# "Talk is cheap, show me the code. ― Linus Torvalds" 

## 資源 
- [Cursor  開發Java](../../../Cursor%20%20開發Java.md)
# Chapter 1：初識Spring (4講)

### 04 | 編寫你的第一個Spring程序 ― [hello-demo]

#### 一、課程目標
- 透過 start.spring.io 快速生成 Spring Boot 專案骨架。
- 理解 Spring Boot 專案結構與核心配置。
- 實作簡單的 REST 控制器，完成 Hello World 範例。
- 了解 Spring Boot 的 Actuator 功能與依賴管理。
- 掌握 Spring Boot 可執行 jar 的打包與運行方式。
- 探討如何自訂 Maven Parent 以管理依賴。

**資源**
- Clone `hello-demo` [GitHub - SpringMicroservicesCourse/hello-demo](https://github.com/SpringMicroservicesCourse/hello-demo)
	- 1.0
	- 1.10-feature-控制器
- 下載及安裝 IntelliJ IDEA Community Edition [Download IntelliJ IDEA](https://www.jetbrains.com/idea/download///?section=mac)

#### 二、Spring Boot 專案生成流程
1. 開啟 [start.spring.io](https://start.spring.io)。
2. 選擇專案類型（Maven/Gradle）、語言（Java）、Spring Boot 版本。
3. 選擇需要的依賴（如 Web、Actuator 等）。
4. 生成並下載專案壓縮包。
5. 使用 IDE（如 IntelliJ IDEA）打開專案。

#### 三、專案結構說明
- Maven 單模組專案。
- 主入口類：帶有 `@SpringBootApplication` 註解。
- `resources` 目錄包含空白配置文件。
- 預設生成測試類骨架。

#### 四、編寫第一個 Hello Spring 控制器
- 使用 `@RestController` 定義控制器。
- 使用 `@RequestMapping` 或 `@GetMapping` 定義路由（如 `/hello`）。
- 回傳字串 "Hello Spring!"。
- 啟動應用後，訪問 `http://localhost:8080/hello` 測試。

#### 五、Spring Boot Actuator
- Actuator 提供健康檢查、監控等功能。
- 依賴由官方嚴格測試，確保無衝突。

#### 六、打包與運行
- 使用 `mvn clean package -Dmanve.test.skip` 生成可執行 jar。
- jar 包包含所有依賴，約23MB。
- 運行方式：`java -jar hello-demo-0.0.1-SNAPSHOT.jar`，無需外部容器。

#### 七、自訂 Maven Parent
- 若需自訂 Parent，可透過 `dependencyManagement` 引入 Spring Boot 依賴管理。
- 保留 Spring Boot 依賴版本管理與打包功能。
- 修改 `pom.xml` 配置即可。
---
# Chapter 2：必知必會 (10講)
### 05 | 如何配置單數據源 ― [datasource-demo, pure-spring-datasource-demo]

#### 一、課程目標
- 在實際應用中，除了簡單的控制器，通常需要與資料庫交互。
- 本章節重點講解如何在Spring應用中配置並使用單一數據源，尤其是JDBC相關操作。

**資源**
- Clone `datasource-demo` [SpringMicroservicesCourse/datasource-demo · GitHub](https://github.com/SpringMicroservicesCourse/datasource-demo)
- Clone `pure-spring-datasource-demo` [SpringMicroservicesCourse/pure-spring-datasource-demo · GitHub](https://github.com/SpringMicroservicesCourse/pure-spring-datasource-demo)

#### 二、使用Spring Boot自動配置數據源
- 利用 [start.spring.io](https://start.spring.io) 選擇依賴：
  - Web、H2內存資料庫、JDBC、Linux相關依賴等。
- Spring Boot根據依賴自動配置：
  - DataSource（數據源）
  - Transaction Manager（事務管理器）
  - JdbcTemplate（JDBC操作模板）
- 配置示例：
  - 內存資料庫名稱：`testdb`
  - 用戶名：`sa`（默認）
  - URL由Spring Boot自動生成，無需手動配置。
- 可透過瀏覽器訪問Actuator端點查看自動配置的Bean。

#### 三、手動配置數據源（非Spring Boot環境）
- 依賴較少，需手動引入資料庫驅動與Spring JDBC。
- 使用DBCP2作為連接池。
- 透過XML或Java配置文件定義：
  - DataSource Bean
  - Transaction Manager Bean
- 需自行管理事務與連接池。

#### 四、Spring Boot自動配置的原理與優勢
- 根據URL自動選擇驅動類。
- 支持自動執行`schema.sql`與`data.sql`初始化資料庫結構與數據。
- 按需加載Bean，若用戶自定義了DataSource，則不再自動配置。
- 減少繁瑣配置，提升開發效率。

#### 五、實戰演示
- 使用JdbcTemplate執行SQL查詢，並將結果輸出到日誌。
- 演示`schema.sql`創建表結構，`data.sql`插入初始數據。
- 程式運行結果展示兩筆數據。

#### 六、課程小結與後續展望
- 透過兩種方式（Spring Boot自動配置與手動配置）理解數據源配置的差異與原理。
- 下一章將介紹多數據源配置，解決多資料庫操作需求。

#### Tips：Lombok 與 H2 資料庫常見問題與設定
##### 1. Lombok 在 IDE 的設定要點

- **安裝 Lombok 插件**
    - IntelliJ IDEA：Settings → Plugins → 搜尋 Lombok → 安裝並重啟
    - Eclipse：下載 lombok.jar，執行 `java -jar lombok.jar`，選擇 Eclipse 目錄安裝，重啟 Eclipse
- **啟用 Annotation Processing**
    - IntelliJ IDEA：Settings → Build, Execution, Deployment → Compiler → Annotation Processors → 勾選「Enable annotation processing」
    - Eclipse：專案右鍵 → Properties → Java Compiler → Annotation Processing → 勾選「Enable project specific settings」與「Enable annotation processing」
- **重新編譯專案**，確保 IDE 正確識別 Lombok 產生的程式碼（如 `log` 變數）
- **Maven 設定**：pom.xml 中需加入 Lombok 依賴，並在 maven-compiler-plugin 設定 annotationProcessorPaths

##### 2. H2 資料庫 schema.sql 建表語法修正

- H2 不支援 `CREATE TABLE FOO (ID INT IDENTITY, BAR VARCHAR(64))`
- 正確寫法應為：
    
    ```
    CREATE TABLE FOO (
      ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      BAR VARCHAR(64)
    );
    ```
    
    或
    
    ```
    CREATE TABLE FOO (
      ID INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
      BAR VARCHAR(64)
    );
    ```
    
- 修改後可避免 Spring Boot 啟動時因語法錯誤導致資料庫初始化失敗
- 從 **Spring Boot 2.4.x** 開始，因為內建H2版本升級，`CREATE TABLE` 中的 `INT IDENTITY` 語法不再被支援，必須改用完整的 `GENERATED BY DEFAULT AS IDENTITY` 或 `GENERATED ALWAYS AS IDENTITY`。
---
### 06 | 如何配置多數據源 [multi-datasource-demo]
#### 一、課程目標

本章節將帶領學生了解如何在Spring微服務架構中配置多個資料源（DataSource），這是實務中常見且重要的需求。透過本課程，學生將學會：

- 如何分離並管理多個資料源的配置，避免混淆與錯誤。
- 掌握Spring Boot自動配置與手動控制多資料源的兩種主要方式。
- 理解在程式中明確指定操作哪個資料源的重要性與實作細節。

此外，建議學生參考Spring官方文件與範例專案，進行實際操作與練習，以加深理解。

#### 二、主體

##### 1. 多資料源配置的基本原則

在實務應用中，當系統需要連接多個資料庫時，必須將每個資料源的設定**分開管理**。例如，若有兩個資料源分別命名為 `foo` 與 `bar`，它們的URL、使用者名稱、密碼等配置都應該獨立設定，避免混淆。即使某些屬性（如下載量）相同，也建議分開配置，方便後續維護與管理。

##### 2. 程式中明確指定資料源的重要性

在操作多資料源時，程式必須**明確告訴系統當前使用的是哪一個資料源**。這包括：

- 指定當前操作的資料源名稱。
- 配合相關環境（如iMac或MacOS）確保資料源切換正確。

由於部分框架可能無法自動判斷使用哪個資料源，開發者需在程式碼中格外小心，避免資料錯用或交易錯亂。

##### 3. 多資料源的兩種配置方式

###### (1) 完全手動控制配置

將Spring Boot的自動配置功能（如DataSource、DataSourceAttributesManager、SynCityManagement等）**全部排除（exclude）**，由開發者自行在程式碼中定義與管理多個資料源。這種方式靈活度高，適合複雜需求，但需要較多的程式碼與維護成本。

###### (2) 利用Spring Boot自動配置結合Primary標記

在多個DataSource中，指定其中一個為**Primary**，讓Spring Boot自動配置時優先使用該資料源。這種方式較為簡單，適合兩個資料源中有主次之分的情況。

#### 三、實戰演示

以實際範例說明如何在Spring Boot應用中配置兩個資料源：

- 在配置檔中分別設定兩個資料源的URL與名稱，確保彼此獨立。
- 在程式碼中排除Spring Boot的自動配置，手動定義兩個DataSource與對應的TransactionManager。
- 透過日誌輸出確認每個資料源的URL是否正確被讀取。
- 在應用介面（如bins頁面）檢查資料源與交易管理器的依賴關係，確保配置生效。

此範例展示了如何在實際應用中清楚區分並操作多個資料源，避免混淆與錯誤。

#### 四、課程小結與後續展望

本章節介紹了兩種多資料源配置方式：

- **完全手動控制**：彈性高，適合複雜場景，但開發與維護成本較高。
- **結合Spring Boot自動配置與Primary標記**：簡化設定，適合有主次資料源的應用。

學生應根據實際需求選擇合適方式，並在程式中明確指定資料源，確保資料操作正確。

下一章節將深入探討多資料源配置的進階技巧與實務應用，幫助學生建立更完整的Spring微服務架構知識體系。

#### 五、Tips：

- 多資料源配置時，務必保持配置檔清晰且分離，避免混淆。
- 在程式中操作資料源時，使用明確的命名與標記（如@Primary、@Qualifier）來區分。
- 排除Spring Boot自動配置時，需自行管理交易管理器，確保資料一致性。
- 測試階段多利用日誌輸出確認資料源切換是否正確。
- 參考Spring官方文件與社群範例，持續優化多資料源管理策略。
---
### 08 | 那些好用的連接池們：Alibaba Druid ― [druid-demo]

#### 一、課程目標

本章節將帶領學生深入了解阿里巴巴開源的Druid資料庫連接池，重點在於其在Spring微服務架構中的應用與配置。學生將學習Druid強大的監控功能、SQL防注入機制、密碼加密配置，以及如何利用其豐富的擴展點進行自訂化開發。透過理論與實務結合，幫助學生掌握提升資料庫連接穩定性與安全性的關鍵技術。

相關資源連結：
- Druid官方GitHub：https://github.com/alibaba/druid
- Druid中文文檔與配置說明（官方文檔內含詳細範例）
- Spring Boot官方文檔（關於資料源配置部分）

#### 二、Druid資料庫連接池介紹與核心功能

Druid是阿里巴巴開源的資料庫連接池，經過多個大型系統（如雙11電商平台）的嚴苛考驗，具備高度的可靠性與性能。其設計重點在於**強大的監控能力**，能夠即時發現並診斷資料庫連接與SQL執行過程中的問題，且監控過程對系統性能影響極小。

Druid的核心功能包括：
- **詳細監控**：提供全面的資料庫狀態與SQL執行情況監控，方便運維與開發人員快速定位問題。
- **ExceptionSorter**：針對主流資料庫的錯誤碼進行分類與處理，提升錯誤恢復能力。
- **SQL防注入**：內建防止SQL注入攻擊的機制，保障資料安全。
- **密碼加密配置**：支援資料庫連接密碼的加密，提升安全性。
- **豐富的擴展點**：允許開發者在資料庫操作的各個環節插入自訂邏輯，靈活應對複雜需求。

這些功能使Druid不僅是一個連接池，更是一個強大的資料庫監控與安全管理工具。

#### 三、Druid在Spring微服務中的配置與使用

在Spring Boot環境中，Druid的配置相對簡單，主要透過`spring.datasource.druid.*`屬性進行設定。常見配置項目包括：

- **資料源基本參數**：URL、用戶名、密碼（可加密）
- **Filter配置**：如`stat`（統計監控）、`wall`（防注入）、`log4j`（日誌記錄）
- **密碼加密**：
  - 啟用加密功能：`spring.datasource.druid.filter.config.enabled=true`
  - 配置解密密鑰：`spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key=<public-key>`
- **SQL防注入設置**：
  - 啟用Wall Filter：`spring.datasource.druid.filter.wall.enabled=true`
  - 設定資料庫類型與限制操作（如禁止刪除、禁止Drop表）

此外，若專案中原本使用HikariCP，需在引入Druid Starter時排除HikariCP，避免衝突。

#### 四、Druid擴展點與自訂Filter實作

Druid提供多個擴展點，允許開發者在資料庫連接的不同階段插入自訂邏輯。這些擴展點涵蓋連接建立前後、SQL執行前後、結果返回後等環節。

實作自訂Filter的方式：
- 繼承`FilterEventAdapter`類別，覆寫需要的事件方法，如`connection_connectBefore`、`connection_connectAfter`等。
- 在Filter中加入自訂邏輯，例如日誌輸出、SQL追蹤、參數檢查等。
- 將自訂Filter配置到Druid的Filter列表中，實現自動生效。

範例說明：
- 在連接建立前後輸出日誌，方便追蹤連接狀態。
- 利用Filter攔截SQL，加入Trace ID，實現分布式追蹤。

這種設計讓Druid不僅是連接池，更成為資料庫操作的中介層，靈活且強大。

#### 五、實戰演示

示範如何在Spring Boot專案中：
- 排除HikariCP，導入Druid Starter。
- 配置Druid資料源，包括密碼加密與Wall Filter防注入。
- 實作並註冊自訂Filter，觀察連接建立前後的日誌輸出。
- 使用Druid提供的Web監控界面，實時查看資料庫連接狀態與SQL執行情況。

透過實作，學生能夠理解Druid的配置細節與擴展機制，並掌握如何在微服務架構中提升資料庫連接的安全性與可觀察性。

#### 六、課程小結與後續展望

本章節介紹了Druid資料庫連接池的核心功能與在Spring微服務架構中的應用，重點包括監控能力、SQL防注入、密碼加密與擴展點自訂。Druid相較於其他連接池（如HikariCP），在監控與安全性方面提供了更多內建支持，但配置較為複雜，需要根據需求靈活調整。

後續章節將介紹多數據源配置，幫助學生掌握在微服務中如何管理多個資料庫連接，進一步提升系統的靈活性與擴展性。

#### 七、Tips

- 使用Druid時，務必排除其他連接池（如HikariCP）以避免衝突。
- 密碼加密功能提升安全性，但需妥善管理解密密鑰。
- 自訂Filter是Druid強大擴展性的關鍵，適合實現業務特定需求，如SQL追蹤、參數校驗等。
- 監控界面是運維的重要工具，建議在生產環境中啟用並定期檢查。
- SQL防注入配置需根據實際資料庫類型調整，避免誤判正常操作。
---
### 09 | 如何通過Spring JDBC訪問資料庫 ― [simple-jdbc-demo]
#### 一、課程目標

本章節將帶領大家深入了解如何在Spring框架中使用Spring JDBC進行資料庫操作。重點涵蓋Spring JDBC的核心組件、常用的JDBC Template操作方法，以及如何透過註解定義Bean來組織資料存取層。學習後，學生能夠掌握Spring JDBC的基本用法，並能實作增刪改查及批次操作，為後續微服務架構中資料存取打下堅實基礎。

相關資源連結：
- Spring官方文件（Spring JDBC部分）
- 範例程式碼庫（包含JDBC Template增刪改查與批次操作）
- 線上SQL練習平台，方便實際操作SQL語句

#### 二、Spring JDBC架構與核心組件介紹

Spring JDBC主要包含四大部分：

1. **核心部分**：以JdbcTemplate為核心，提供簡化JDBC操作的API，包含增刪改查等方法，讓開發者不必直接操作繁瑣的JDBC程式碼。
2. **DataSource**：負責資料庫連線管理，Spring提供多種DataSource實作，並支援連線池。
3. **Object部分**：將JDBC操作封裝成可重用的物件，方便管理與擴展。
4. **Support工具**：包含各種輔助工具，如簡化程式碼的工具類別。

這四部分共同構成了Spring JDBC的完整生態，讓資料庫操作更為簡潔且易於維護。

#### 三、Spring Bean定義與註解說明

在Spring中，Bean的定義是核心概念，常用的註解包括：

- **@Component**：通用的Bean定義註解，適用於任何組件。
- **@Repository**：專門用於資料存取層（DAO），標示該Bean負責資料庫操作，並可啟用Spring的例外轉換機制。
- **@Service**：用於業務邏輯層。
- **@Controller**與**@RestController**：用於Web層，後者特別適合開發RESTful服務。

建議將所有資料庫操作放在標註了@Repository的Bean中，保持架構清晰。

#### 四、JdbcTemplate的基本操作

JdbcTemplate是Spring JDBC的核心，提供多種方法來執行SQL：

- **查詢操作**：
  - `queryForObject`：查詢單一結果，適合計數或單筆資料。
  - `queryForList`：查詢多筆資料，回傳List。
  - `query`搭配RowMapper：將查詢結果映射成自訂物件。
- **增刪改操作**：
  - `update`：執行INSERT、UPDATE、DELETE語句。
- **NamedParameterJdbcTemplate**：支援使用命名參數，提升SQL語句可讀性。

範例說明：  
使用`@Repository`註解的DAO中注入JdbcTemplate，透過`update`方法插入資料，使用`queryForObject`取得計數結果，並用`query`搭配RowMapper將資料映射成物件列表。

#### 五、物件映射與Lambda簡化

為了將查詢結果轉換成Java物件，Spring JDBC提供了RowMapper介面。利用Java 8的Lambda表達式，可以簡化RowMapper的實作，使程式碼更簡潔易懂。

例如，將資料庫欄位映射到物件屬性，只需在Lambda中定義set方法，提升開發效率。

#### 六、SingleJdbcInsert的應用

SingleJdbcInsert是Spring JDBC提供的輔助類別，專門用於簡化插入操作，特別是當需要取得自動生成的主鍵時非常方便。

使用時只需設定DataSource與表名，呼叫`executeAndReturnKey`即可取得主鍵值，避免手動撰寫複雜的SQL。

#### 七、批次操作（Batch Processing）

在實務中，批次插入大量資料是常見需求。Spring JDBC提供兩種批次操作方式：

1. **JdbcTemplate的batchUpdate**：透過傳入PreparedStatementSetter，逐筆設定參數，執行批次更新。
2. **NamedParameterJdbcTemplate的batchUpdate**：使用命名參數，將參數集合一次傳入，簡化批次操作。

範例中展示如何使用這兩種方式插入多筆資料，並印出結果，提升資料庫操作效率。

#### 八、實戰演示

- 建立一個標註@Repository的DAO類別，注入JdbcTemplate。
- 實作插入單筆資料、查詢單筆與多筆資料，並將結果映射成物件。
- 使用SingleJdbcInsert插入資料並取得主鍵。
- 實作批次插入，展示兩種批次操作方式的差異與使用場景。
- 執行程式，觀察輸出結果，確認資料正確寫入與查詢。

#### 九、課程小結與後續展望

本章節介紹了Spring JDBC的核心組件與基本操作，並透過範例展示了增刪改查及批次操作的實作方式。  
重點整理：
- JdbcTemplate簡化了JDBC操作，提升開發效率。
- 使用@Repository註解明確分層，方便維護。
- SingleJdbcInsert方便取得自動生成主鍵。
- 批次操作有效提升大量資料處理效能。

下一章節將帶大家學習多數據源配置，進一步掌握複雜微服務架構中資料庫的管理與切換，敬請期待。

#### 十、Tips：

- 使用JdbcTemplate時，注意SQL語句的安全性，避免SQL注入。
- RowMapper可利用Lambda簡化，提升程式可讀性。
- 批次操作時，根據資料量選擇合適的批次大小，避免一次過大造成效能瓶頸。
- SingleJdbcInsert適合簡單插入並需取得主鍵的場景，複雜操作仍建議使用JdbcTemplate。
---
### 10 | 什麼是Spring的事務抽象（上）
---
### 11 | 什麼是Spring的事務抽象（下）― [programmatic-transaction-demo]
#### 一、課程目標

本章節將介紹Spring微服務架構中**編程式事務管理（Programmatic Transaction Management）**的實作方式，讓學生了解如何透過程式碼精確控制事務的開始、提交與回滾。學習重點包括：

- 使用Spring的TransactionTemplate進行編程式事務管理。
- 理解事務的原子性與回滾機制。
- 透過實例掌握事務執行過程中資料狀態的變化。
- 比較編程式事務與註解式事務的差異與應用場景。

相關資源：

- Spring官方事務管理指南：https://spring.io/guides/gs/managing-transactions/
- 範例專案程式碼（含TransactionTemplate示範）

#### 二、編程式事務管理的核心概念與技術棧

在Spring微服務架構中，除了常用的註解式事務管理（@Transactional）外，還可以使用**編程式事務管理**，透過TransactionTemplate在程式中明確控制事務範圍與行為。

本示範專案採用技術包括：

- Java 17與Spring Boot 3.4.5
- Spring JDBC與JdbcTemplate進行資料庫操作
- H2內存資料庫作為測試環境
- Maven管理專案依賴

這種方式適合需要動態決定事務行為的複雜場景，提供更細粒度的控制。

#### 三、TransactionTemplate的使用與事務回滾示範

TransactionTemplate是Spring提供的編程式事務管理工具，使用時透過execute方法包裹事務邏輯：

- 在execute方法中，開啟一個事務範圍，所有資料庫操作都在此範圍內執行。
- 可以透過TransactionStatus物件動態設定是否回滾，例如呼叫`setRollbackOnly()`強制回滾。
- 這種方式比起註解式事務，能更靈活地控制事務行為，適合需要根據條件決定是否回滾的業務邏輯。

範例中，程式碼先查詢資料庫中資料數量，然後在事務中插入一筆資料，接著手動設置回滾，最後再次查詢資料數量，結果顯示資料未被永久寫入，證明事務的原子性。

#### 四、資料庫結構與專案架構說明

專案中使用H2內存資料庫，啟動時自動建立一個簡單的FOO表：

- FOO表包含ID（自動生成主鍵）與BAR欄位（字串）。
- JdbcTemplate用於執行SQL語句，操作資料庫。

專案結構清晰，主應用程式位於`ProgrammaticTransactionDemoApplication.java`，負責事務示範與日誌輸出。

#### 五、實戰演示流程解析

1. 啟動應用程式，建立FOO表。
2. 查詢並記錄交易前FOO表的資料數量。
3. 使用TransactionTemplate執行事務：
   - 在事務中插入一筆資料。
   - 查詢並記錄事務中資料數量（此時資料可見）。
   - 呼叫`setRollbackOnly()`，手動標記事務回滾。
4. 事務結束後，再次查詢資料數量，確認資料未被保存。

透過日誌輸出，學生可以清楚看到事務前、中、後資料狀態的變化，理解事務的原子性與回滾機制。

#### 六、課程小結與後續展望

本章節重點在於掌握Spring中編程式事務管理的實作技巧，理解TransactionTemplate的使用場景與優勢。與註解式事務相比，編程式事務提供更靈活的控制，但程式碼較為冗長。

後續章節將介紹註解式事務的使用與限制，並深入探討Spring事務代理機制，幫助學生建立完整的事務管理知識體系。

#### 七、Tips：

- 編程式事務適合需要根據複雜條件動態決定回滾的場景。
- 使用TransactionTemplate時，務必確保所有資料庫操作都在execute方法內完成，避免事務失效。
- H2內存資料庫適合快速測試與學習，實務中請根據需求選擇合適的資料庫。
- 透過日誌觀察事務生命週期，有助於理解事務的開始、提交與回滾時機。
- 在微服務架構中，事務管理是確保資料一致性的關鍵，建議多做實驗與測試。
---
### 12 | 瞭解Spring的 JDBC異常抽象 ― [errorcode-demo]
#### 一、課程目標

本章節將帶領大家深入了解Spring框架中對JDBC異常的抽象與統一處理機制。學習重點包括：

- 理解Spring如何將不同資料庫的異常代碼統一轉換為Data Access Exception層次結構，方便異常處理。
- 掌握Spring內建的SQL錯誤碼映射機制及其配置方式。
- 學習如何自定義SQL錯誤碼映射，實現業務特定的異常處理。
- 透過實戰演示，了解如何在Spring中進行異常測試與定制。

實務意義：透過統一異常抽象，開發者能夠撰寫與資料庫無關的異常處理邏輯，提升系統的可維護性與擴展性。

推薦資源：

- Spring官方文件中關於JDBC異常處理章節
- Spring JDBC Support套件源碼與配置範例
- H2內存資料庫，方便快速測試與演示

#### 二、Spring的JDBC異常抽象概述

Spring框架提供了一套統一的異常抽象層，稱為Data Access Exception。這個層次結構將各種資料庫操作中可能出現的異常，如違反約束、重複鍵、資料過期等，統一封裝成Spring定義的異常類別。

重點標籤：#DataAccessException #異常抽象 #統一異常處理

這樣的設計讓開發者無論使用哪種資料庫（Oracle、MySQL、PostgreSQL等），或是使用JDBC、Hibernate等不同的資料存取技術，都能以一致的方式捕捉和處理異常，避免了因資料庫錯誤碼差異而導致的複雜判斷。

#### 三、Spring如何識別並轉換資料庫異常

Spring內部透過SQL Error Code Translator機制，將各資料庫特有的錯誤碼映射到對應的Data Access Exception子類。這些錯誤碼定義存放於spring-jdbc模組的support包中，並以配置文件形式管理。

重點標籤：#SQLErrorCodeTranslator #錯誤碼映射 #spring-jdbc

舉例來說，MySQL的錯誤碼102代表重複鍵違反約束，Spring會將此錯誤碼自動轉換成DuplicateKeyException異常。這種映射關係讓異常處理邏輯與資料庫細節解耦。

此外，Spring允許開發者自定義錯誤碼映射配置，覆蓋官方預設，滿足特定業務需求。

#### 四、自定義SQL錯誤碼映射的實作

在實務中，可能會遇到代理層或特殊資料庫錯誤碼，官方配置無法涵蓋。此時，我們可以透過新增自定義的SQL Error Code配置文件，將特定錯誤碼映射到自定義的異常類別。

重點標籤：#自定義錯誤碼 #異常定制 #業務需求

範例說明：

- 使用H2內存資料庫作為測試環境。
- 在官方H2錯誤碼配置基礎上，追加Personal Translations配置。
- 將錯誤碼2301和23505映射到自定義的Personal Directed Key異常。
- 透過JUnit測試驗證異常是否正確拋出。

這種方式讓我們能夠靈活控制異常行為，提升系統的健壯性與可控性。

#### 五、實戰演示：Spring中JDBC異常的測試與定制

本段將示範如何在Spring專案中：

- 引入spring-jdbc依賴與H2資料庫。
- 編寫SQL操作，故意觸發違反唯一鍵約束的異常。
- 使用JUnit測試捕捉並驗證自定義異常是否被正確拋出。
- 展示如何配置並覆蓋官方SQL錯誤碼映射。

透過實際操作，學生能夠更直觀理解Spring異常抽象的運作流程與定制方法。

#### 六、課程小結與後續展望

本章節我們學習了Spring如何透過Data Access Exception層次結構，統一處理來自不同資料庫的異常，並且掌握了錯誤碼映射的原理與自定義方法。

兩種配置方式比較：

- 官方預設錯誤碼映射：方便快速使用，適合大多數場景。
- 自定義錯誤碼映射：靈活應對特殊業務需求，但需額外維護配置。

後續章節將介紹多數據源配置，幫助大家進一步掌握Spring微服務架構中複雜資料庫環境的管理與應用。

#### 七、Tips

- 異常抽象有助於提升代碼的可移植性與維護性，建議在專案初期就規劃好異常處理策略。
- 自定義錯誤碼映射時，務必確保異常類別繼承自Spring的DataAccessException，否則可能導致異常捕捉失敗。
- 利用內存資料庫（如H2）進行異常測試，能快速驗證配置效果，避免影響生產環境。
- 深入閱讀spring-jdbc的support包源碼，有助於理解異常轉換的細節與擴展點。
---
# Chapter 3：O-R-Mapping實踐 (9講)
### 15 | 認識Spring Data JPA
---
### 16 | 定義JPA的實體物件
---
### 17 | 開始我們的線上咖啡館實戰專案：SpringBucks ― [jpa-demo]
#### 一、課程目標

本章節將帶領學生深入理解並實作Spring微服務架構中，如何利用Spring Boot與Spring Data JPA進行物件關聯對應（ORM）。透過實際的咖啡訂單管理系統示範專案，學生將學會：

- Spring Data JPA的核心概念與實作方式
- 如何定義實體類別(Entity)及其關聯
- 使用JPA屬性轉換器(AttributeConverter)處理複雜資料型態（如金額）
- 實作資料庫操作與初始化測試資料
- 掌握Spring Boot專案的建置與執行流程

此外，將提供GitHub專案連結，方便學生下載範例程式碼並進行實務練習。

相關資源連結：
- 專案GitHub：[SpringMicroservicesCourse/jpa-demo](https://github.com/SpringMicroservicesCourse/jpa-demo)

#### 二、Spring微服務架構中的ORM實作核心概念

在微服務架構中，資料持久化是不可或缺的一環。Spring Data JPA提供了方便的ORM解決方案，讓Java物件與資料庫表格之間的映射變得簡單且直觀。

1. **實體類別(Entity)定義**  
   實體類別是資料庫表格的映射對象。以咖啡訂單系統為例，定義了`Coffee`與`CoffeeOrder`兩個實體。  
   - `@Entity`標記類別為JPA實體  
   - `@Table`指定對應資料表名稱  
   - 使用Lombok註解如`@Data`、`@Builder`簡化程式碼  
   - 透過`@Id`與`@GeneratedValue`定義主鍵與自動生成策略  
   - 利用`@ManyToMany`建立多對多關聯，並用`@JoinTable`指定關聯表  

2. **屬性轉換器(AttributeConverter)應用**  
   金額類型使用Joda Money函式庫，為了將Money物件正確存取於資料庫，實作了`MoneyConverter`轉換器。  
   - `@Converter(autoApply = true)`自動應用於所有Money欄位  
   - 將Money物件轉換為資料庫可存儲的Long型態（以分為單位）  
   - 反向轉換時恢復Money物件，確保金額精確性  

3. **時間戳記管理**  
   使用`@CreationTimestamp`與`@UpdateTimestamp`自動記錄資料建立與更新時間，方便追蹤資料變更歷程。

4. **訂單狀態管理**  
   訂單狀態使用列舉型態`OrderState`，並以`@Enumerated`標記，確保狀態欄位的可讀性與一致性。

#### 三、實戰演示：Spring Boot JPA咖啡訂單管理系統

本專案示範如何結合Spring Boot與JPA完成一個簡單的咖啡訂單系統。

1. **專案結構說明**  
   - `model`資料夾：定義實體類別與轉換器  
   - `repository`資料夾：定義資料存取介面，繼承Spring Data JPA的Repository  
   - 主類別`JpaDemoApplication`：啟動應用並初始化測試資料  

2. **初始化測試資料**  
   在應用啟動時，透過`ApplicationRunner`介面執行`initOrders()`方法，建立兩種咖啡（espresso與latte）及一筆包含多品項的訂單。  
   這樣的設計讓學生能快速看到資料庫操作的結果，並理解實體與資料庫的映射關係。

3. **建置與執行流程**  
   - 使用JDK 21與Maven 3.6以上版本  
   - 透過Git克隆專案，進入目錄後執行`mvn clean package`建置  
   - 使用`mvn spring-boot:run`啟動應用  
   - 預設使用H2記憶體資料庫，方便快速測試與開發  

4. **資料庫設定與測試資料**  
   - H2資料庫連線資訊簡單，無需額外設定  
   - 啟動時自動建立測試資料，方便驗證功能  

#### 四、課程小結與後續展望

本章節透過Spring Boot與Spring Data JPA的實作，讓學生掌握了微服務架構中資料持久化的核心技術。重點包括：

- 實體類別的定義與關聯映射
- 屬性轉換器的應用，解決複雜資料型態的存取問題
- 自動時間戳記管理
- Spring Boot專案的建置與執行流程

兩種配置方式的差異與優缺點：

- 使用JPA自動生成資料表結構，方便快速開發，但對於複雜資料結構需額外設計轉換器
- 使用記憶體資料庫適合開發與測試，生產環境則需切換至持久化資料庫

後續章節將介紹多數據源配置，幫助學生理解如何在微服務架構中管理多個資料庫連線，提升系統的擴展性與彈性。

#### 五、Tips

- 金額處理務必使用專業函式庫（如Joda Money），避免浮點數誤差  
- 使用`@Convert`自訂轉換器，能有效解決資料庫與物件型態不匹配問題  
- 利用Lombok簡化實體類別程式碼，提高開發效率  
- H2資料庫適合快速開發與測試，生產環境請選擇適合的關聯式資料庫  
- 建議在專案中加入日誌功能，方便追蹤資料操作與除錯  
---
### 18 | 通過Spring Data JPA操作資料庫 ― [jpa-complex-demo]
#### 一、課程目標

本章節將帶領學生深入理解如何使用Spring Data JPA操作資料庫，並結合Spring微服務架構實務應用。學生將學會如何定義實體類別（Entity）、建立Repository介面以簡化資料存取，並掌握常用的查詢方法與分頁排序技巧。透過實際的咖啡訂單系統示範專案，學生能夠理解物件關聯對應（O-R Mapping）的實作方式，並熟悉Spring Boot與JPA的整合開發流程。

相關資源連結：
- 專案GitHub：https://github.com/SpringMicroservicesCourse/jpa-complex-demo
- Spring Data JPA官方文件：https://spring.io/projects/spring-data-jpa
- JPA教學與範例：https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa

#### 二、Spring Data JPA與Repository的核心概念

Spring Data JPA提供了一套強大的資料存取抽象層，讓開發者不需撰寫繁複的SQL語句，即可透過定義介面來完成CRUD操作。重點在於：

- **Repository介面**：只需定義介面並繼承Spring Data提供的CRUD Repository、PagingAndSortingRepository或JpaRepository，Spring會自動生成實作類別。
- **自動註冊**：使用@EnableJpaRepositories註解後，Spring會自動掃描並註冊所有Repository介面。
- **查詢方法命名規則**：透過方法名稱如findBy、readBy、getBy等，結合屬性名稱與條件（如And、Or、Top、First），即可自動生成對應的查詢語句。
- **排序與分頁**：利用Sort類別與Pageable介面，輕鬆實現資料排序與分頁功能。

這種設計大幅降低了資料存取層的開發複雜度，讓開發者專注於業務邏輯。

#### 三、實體類別與資料模型設計

在本專案中，實體類別使用JPA註解來定義資料表結構與關聯，例如：

- **Coffee實體**：代表咖啡商品，包含名稱、價格（使用Joda Money確保貨幣計算精確性）等屬性。
- **Order實體**：代表訂單，與多個Coffee實體形成一對多關聯。
- 使用Lombok簡化getter/setter與建構子，減少樣板程式碼。

透過這樣的設計，實體類別不僅映射資料庫表結構，也清楚表達了業務模型間的關係。

#### 四、實作範例：咖啡訂單系統操作流程

1. **建立實體物件**  
   以Coffee為例，使用Builder模式建立一個Espresso咖啡物件，設定名稱與價格。

2. **保存資料**  
   透過CoffeeRepository的save方法，將Coffee物件存入資料庫。Hibernate會自動生成ID並回寫至物件。

3. **建立訂單**  
   建立Order物件，並將多個Coffee物件加入訂單項目中，最後透過OrderRepository保存。

4. **查詢資料**  
   使用Spring Data JPA提供的findBy方法，根據條件查詢資料，例如findByItemsName查找包含特定咖啡名稱的訂單。

5. **排序與分頁**  
   利用Sort與Pageable參數，實現依ID排序或分頁查詢，提升資料查詢效率。

這些操作展示了Spring Data JPA如何簡化資料庫操作，並且與Spring Boot整合實現微服務架構中的資料管理。

#### 五、實戰演示

請同學們下載並執行示範專案：

- 克隆專案：`git clone https://github.com/SpringMicroservicesCourse/jpa-complex-demo`
- 編譯專案：`mvn clean install`
- 啟動專案：`mvn spring-boot:run`

運行後，觀察控制台輸出，理解資料的新增、查詢與關聯操作。特別注意：

- Hibernate自動生成的SQL語句
- 實體物件ID與時間戳的自動回寫
- 複雜查詢中Left Join的使用

透過實際操作，加深對Spring Data JPA的理解。

#### 六、課程小結與後續展望

本章節重點在於掌握Spring Data JPA的Repository設計與使用，理解如何透過命名規則快速定義查詢方法，並熟悉實體類別與資料庫的映射關係。兩種主要的資料操作方式——直接使用CRUD Repository與自訂複雜查詢方法——各有優缺點：

- **CRUD Repository**：簡單易用，適合基本資料操作。
- **自訂查詢方法**：靈活強大，適合複雜業務需求，但需注意命名規則與效能。

下一章節將介紹多數據源配置，幫助學生理解如何在微服務架構中管理多個資料庫連線，進一步提升系統的擴展性與彈性。

#### 七、Tips：

- 使用Spring Data JPA時，盡量遵循命名規則，避免手寫SQL，提升開發效率。
- 分頁查詢時，務必使用PagingAndSortingRepository或JpaRepository，確保分頁功能正常。
- 實體類別中使用Money類型處理貨幣，避免浮點數計算誤差。
- 開發過程中多利用IDE的跳轉功能查看Spring Data JPA的內部實作，幫助理解底層機制。
- 在複雜查詢中，適當使用@Transactional註解管理事務，確保資料一致性。
---
### 19 | Spring Data JPA的Repository是怎麼從接口變成Bean的
---
### 20 | 通過MyBatis操作數據庫 ― [mybatis-demo]
#### 一、課程目標

本章節將帶領學生深入了解如何在Spring微服務架構中，利用Spring Boot與MyBatis實作物件關聯對應（ORM）。透過一個咖啡訂單管理系統示範專案，學生將學會如何設計資料模型、撰寫Mapper介面進行資料存取，以及撰寫單元測試驗證功能。學習重點包括MyBatis的基本使用、資料庫欄位與Java物件的映射技巧，以及Spring Boot整合測試的實務操作。

實務意義在於掌握ORM技術，能有效提升微服務中資料存取的效率與維護性，並為後續複雜微服務架構的資料管理打下基礎。

推薦資源連結：
- MyBatis官方文件：https://mybatis.org/mybatis-3/
- Spring Boot官方文件：https://spring.io/projects/spring-boot
- H2資料庫介紹：https://www.h2database.com/html/main.html

#### 二、專案架構與技術介紹

本示範專案基於Spring Boot 3.4.5與MyBatis 3.0.3，使用Java 21開發，搭配H2記憶體資料庫，並利用Lombok簡化Java程式碼。專案結構清晰，分為資料模型（model）、資料存取層（mapper）與測試程式碼（test）三大部分。

- **資料模型**：定義咖啡實體類別，包含id、名稱、價格、建立與更新時間等欄位。
- **資料存取層**：使用MyBatis Mapper介面，透過註解方式撰寫SQL語句，實現資料的新增與查詢。
- **測試程式碼**：利用Spring Boot測試框架，撰寫單元測試驗證資料存取功能的正確性。

此架構示範了微服務中常見的資料存取設計模式，強調分層與模組化，方便維護與擴充。

#### 三、核心技術詳解

1. **咖啡實體類別（Coffee.java）**

   使用Lombok註解如`@Data`、`@Builder`等，簡化getter/setter與建構子撰寫。`Money`類型用於表示價格，確保貨幣與數值的正確性。此類別是資料庫中t_coffee表的映射，實現物件與資料表欄位的對應。

2. **資料存取介面（CoffeeMapper.java）**

   利用`@Mapper`標記為MyBatis Mapper，並用`@Insert`與`@Select`註解定義SQL語句。`@Options(useGeneratedKeys = true, keyProperty = "id")`確保新增資料時自動產生主鍵並回填至物件。`@Results`註解用於處理資料庫欄位與Java屬性的映射，解決命名不一致問題。

3. **單元測試（MybatisDemoApplicationTests.java）**

   使用`@SpringBootTest`啟動完整Spring上下文，並透過`@Autowired`注入Mapper。測試流程包括建立測試資料、執行儲存與查詢操作，最後驗證資料正確性。此測試確保資料存取層功能正常，提升系統穩定度。

#### 四、資料庫設計與設定

專案採用H2記憶體資料庫，方便開發與測試。資料表t_coffee結構包含自增主鍵id、名稱name、價格price（以bigint存儲貨幣單位）、建立與更新時間。資料庫連線設定位於`application.properties`，預設使用H2，無需額外安裝。

此設計適合微服務中輕量級資料存取需求，且易於擴展至其他資料庫。

#### 五、建置與執行流程

1. 確認環境：JDK 21以上、Maven 3.6以上。
2. 下載專案：使用git clone指令取得原始碼。
3. 進入專案目錄，執行`mvn clean package`進行建置。
4. 使用`mvn spring-boot:run`啟動應用程式。
5. 執行`mvn test`驗證單元測試。

此流程展示了Spring Boot專案的標準開發與測試步驟，方便學生實際操作與理解。

#### 六、課程小結與後續展望

本章節透過Spring Boot與MyBatis示範專案，讓學生掌握了ORM的基本實作方法，理解了資料模型設計、Mapper介面撰寫與單元測試的重要性。兩種配置方式（註解SQL與XML配置）各有優缺點，註解方式簡潔直觀，適合簡單場景；XML配置則更靈活，適合複雜查詢。

後續章節將介紹多數據源配置，幫助學生學習如何在微服務架構中管理多個資料庫連線，進一步提升系統的擴展性與彈性。

#### 七、Tips

- 使用Lombok可大幅減少樣板程式碼，但需確保IDE已安裝相應插件。
- `@Options(useGeneratedKeys = true, keyProperty = "id")`是MyBatis自動回填主鍵的關鍵設定，避免手動設定主鍵錯誤。
- 單元測試中，建議使用記憶體資料庫（如H2）以加快測試速度並避免資料污染。
- 遇到資料庫欄位與Java屬性命名不一致時，務必使用`@Results`或XML映射明確對應，避免資料錯亂。
- 常見JVM警告通常不影響程式執行，可暫時忽略，但建議持續關注官方更新。
---
### 21 | 讓MyBatis更好用的那些工具：MyBatis Generator ― [mybatis-generator-demo]
#### 一、課程目標

本章節將帶領學生深入了解如何在Spring微服務架構中，利用MyBatis Generator自動化產生資料存取層程式碼，提升開發效率與維護性。學生將學會：

- MyBatis Generator的配置與使用方法
- 如何解決H2資料庫主鍵自動產生的問題
- 整合Joda Money處理金額型別的技巧
- 自訂TypeHandler以應對複雜資料型別轉換
- 使用相對路徑設定，提升專案的可移植性與靈活性

此外，提供實戰專案範例與相關資源，方便學生實際操作與練習。

相關資源連結：
- [Spring Boot 官方網站](https://spring.io/projects/spring-boot)
- [MyBatis Generator 官方文件](http://mybatis.org/generator/)
- [H2 Database 官方文件](https://www.h2database.com/html/main.html)
- [Joda Money 官方文件](https://www.joda.org/joda-money/)

#### 二、MyBatis Generator簡介與使用

MyBatis Generator是MyBatis官方提供的程式碼自動生成工具，能根據資料庫表結構自動產生Model類別、Mapper介面及對應的XML SQL映射檔。這大幅減少手寫SQL與資料存取程式碼的工作量，降低錯誤率。

MyBatis Generator的執行方式多樣，包括：

- 直接命令列執行，傳入配置檔
- Maven插件執行（最常用）
- Gradle插件執行
- 程式碼呼叫API執行
- Ant任務執行（較少使用）

本課程將以Maven插件與程式碼呼叫兩種方式為主，示範如何整合於Spring Boot專案中。

#### 三、MyBatis Generator配置詳解

MyBatis Generator的核心配置檔為XML格式，主要包含以下幾個部分：

- **generatorConfiguration**：整體設定容器
- **context**：定義生成環境與目標資料庫連線資訊
- **jdbcConnection**：資料庫連線設定（URL、帳號、密碼）
- **javaModelGenerator**：Model類別生成路徑與包名
- **sqlMapGenerator**：XML映射檔生成路徑與包名
- **javaClientGenerator**：Mapper介面生成路徑與包名
- **table**：指定要生成的資料表及其細節設定

重點說明：

- **主鍵自動產生**：使用`<generatedKey column="id" sqlStatement="JDBC" identity="true"/>`，確保H2資料庫與其他JDBC相容資料庫的主鍵生成一致性。
- **自訂欄位型別處理器**：透過`<columnOverride>`指定特定欄位使用自訂TypeHandler，例如將BIGINT型別轉換為Joda Money物件，方便金額資料的專業處理。
- **生成策略**：可選擇純注解、純XML或混合方式，根據專案需求靈活調整。

配置檔中插件（plugin）順序需特別注意，必須先定義插件，再設定資料庫連線與生成目標，避免生成錯誤。

#### 四、專案架構與核心程式碼解析

本專案以Spring Boot 3.x為基礎，結合MyBatis Generator與H2記憶體資料庫，實作一個線上咖啡館系統的資料存取層。

專案結構清晰分工：

- `model/`：自動生成的實體類別（如Coffee.java）
- `mapper/`：自動生成的Mapper介面（如CoffeeMapper.java）
- `handler/`：自訂型別處理器（如MoneyTypeHandler.java）
- `resources/`：配置檔與SQL映射XML檔

主程式`MybatisGeneratorDemoApplication.java`包含兩大功能：

1. **generateArtifacts()**：執行MyBatis Generator，根據`generatorConfig.xml`產生Model、Mapper與XML檔案。此方法使用相對路徑設定，確保跨環境可用。

2. **playWithArtifacts()**：示範資料庫操作，包括插入兩筆咖啡資料（espresso與latte），以及透過主鍵與條件查詢資料。此段程式碼展示了MyBatis Generator產生的API如何方便地操作資料。

#### 五、實戰演示

透過專案中的Demo，學生可以實際體驗：

- 使用Maven指令執行MyBatis Generator產生程式碼
- 觀察生成的Model與Mapper結構
- 使用自訂的MoneyTypeHandler處理金額欄位
- 執行插入與查詢操作，驗證資料正確性
- 理解生成檔案與手寫程式碼分離的重要性，避免覆蓋問題

建議學生下載專案後，依照快速開始步驟操作，並嘗試修改查詢條件，深化理解。

#### 六、課程小結與後續展望

本章節重點在於掌握MyBatis Generator的配置與使用，理解自動生成程式碼的優勢與限制。透過實戰專案，學生能夠：

- 快速建立資料存取層，減少重複性工作
- 解決H2資料庫主鍵生成的相容性問題
- 利用自訂TypeHandler處理複雜資料型別
- 掌握相對路徑設定，提升專案靈活性與可移植性

兩種主要配置方式（純注解與XML混合）各有優缺點，學生應根據專案需求選擇合適方案。

下一章節將介紹多數據源配置，幫助學生進一步理解Spring微服務架構中資料庫整合的複雜性與解決方案。

#### 七、Tips

- **生成檔案覆蓋問題**：建議將自訂修改與自動生成的程式碼分開存放，避免下次生成時覆蓋手寫邏輯。
- **主鍵生成設定**：務必使用`sqlStatement="JDBC"`以確保跨資料庫相容性，特別是H2 2.x版本。
- **查詢條件建構**：利用Generator產生的Example類別，可靈活組合複雜查詢條件，提升查詢彈性。
- **開發環境建議**：使用IntelliJ IDEA搭配Spring Tools插件，提升開發效率與除錯便利性。
- **效能考量**：H2資料庫適合開發測試，正式環境建議使用MySQL或PostgreSQL等生產級資料庫。
---
### 22 | 讓MyBatis更好用的那些工具：MyBatis PageHelper ― [mybatis-pagehelper-demo]
#### 一、課程目標

本章節旨在讓學生理解並掌握如何在Spring微服務架構中，利用MyBatis與PageHelper實現高效且靈活的資料庫分頁查詢。學生將學會兩種主要的分頁方式（RowBounds與PageHelper），並了解如何處理特殊資料類型（如貨幣Money）的映射與轉換。此外，透過實戰範例，學生能夠實際操作並調整分頁設定，提升微服務中資料存取的效能與可維護性。

相關資源連結：
- MyBatis官方文件：https://mybatis.org/mybatis-3/
- PageHelper官方文件：https://pagehelper.github.io/
- Spring Boot官方文件：https://spring.io/projects/spring-boot
- Joda Money官方文件：https://www.joda.org/joda-money/

#### 二、MyBatis與PageHelper分頁查詢概述

在微服務架構中，資料庫查詢的效率直接影響服務的響應速度與用戶體驗。分頁查詢是常見的優化手段，能有效限制每次查詢的資料量，避免一次載入過多資料造成系統負擔。

MyBatis提供了兩種分頁方式：

- **RowBounds分頁**：MyBatis原生的分頁機制，透過偏移量(offset)與限制(limit)控制查詢範圍，實現簡單分頁。
- **PageHelper分頁**：第三方套件，提供更靈活且功能豐富的分頁支援，包含合理化分頁參數、支援多種分頁模式及分頁資訊封裝。

本章節將以咖啡店商品管理系統為例，展示如何整合這兩種分頁方式，並處理Money類型的價格欄位。

#### 三、Money類型的資料庫映射與轉換

在實務中，貨幣資料通常需要精確處理，避免浮點數誤差。Joda Money提供了專門的Money類別來表示貨幣金額。

為了讓MyBatis能正確讀寫Money類型，我們實作了`MoneyTypeHandler`，負責將Money物件與資料庫中的Long（以分為單位）互相轉換。

範例說明：
- 寫入資料庫時，將Money物件轉成Long（分）
- 從資料庫讀取時，將Long轉回Money物件（台幣TWD）

這樣的轉換確保了資料的精確性與一致性。

#### 四、分頁查詢的實作細節

1. **RowBounds分頁**

使用MyBatis原生的RowBounds物件，指定查詢的起始位置與查詢數量。

```java
@Select("select * from t_coffee order by id")
List<Coffee> findAllWithRowBounds(RowBounds rowBounds);
```

此方式簡單直接，但在某些情況下可能不夠靈活。

2. **PageHelper分頁**

引入PageHelper套件後，可以透過設定與參數傳遞，實現更靈活的分頁控制。

```java
@Select("select * from t_coffee order by id")
List<Coffee> findAllWithParam(@Param("pageNum") int pageNum,
                              @Param("pageSize") int pageSize);
```

PageHelper支援多種分頁模式，並能自動封裝分頁資訊（如總頁數、當前頁碼等），方便前端顯示與後端邏輯處理。

#### 五、PageHelper的配置與使用技巧

在`application.properties`中，我們可以設定PageHelper的行為：

- `pagehelper.offset-as-page-num=true`：將offset視為頁碼，方便使用者理解。
- `pagehelper.reasonable=true`：合理化分頁參數，避免頁碼小於1或超出最大頁數。
- `pagehelper.page-size-zero=true`：允許pageSize為0時，查詢所有資料。
- `pagehelper.support-methods-arguments=true`：支援從Mapper方法參數中直接取得分頁參數。

這些設定讓分頁查詢更穩定且易於調整。

#### 六、實戰演示說明

本專案提供了完整的Demo，展示如何使用MyBatis與PageHelper進行分頁查詢：

- 建立`Coffee`資料表並插入測試資料。
- 使用RowBounds分頁，分別查詢第一頁與第二頁資料。
- 使用PageHelper分頁，展示pageSize為0時查詢全部資料的效果。
- 利用PageInfo物件，取得分頁的詳細資訊（如當前頁、總頁數、資料範圍等）。

透過這些範例，學生能夠理解分頁查詢的實際運作流程與調試方法。

#### 七、課程小結與後續展望

本章節介紹了MyBatis中兩種主要的分頁查詢方式，並詳細說明了PageHelper的配置與使用技巧。透過MoneyTypeHandler，我們也學會了如何處理特殊資料類型的映射。

兩種分頁方式比較：
- RowBounds簡單易用，適合基礎需求，但功能較有限。
- PageHelper功能豐富，支援多種分頁策略與參數合理化，適合複雜應用。

後續章節將帶領大家學習多數據源配置，進一步提升Spring微服務架構的彈性與擴展性。

#### 八、Tips

- 分頁查詢時，務必注意資料庫索引與查詢效率，避免全表掃描。
- 使用PageHelper時，建議搭配PageInfo物件，方便取得完整分頁資訊。
- Money類型的精確處理對金融相關應用至關重要，切勿使用浮點數直接存取。
- 在多環境部署時，確保`application.properties`中分頁與資料庫設定一致。
- 常見錯誤如分頁結果異常，多半因配置不當，建議先檢查PageHelper相關設定。
---
###  23 | SpringBucks實戰項目進度小結 ― [springbucks]
#### 一、課程目標

本章節旨在讓學生深入理解Spring微服務架構中，如何利用Spring Boot與Spring Data JPA實現企業級的資料持久化與訂單管理系統。重點涵蓋JPA的基本概念與注解、資料庫設計的最佳實踐、金額精確處理技術，以及如何結合實務案例（如SpringBucks咖啡訂購系統）進行開發。透過本章學習，學生將能掌握微服務中資料存取層的設計與實作，並理解如何確保交易資料的準確性與系統效能。

推薦學生實際操作專案，參考GitHub上的SpringBucks範例，並結合官方文件深化理解：

- Spring Boot官方文件：https://spring.io/projects/spring-boot
- Spring Data JPA參考指南：https://spring.io/projects/spring-data-jpa
- Jakarta Persistence規範：https://jakarta.ee/specifications/persistence/

#### 二、Spring微服務架構中的資料持久化與JPA基礎

在微服務架構中，資料持久化是核心組件之一。Spring Data JPA提供了方便且強大的資料存取層解決方案，讓開發者能以物件導向方式操作資料庫。

- **JPA（Jakarta Persistence API）** 是Java的物件關聯對映標準，透過注解定義實體類別與資料表的映射關係。
- 常用注解如@Entity、@Id、@GeneratedValue等，幫助定義資料模型。
- Spring Data JPA進一步簡化Repository層的開發，透過介面定義方法，框架自動生成對應的SQL查詢。

以SpringBucks專案為例，定義了Coffee與CoffeeOrder兩個實體，並透過Repository介面實現資料存取，讓業務邏輯層能專注於核心功能。

#### 三、精確金額處理與資料庫設計

金融交易系統對金額的精確度要求極高，SpringBucks專案採用以下策略確保金額計算的準確性與效能：

- 使用**Money處理庫**來封裝金額與貨幣單位，避免浮點數誤差。
- 利用JPA的**AttributeConverter**，將Money物件轉換為資料庫中的Long型態（以分為單位）存儲。
- 在資料庫中，金額欄位使用BIGINT型態，存儲如NT$100.00即為10000（分）。
- 這種設計不僅節省空間，也提升查詢效率，並支援索引優化。

此設計確保了金額的精確計算與高效查詢，是金融相關微服務不可或缺的技術要點。

#### 四、SpringBucks專案架構與實作細節

SpringBucks是一個基於Spring Boot的咖啡訂購系統，展示了微服務中資料持久化與業務邏輯的整合實踐。

- 專案結構清晰，分為model（資料模型）、repository（資料存取）、service（業務邏輯）三層。
- 透過Lombok減少樣板程式碼，提高開發效率。
- CoffeeService與CoffeeOrderService分別負責咖啡商品與訂單的業務邏輯。
- 訂單狀態管理嚴格控制狀態流轉方向，避免狀態回退，確保訂單流程正確。
- 使用H2記憶體資料庫方便開發與測試，並可根據環境調整application.properties設定。

此架構符合微服務設計原則，強調模組化與高內聚，便於後續擴展與維護。

#### 五、實戰演示：SpringBucks系統操作流程

1. 啟動SpringBucks應用程式，系統自動載入初始資料。
2. 透過CoffeeRepository查詢所有咖啡商品，並列印清單。
3. 使用ExampleMatcher進行精確匹配查詢，例如查找名稱為「拿鐵」的咖啡。
4. 若找到目標咖啡，透過CoffeeOrderService建立訂單，並設定訂單狀態。
5. 訂單狀態只能往前流轉（如從「Delete」到「Paid」），嘗試逆向流轉會觸發警告。
6. 控制台輸出操作結果，展示查詢與訂單狀態更新的過程。

此演示幫助學生理解如何結合JPA查詢與業務邏輯實現完整功能。

#### 六、課程小結與後續展望

本章節透過SpringBucks專案，讓學生掌握了Spring微服務架構中資料持久化的核心技術，包括JPA實體定義、Repository使用、金額精確處理與訂單狀態管理。兩種配置方式（如手動維護資料表與自動DDL）各有優缺點：

- **手動維護資料表**：控制力強，適合正式環境，但開發成本較高。
- **自動DDL生成**：開發快速，但正式環境需謹慎使用以避免資料遺失。

後續章節將介紹多數據源配置，幫助學生理解如何在微服務中管理多個資料庫連線，提升系統彈性與擴展性。

#### 七、Tips

- 使用ExampleMatcher進行查詢時，注意匹配條件的設定，避免查詢結果不符合預期。
- 金額欄位務必使用整數型態存儲，避免浮點數誤差導致交易錯誤。
- 訂單狀態流轉應嚴格控制，防止資料不一致。
- 開發環境與正式環境的資料庫設定應分開管理，避免誤操作。
- 多利用Spring Boot與Spring Data JPA的官方文件，掌握最新功能與最佳實踐。
---
# Chapter 4：NoSQL實踐 (7講)
### 24 | 通過Docker輔助開發
#### 一、課程目標

本章節旨在讓學生了解Docker在Spring微服務架構開發中的重要角色，掌握如何利用Docker容器技術簡化本地開發環境的搭建與管理，提升開發效率與系統的可擴展性。學生將學會基本的Docker操作指令，並能實際運用Docker啟動常用的技術服務（如MongoDB），為後續微服務的實戰開發打下堅實基礎。

相關資源連結：
- Docker中文官網：https://www.docker.cn/
- Docker Hub官方鏡像庫：https://hub.docker.com/
- MongoDB官方Docker鏡像說明：https://hub.docker.com/_/mongo

#### 二、Docker與微服務架構的關聯與優勢

Docker是一種輕量級的容器技術，相較於傳統虛擬機，容器啟動更快、資源消耗更低，這使得在本地開發環境中快速啟動多個服務成為可能。對於Spring微服務架構而言，Docker能夠幫助開發者：

- **標準化開發環境**：不論是Windows、Linux還是MacOS，Docker容器內的環境一致，避免「在我機器上可以跑」的問題。
- **簡化依賴管理**：不需手動安裝和配置MongoDB、Redis等服務，直接透過Docker鏡像快速部署。
- **提升交付效率與彈性**：容器的輕量特性使得系統擴展和縮減更為靈活，符合微服務的彈性需求。

這些優勢使Docker成為微服務架構中不可或缺的工具。

#### 三、Docker基本操作與實務應用

1. **Docker鏡像與容器的概念**  
   - 鏡像（Image）是應用及其運行環境的靜態模板。  
   - 容器（Container）是鏡像的運行實例，類似於輕量級的虛擬機。

2. **常用Docker命令介紹**  
   - `docker pull <image>`：從Docker Hub下載鏡像。  
   - `docker run`：啟動一個容器，常用參數包括：  
     - `-d`：後台運行容器。  
     - `-p <hostPort>:<containerPort>`：端口映射，讓宿主機能訪問容器內服務。  
     - `-v <hostDir>:<containerDir>`：目錄映射，方便數據持久化。  
     - `--name <containerName>`：為容器命名，方便管理。  
   - `docker ps`：查看正在運行的容器。  
   - `docker logs <containerName>`：查看容器日誌。  
   - `docker exec -it <containerName> bash`：進入容器內部執行命令。

3. **配置國內Docker鏡像加速**  
   由於Docker Hub在國內訪問速度較慢，建議配置國內官方鏡像源（如阿里雲鏡像），提升下載效率。

#### 四、實戰演示：使用Docker啟動MongoDB

以MongoDB為例，展示如何在本地利用Docker快速啟動資料庫服務：

- 從Docker Hub拉取官方MongoDB鏡像：`docker pull mongo`
- 啟動MongoDB容器，並映射端口與資料目錄：
  ```docker
  docker run -d --name mongo \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=admin \
  -p 27017:27017 \
  -v $(pwd)/mongo_data:/data/db \
  mongo:latest
  ```
- 使用`docker ps`確認容器運行狀態。
- 透過`docker exec -it mongo bash`進入容器，使用MongoDB命令行工具操作資料庫。
- 這種方式讓開發者無需在本地安裝MongoDB，環境配置更簡潔且易於管理。

> [!important] 從 MongoDB 5.0 版本開始，官方映像檔已經把舊的 `mongo` shell 移除，改用新的 MongoDB Shell 工具叫 `mongosh`。
> $ mongosh -u admin -p admin

#### 五、課程小結與後續展望

本章節介紹了Docker在Spring微服務開發中的應用，強調了容器技術的輕量級特性及其對開發環境標準化的重要性。透過實際操作MongoDB容器，學生體驗了Docker如何簡化服務部署與管理。

接下來，我們將探討多數據源配置，進一步深化微服務架構中資料管理的實務技巧，為複雜系統的開發做好準備。

#### 六、Tips：

- 使用Docker時，務必熟悉端口映射與資料卷映射，這是容器與宿主機溝通的關鍵。  
- 容器命名有助於管理多個服務，避免混淆。  
- 配置國內鏡像加速能大幅提升鏡像下載速度，節省開發時間。  
- 多利用Docker官方文檔和Docker Hub上的鏡像說明，掌握最新的使用方法與參數。  
---
### 25 | 在Spring中訪問 MongoDB ― [mongo-demo, mongo-repository-demo]
#### 一、課程目標

本課程將介紹如何在Spring Boot中整合MongoDB，學習重點包括：
- MongoDB基本操作與Spring整合方式
- MongoTemplate的使用方法
- Spring Data MongoDB Repository的實作
- 自定義類型轉換器的開發

相關資源：
- MongoDB官方文件：https://docs.mongodb.com/
- Spring Data MongoDB文件：https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/

#### 二、環境準備

1. 啟動MongoDB容器
```bash
docker run -d --name mongo -p 27017:27017 mongo:latest
```

2. 建立資料庫與使用者
```javascript
use springbucks
db.createUser({
  user: "springbucks",
  pwd: "springbucks",
  roles: [{ role: "readWrite", db: "springbucks" }]
})
```

3. 列出使用者
```
show users;
[
  {
    _id: 'springbucks.springbucks',
    userId: UUID('d560c45c-af1c-4afb-bf07-cf51b55bef55'),
    user: 'springbucks',
    db: 'springbucks',
    roles: [ { role: 'readWrite', db: 'springbucks' } ],
    mechanisms: [ 'SCRAM-SHA-1', 'SCRAM-SHA-256' ]
  }
]
```

5. 列出文檔
```
springbucks> show collections;
coffee
```

6. 顯示文檔
```
springbucks> db.coffee.find();
[
  {
    _id: ObjectId('685e18ddbb0c495553862264'),
    name: 'espresso',
    price: {
      money: {
        currency: { code: 'TWD', numericCode: 901, decimalPlaces: 2 },
        amount: '150.00'
      }
    },
    createTime: ISODate('2025-06-27T04:06:53.677Z'),
    updateTime: ISODate('2025-06-27T06:02:01.346Z'),
    _class: 'tw.fengqing.spring.data.mongodemo.model.Coffee'
  },
  {
    _id: ObjectId('685e33d8c5352d4259d44289'),
    name: 'espresso',
    price: {
      money: {
        currency: { code: 'TWD', numericCode: 901, decimalPlaces: 2 },
        amount: '100.00'
      }
    },
    createTime: ISODate('2025-06-27T06:02:00.229Z'),
    updateTime: ISODate('2025-06-27T06:02:00.229Z'),
    _class: 'tw.fengqing.spring.data.mongodemo.model.Coffee'

```

7. 刪除資料
```
springbucks> db.coffee.remove({"name":"espresso"});
```

show collections;
show.coffee.find();
springbucks> db.coffee.remove({"name":"espresso"});
#### 三、專案配置

1. 引入依賴
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```

2. 配置MongoDB連線
```properties
spring.data.mongodb.uri=mongodb://springbucks:springbucks@localhost:27017/springbucks
```

#### 四、實戰演示

1. 實體類定義
```java
@Document
public class Coffee {
    @Id
    private String id;
    private String name;
    private Money price;
    private Date createTime;
    private Date updateTime;
}
```

2. 自定義轉換器
```java
public class MoneyReadConverter implements Converter<Document, Money> {
    @Override
    public Money convert(Document source) {
        Document money = (Document) source.get("money");
        double amount = money.getDouble("amount");
        String currency = money.getString("currency");
        return Money.of(CurrencyUnit.of(currency), amount);
    }
}
```

3. MongoTemplate使用示例
```java
@Autowired
private MongoTemplate mongoTemplate;

// 保存文檔
Coffee saved = mongoTemplate.save(coffee);

// 查詢文檔
List<Coffee> list = mongoTemplate.find(
    Query.query(Criteria.where("name").is("espresso")),
    Coffee.class);

// 更新文檔
UpdateResult result = mongoTemplate.updateFirst(
    Query.query(Criteria.where("name").is("latte")),
    Update.update("price", new Money(30.0)),
    Coffee.class);
```

#### 五、課程小結與後續展望

1. MongoDB在Spring中的兩種使用方式：
- MongoTemplate：靈活性高，可執行複雜查詢
- Repository：簡單便捷，適合基礎CRUD操作

2. 注意事項：
- 建議使用自定義轉換器處理複雜類型
- 操作時需注意更新時間戳的維護
- 建議使用索引優化查詢性能

3. 後續課程預告：
- 多數據源配置
- MongoDB進階查詢
- 分片集群配置

#### Tips

1. 開發建議：
- 善用Spring Boot的自動配置
- 建議實作統一的錯誤處理
- 注意MongoDB的版本兼容性

2. 常見問題：
- 類型轉換錯誤：檢查轉換器配置
- 連線超時：確認網路設定
- 認證失敗：檢查用戶權限
---
### 26 | 在Spring中訪問 Redis ― [jedis-demo]
#### 一、課程目標

- 理解Redis作為內存型快取資料庫的特性與應用場景
- 掌握使用Jedis客戶端操作Redis的基本方法
- 學習如何在Spring專案中正確配置和使用JedisPool
- 實作Redis快取功能，提升應用程式效能

#### 二、Redis基礎概念

Redis是一款開源的記憶體資料庫，具有以下特點：
- 支援多樣化的資料結構（String、List、Set、Hash等）
- 高性能的記憶體存取
- 常用於快取場景，非持久化存儲
- 相比Memcache具有更豐富的資料類型支援

#### 三、Jedis客戶端使用要點

1. **線程安全性考慮**
- Jedis實例非線程安全
- 不能在多個線程間共享同一個Jedis實例
- 建議使用JedisPool進行連接池管理

2. **JedisPool配置重點**
```java
JedisPoolConfig config = new JedisPoolConfig();
config.setMaxTotal(5);         // 最大連接數
config.setMaxIdle(5);          // 最大空閒連接數
config.setTestOnBorrow(true);  // 取用時測試連接
```

#### 四、實戰演示

1. **啟動Redis容器**
```bash
docker run --name redis -d -p 6379:6379 redis
```

2. **Spring Boot整合範例**
```java
@Autowired
private JedisPool jedisPool;

public void cacheMenu() {
    try (Jedis jedis = jedisPool.getResource()) {
        // 將咖啡菜單存入Redis Hash結構
        coffeeList.forEach(c -> 
            jedis.hset("springbucks.menu", 
                      c.getName(), 
                      c.getPrice().toString())
        );
    }
}
```

#### 五、課程小結與後續展望

- Redis作為快取解決方案的優勢
- Jedis客戶端的正確使用方式
- 連接池管理的重要性
- 下一步：學習Spring Data Redis，提供更高層級的抽象

#### 六、Tips

- 🔔 使用try-with-resources自動管理Jedis資源釋放
- 💡 善用JedisPool避免重複創建連接
- ⚠️ 注意線程安全問題，不要共享Jedis實例
- 📌 快取資料要考慮過期策略
- 🛠️ 建議在開發環境使用Docker運行Redis，方便管理
---
### 27 | Redis的哨兵與集群模式
根據提供的內容，我幫你整理一份關於Redis哨兵與集群模式的教學講義：

#### 一、課程目標

- 理解Redis的兩種主要高可用部署方案：哨兵模式和集群模式
- 掌握Redis哨兵的監控和故障轉移機制
- 了解Redis Cluster的分片機制和節點管理
- 學習在Spring專案中配置Redis哨兵和集群模式

#### 二、Redis哨兵模式（Sentinel）

1. **架構特點**
- 由一主多從的Redis節點組成
- 配置多個哨兵節點進行監控
- 支援自動故障轉移
- 🔍 關鍵詞：Master、Slave、Sentinel

2. **工作機制**
- 哨兵持續監控Master節點狀態
- 當發現Master故障時，至少需要兩個哨兵達成共識
- 自動選舉新的Master並進行故障轉移
- 🔔 重要：確保高可用性，避免單點故障

#### 三、Redis集群模式（Cluster）

1. **特性介紹**
- 採用分片機制，數據分散存儲
- 通常配置為6個節點（3主3從）
- 使用Hash Slot進行數據分配
- 🎯 每個節點負責一部分slot（共16384個）

2. **數據分片原理**
```plaintext
key分配公式：HASH_SLOT = CRC16(key) mod 16384
```
- 確保數據均勻分布
- 支援節點擴展和收縮
- ⚠️ 注意：集群模式下部分批量操作可能受限

#### 四、實戰演示

1. **哨兵模式配置**
```java
@Bean
public JedisSentinelPool jedisSentinelPool() {
    Set<String> sentinels = new HashSet<>();
    sentinels.add("host1:26379");
    sentinels.add("host2:26379");
    return new JedisSentinelPool("mymaster", sentinels);
}
```

2. **集群模式配置**
```java
@Bean
public JedisCluster jedisCluster() {
    Set<HostAndPort> nodes = new HashSet<>();
    nodes.add(new HostAndPort("host1", 6379));
    nodes.add(new HostAndPort("host2", 6379));
    return new JedisCluster(nodes);
}
```

#### 五、課程小結與後續展望

- Redis哨兵適合主從複製的高可用場景
- Redis Cluster適合大規模數據分片場景
- 下一步：深入學習Redis的數據持久化機制

#### 六、Tips

- 💡 哨兵模式至少需要3個哨兵實例確保可靠性
- 🔒 集群模式建議使用奇數個主節點
- ⚡ 注意監控哨兵和集群的健康狀態
- 📌 定期備份配置和數據
- 🛠️ 建議在測試環境充分驗證配置
---
### 28 | 瞭解Spring的緩存抽象 ― [cache-demo, cache-with-redis-demo]
根據提供的內容，我幫你整理出一份Spring Cache抽象的教學講義：

#### 一、課程目標

- 理解Spring Cache抽象層的概念與優勢
- 掌握Cache相關注解的使用方法
- 學習如何整合Redis實現分布式緩存
- 了解緩存策略的選擇原則

#### 二、Spring Cache抽象概述

Spring Cache提供了一個統一的緩存抽象層，通過簡單的注解即可實現方法級別的緩存。主要特點：

- 透過AOP實現，對業務代碼無侵入
- 支持多種緩存實現（內存、Redis等）
- 統一的緩存操作接口
- 靈活的緩存策略配置

#### 三、核心注解使用

1. **@EnableCaching**
- 功能：開啟緩存支持
- 位置：配置類上

2. **@Cacheable**
- 功能：將方法結果緩存
- 使用場景：查詢操作
- 範例：
```java
@Cacheable(cacheNames = "coffee")
public List<Coffee> findAllCoffee() {
    return coffeeRepository.findAll();
}
```

3. **@CacheEvict**
- 功能：清除緩存
- 使用場景：更新或刪除操作
- 範例：
```java
@CacheEvict(cacheNames = "coffee")
public void reloadCoffee() {
    // 觸發緩存清除
}
```

#### 四、緩存策略選擇

1. **本地緩存（如ConcurrentHashMap）適用場景**：
- 數據變化頻率低
- 可接受數據短暫不一致
- 對性能要求較高

2. **分布式緩存（如Redis）適用場景**：
- 需要跨服務器數據一致
- 數據訪問頻繁
- 數據量較大

3. **不適合使用緩存的情況**：
- 寫入頻繁的數據
- 讀寫比例接近1:1
- 實時性要求極高的數據

#### 五、實戰演示

1. **基礎緩存配置**
```java
@EnableCaching
@Configuration
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager();
    }
}
```

2. **Redis緩存整合**
```properties
spring.cache.type=redis
spring.cache.cache-names=coffee
spring.cache.redis.time-to-live=5000
```

#### 六、課程小結與後續展望

- Spring Cache提供了便捷的緩存實現方式
- 合理使用緩存可大幅提升系統性能
- 需要根據業務場景選擇合適的緩存策略
- 後續可深入學習：
  - 緩存穿透、擊穿、雪崩的處理
  - 多級緩存架構
  - 緩存預熱策略

#### 七、Tips

- 設置合理的緩存過期時間
- 注意緩存與數據庫的一致性
- 監控緩存命中率
- 考慮緩存容量上限
- 做好緩存降級方案
---
### 29 | Redis在Spring中的其他用法 ― [redis-demo, redis-repository-demo]
根據提供的內容，我幫你整理出一份關於Spring中Redis使用的教學講義：

#### 一、課程目標

- 了解Spring Data Redis的基本使用方式
- 掌握RedisTemplate和Redis Repository兩種操作方式
- 學習Redis不同部署模式(單節點、哨兵、集群)的配置方法
- 理解Redis在Spring中的常見應用場景

#### 二、Redis連接配置

1. **單節點配置**
```properties
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=secret
```

2. **哨兵模式配置**
```properties
spring.redis.sentinel.master=mymaster
spring.redis.sentinel.nodes=host1:26379,host2:26379
```

3. **集群模式配置**
```properties
spring.redis.cluster.nodes=host1:6379,host2:6379
spring.redis.cluster.max-redirects=3
```

#### 三、RedisTemplate使用方式

1. **基本配置**
```java
@Bean
public RedisTemplate<String, Coffee> redisTemplate(RedisConnectionFactory factory) {
    RedisTemplate<String, Coffee> template = new RedisTemplate<>();
    template.setConnectionFactory(factory);
    return template;
}
```

2. **常見操作**
```java
// Hash操作
HashOperations<String, String, Coffee> hashOps = redisTemplate.opsForHash();
hashOps.put("coffee", coffee.getName(), coffee);

// 設置過期時間
redisTemplate.expire("coffee", 1, TimeUnit.MINUTES);
```

#### 四、Redis Repository使用方式

1. **實體類定義**
```java
@RedisHash(value = "springbucks-coffee", timeToLive = 60)
public class CoffeeCache {
    @Id
    private Long id;
    @Indexed
    private String name;
    private Money price;
}
```

2. **Repository定義**
```java
public interface CoffeeCacheRepository extends CrudRepository<CoffeeCache, Long> {
    Optional<CoffeeCache> findOneByName(String name);
}
```

#### 五、實戰演示

1. **使用RedisTemplate實現緩存**
```java
public Optional<Coffee> findOneCoffee(String name) {
    HashOperations<String, String, Coffee> hashOps = redisTemplate.opsForHash();
    
    // 檢查緩存
    if (hashOps.hasKey(CACHE_KEY, name)) {
        return Optional.of(hashOps.get(CACHE_KEY, name));
    }
    
    // 查詢數據庫並更新緩存
    Optional<Coffee> coffee = coffeeRepository.findByName(name);
    coffee.ifPresent(c -> {
        hashOps.put(CACHE_KEY, name, c);
        redisTemplate.expire(CACHE_KEY, 1, TimeUnit.MINUTES);
    });
    
    return coffee;
}
```

#### 六、Redis命令行操作

1. **進入Redis容器**

```bash
docker exec -it redis bash
```

2. **進入Redis CLI**

```bash
redis-cli
```

3. **常用命令示例**

```bash
# 查看所有 key
127.0.0.1:6379> keys *
1) "\xac\xed\x00\x05t\x00\x12springbucks-coffee"
2) "springbucks-menu"

# 查看所有菜單項目
HGETALL "\xac\xed\x00\x05t\x00\x12springbucks-coffee"

# 查看過期時間
TTL "\xac\xed\x00\x05t\x00\x12springbucks-coffee"
(integer) 23
```

#### 七、課程小結與後續展望

- RedisTemplate適合靈活的緩存操作
- Redis Repository提供更高層的抽象
- 根據業務場景選擇合適的操作方式
- 後續可深入學習：
  - Redis事務管理
  - 分布式鎖實現
  - 緩存穿透與雪崩處理

#### 八、Tips

- 務必設置緩存過期時間
- 注意序列化方式的選擇
- 合理配置連接池參數
- 建議使用Lettuce作為Redis客戶端
- 生產環境建議配置主從架構
---
### 30 | SpringBucks實戰項目進度小結
根據提供的內容，我幫你整理一份Spring微服務架構的講義：

#### 一、課程目標

本章節主要介紹Docker環境下的數據持久化解決方案，包括MongoDB和Redis的整合應用，以及Spring Cache抽象的實現。通過實際案例，讓學生理解分布式系統中的數據存取策略。

> [!important] 學習重點
> - Docker基礎操作
> - MongoDB與Redis在Spring中的應用
> - Spring Cache抽象概念與實現
> - 數據庫優化策略

#### 二、理論基礎

1. Docker環境配置
- 本地環境搭建
- MongoDB容器配置
- Redis容器啟動與管理

2. Spring Data整合
- MongoDB基本操作
- Redis數據訪問
- Spring Cache抽象層實現

#### 三、實戰演示：SpringBucks咖啡訂單系統

以咖啡店訂單管理為例，展示：

1. 數據存儲方案
- JPA實現訂單與咖啡信息存儲
- Redis緩存優化訪問性能
- 菜單數據緩存策略

2. Redis操作方式
- Redis Standard接口
- Redis Repository方式
- 兩種方式的實際應用場景

> [!tip] 實戰要點
> - 咖啡菜單適合使用緩存，因為更新頻率低
> - 訂單信息建議使用數據庫持久化存儲
> - 合理使用緩存可以顯著減少數據庫壓力

#### 四、課程小結與後續展望

1. 本章要點回顧：
- Docker環境配置
- MongoDB與Redis的整合應用
- 緩存策略的實現方式

2. 實踐建議：
- 嘗試使用MongoDB替代關係型數據庫
- 結合MongoDB和Redis實現完整的訂單系統
- 探索不同數據存儲方案的優劣

#### 五、Tips

1. 技術選型建議：
- 數據變更頻繁的場景適合使用數據庫
- 讀多寫少的場景優先考慮緩存
- 根據業務特點選擇合適的存儲方案

2. 常見問題解決：
- 緩存更新策略
- 數據一致性保證
- 性能優化方向
---
# Chapter 5：數據進階訪問（8講）
### 31 | Project Reactor介紹（上）
我來幫你將這段內容轉換成結構化的講義：

#### 一、課程目標

本章節將介紹Project Reactor的基礎概念及其在Spring生態系統中的應用。學習重點包括：
- 理解響應式編程(Reactive Programming)的核心概念
- 掌握Project Reactor的基本原理
- 比較傳統回調式編程和響應式編程的差異

> [!tip] 實務意義
> 在現代微服務架構中，響應式編程能夠更好地處理非同步操作，提升系統效能和可維護性。

#### 二、響應式編程基礎

響應式編程（Reactive Programming）是一種面向數據流和變化傳播的編程範式。

透過Excel的類比來理解：
- 傳統編程：A = B + C，B和C的後續變化不會影響A
- 響應式編程：類似Excel公式，當相依的數值改變時，結果會自動更新

> [!note] 歷史演進
> - 早期：響應式編程概念的提出
> - 中期：RxJava的發展
> - 現代：Reactive Streams規範的確立

#### 三、Project Reactor介紹

Project Reactor是基於Reactive Streams規範的非阻塞響應式程式庫，主要包含：

核心概念：
- Mono：代表0或1個元素的序列
- Flux：代表N個元素的序列
- 非阻塞I/O操作

> [!important] 關鍵特性
> - 完全非阻塞
> - 基於背壓（backpressure）機制
> - 豐富的操作符

#### 四、實戰演示：傳統vs響應式

傳統回調方式：
```java
// 多層回調，代碼複雜度高
user.getFavorites(uid, new Callback<List<String>>() {
    onSuccess(List<String> list) {
        if(list.isEmpty()) {
            // 更多巢狀回調...
        }
    }
    onError(Exception e) {
        // 錯誤處理
    }
});
```

響應式方式：
```java
ufs.getFavorites(uid)
   .take(5)
   .publishTo(ui)
   .onError(error -> log.error("處理異常"))
```

> [!tip] 程式碼優勢
> - 更清晰的程式碼結構
> - 更優雅的錯誤處理
> - 更好的可維護性

#### 五、課程小結與後續展望

本節重點：
- 理解了響應式編程的基本概念
- 認識了Project Reactor的核心特性
- 比較了傳統編程和響應式編程的差異

下一章節預告：
- Project Reactor的進階操作
- 實際應用案例分析

> [!note] 補充資源
> - Project Reactor官方文檔：https://projectreactor.io/docs
> - Spring WebFlux文檔：https://docs.spring.io/spring-framework/reference/web/webflux.html

---
### 32 | Project Reactor介紹（下）― [simple-reactor-demo]

根據提供的內容，我幫你整理一份關於Project Reactor的教學講義：

#### 一、課程目標

本課程旨在介紹Project Reactor這個響應式程式設計框架，讓學生能夠：
- 理解響應式程式設計的核心概念
- 掌握Flux和Mono的基本使用
- 學會處理背壓(Backpressure)機制
- 熟悉線程調度的應用
- 能夠進行異常處理

相關資源：
- Project Reactor官方文檔：https://projectreactor.io/docs
- 示範代碼：[[simple-reactor-demo]]

#### 二、核心概念介紹

1. **Publisher-Subscriber模式** 🔑
- Publisher(發布者)：產生數據流
- Subscriber(訂閱者)：消費數據
- 採用"推"的方式：發布者主動將元素推送給訂閱者
- 重要特性：在調用Subscribe方法前，不會執行任何操作

2. **兩個主要類型** 🔑
- Flux：處理0-N個元素的序列
- Mono：處理0-1個元素的序列

#### 三、重要機制說明

1. **背壓(Backpressure)機制** 
- 目的：解決生產速度快於消費速度的問題
- 實現：訂閱者可以控制請求的元素數量
- 方法：通過request(n)方法指定需要的元素數量

2. **線程調度** 
常用調度器：
- immediate：當前線程
- single：單一線程
- elastic：彈性線程池(空閒60秒後回收)
- parallel：固定大小線程池(CPU核數相同)

#### 四、實戰演示

```java
Flux.range(1, 6)    // 創建1-6的序列
    .doOnRequest(n -> log.info("Request {} number", n))
    .map(i -> i * 2)    // 元素轉換
    .publishOn(Schedulers.elastic())    // 切換執行線程
    .subscribe(
        value -> log.info("Received: {}", value),
        error -> log.error("Error: {}", error),
        () -> log.info("Completed")
    );
```

#### 五、異常處理

主要處理方式：
- onErrorReturn：遇到錯誤時返回默認值
- onErrorResume：提供錯誤處理邏輯
- doFinally：確保資源釋放

#### 六、課程小結與後續展望

**核心要點回顧：**
- Project Reactor是一個強大的響應式編程框架
- 基於推送模式的數據流處理
- 提供完善的背壓機制
- 靈活的線程調度
- 豐富的錯誤處理方案

**後續學習建議：**
- 深入學習更多操作符
- 結合Spring WebFlux實戰
- 研究響應式微服務架構

#### Tips

1. 開發環境要求：
- Java版本 ≥ 1.8（因大量使用Lambda表達式）
- 建議使用IDE以獲得更好的程式碼提示

2. 常見陷阱：
- 忘記調用Subscribe方法
- 沒有正確處理異常
- 線程切換使用不當

3. 實踐建議：
- 從簡單的例子開始
- 多使用日誌來理解執行流程
- 注意資源的及時釋放
- ---
### 33 | 通過Reactive的方式訪問Redis ― [redis-demo2]
根據提供的內容，我幫你整理一份Spring微服務架構中關於Reactive Redis操作的講義：

#### 一、課程目標

本節課程將介紹如何使用Spring Data Redis Reactive進行反應式Redis操作，學習重點包括：
- 理解Reactive程式設計在Redis操作中的應用
- 掌握Spring Boot與Redis的整合配置
- 學習非阻塞式數據存取的實現方式
- 實作數據庫與Redis快取的整合應用

相關資源：
- Spring Data Redis官方文件
- Project Reactor官方文件
- 示範代碼庫：redis-demo2

#### 二、Redis支援模式介紹

Spring Data Redis提供兩種客戶端支援：
1. Jedis客戶端：傳統的同步操作模式
2. Lettuce客戶端：支援響應式編程的非阻塞操作模式

> 🔑 重點：使用Reactive方式操作Redis時，必須選擇Lettuce客戶端

#### 三、核心組件說明

主要使用的組件包括：
- ReactiveRedisConnection：建立Redis的響應式連接
- ReactiveRedisTemplate：提供響應式的Redis操作介面
- ReactiveHashOperations：處理Hash類型數據的操作介面

> 🔑 重點：所有操作方法都會返回Mono或Flux對象，而不是直接的操作結果

#### 四、實戰演示

以咖啡菜單為例，展示如何：
1. 配置Redis連接
```properties
spring.redis.host=localhost
spring.redis.port=6379
```

2. 定義ReactiveRedisTemplate
```java
@Bean
public ReactiveRedisTemplate<String, String> reactiveRedisTemplate(
    ReactiveRedisConnectionFactory factory) {
    return new ReactiveRedisTemplate<>(factory, 
        RedisSerializationContext.string());
}
```

3. 實現數據操作
```java
// 獲取Hash操作對象
ReactiveHashOperations<String, String, String> hashOps = 
    redisTemplate.opsForHash();

// 將咖啡數據存入Redis
Flux.fromIterable(coffeeList)
    .publishOn(Schedulers.single())
    .flatMap(coffee -> hashOps.put(
        "coffee_menu", 
        coffee.getName(), 
        coffee.getPrice().toString()))
    .subscribe();
```

#### 五、課程小結與後續展望

優點：
- 非阻塞式操作提高系統效能
- 支援響應式編程範式
- 易於整合Spring生態系統

注意事項：
- 需要理解響應式編程概念
- 正確處理異步操作的錯誤情況
- 合理設置快取過期時間

#### 六、Tips

1. 使用Docker快速啟動Redis環境：
```bash
docker run --name redis -p 6379:6379 -d redis
```

2. 開發時建議使用Redis Desktop Manager等工具進行數據查看
3. 生產環境記得配置連接池參數
4. 建議加入監控機制，追蹤Redis性能
---
### 34 | 通過Reactive的方式訪問MongoDB ― [mongo-demo]
根據提供的內容，我幫你整理一份關於Spring響應式MongoDB的教學講義：

#### 一、課程目標

本課程旨在介紹如何使用Spring Data MongoDB的響應式編程方式訪問MongoDB數據庫。學習重點包括：
- 理解響應式編程在MongoDB操作中的應用
- 掌握Spring Data MongoDB Reactive的基本使用方法
- 學習自定義類型轉換器的實現
- 實戰演練響應式數據庫操作

> [!tip] 相關資源
> - Spring Data MongoDB Reactive官方文檔
> - MongoDB Java響應式驅動程序
> - Project Reactor參考指南

#### 二、響應式MongoDB基礎

1. **核心依賴配置**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
</dependency>
```

2. **主要特點**
- 非阻塞式I/O操作
- 基於Project Reactor實現
- 提供ReactiveMongoTemplate支持
- 支持自定義類型轉換

> [!note] 為什麼選擇響應式MongoDB？
> - 提升系統吞吐量
> - 更好的資源利用率
> - 適合高併發場景

#### 三、實戰演示

1. **基本配置示例**
```java
@Configuration
public class MongoConfig {
    @Bean
    public MongoCustomConversions customConversions() {
        return new MongoCustomConversions(Arrays.asList(
            new MoneyReadConverter(),
            new MoneyWriteConverter()
        ));
    }
}
```

2. **響應式操作示例**
```java
// 插入數據
template.insertAll(coffees)
    .publishOn(Schedulers.boundedElastic())
    .doOnNext(coffee -> log.info("Inserted: {}", coffee))
    .subscribe();

// 條件更新
template.updateMulti(
    query(where("price").gte(3000)),
    new Update().inc("price", -500),
    Coffee.class
).subscribe();
```

#### 四、實作要點與注意事項

1. **線程處理**
- 響應式操作通常在不同線程中執行
- 需要注意操作順序的保證
- 使用CountDownLatch等工具控制程序流程

2. **常見陷阱**
- 避免在響應式流中使用阻塞操作
- 正確處理訂閱和錯誤情況
- 注意數據轉換的一致性

> [!warning] 注意事項
> - 響應式程序的執行順序可能與代碼編寫順序不同
> - 必須正確處理訂閱，否則操作可能不會執行
> - 建議使用適當的調度器（Scheduler）

#### 五、課程小結與後續展望

本課程介紹了Spring響應式MongoDB的基本使用方法，從配置到實際操作都有詳細說明。後續課程將探討：
- 與WebFlux的整合應用
- 更複雜的響應式數據操作
- 性能優化與最佳實踐

> [!tip] 學習建議
> - 多練習響應式編程的基本概念
> - 理解背壓（backpressure）機制
> - 實際動手操作示例代碼

---
### 35 | 通過Reactive的方式訪問RDBMS ― [r2dbc-repository-demo]
<font color="#ff0000">simple-reactor-demo 程式碼修改有問題，暫時不作說明</font>
#### 一、課程目標

本章節將帶領大家深入了解如何透過 Spring Data R2DBC 以反應式（Reactive）方式存取關聯式資料庫，並掌握 R2DBC Repository 的實作與應用。重點包括：

- 認識 R2DBC 的設計理念與解決的問題
- 學會設定與使用 R2DBC Repository 進行非阻塞式資料存取
- 實作自訂型別轉換器（如 Money 類型）
- 比較傳統 JDBC 與 R2DBC 的差異與優缺點

【重點】本章節將協助你建立現代微服務架構下高效能資料存取的基礎，並為後續多資料源配置等進階主題鋪路。

【資源連結】
- Spring Data R2DBC 官方文件：https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/
- R2DBC 官方網站：https://r2dbc.io/
- 範例專案：https://github.com/SpringMicroservicesCourse/r2dbc-repository-demo

#### 二、R2DBC 與反應式資料存取的核心概念

R2DBC（Reactive Relational Database Connectivity）是一套專為反應式程式設計打造的資料庫存取規範，解決了傳統 JDBC 阻塞式 I/O 的效能瓶頸。它讓我們能以非阻塞、事件驅動的方式操作關聯式資料庫，非常適合高併發的微服務場景。

【重點】
- R2DBC 支援主流資料庫（如 PostgreSQL、H2、SQL Server），但目前尚未涵蓋所有資料庫（如 MySQL、Oracle）。
- 反應式程式設計強調「資料流」與「背壓」管理，常用 Reactor 的 Flux/Mono 來處理資料。

舉例來說，傳統 JDBC 查詢時會「卡住」等待資料庫回應，而 R2DBC 則能讓應用程式繼續處理其他請求，等資料回來再通知你。

#### 三、R2DBC 在 Spring 生態的應用與設定

在 Spring Boot 中整合 R2DBC 主要有兩種方式：

1. **DatabaseClient 方式**：直接操作資料庫，彈性高但需自行處理 SQL 與資料轉換。
2. **R2DBC Repository 方式**：類似傳統 Spring Data Repository，提供標準 CRUD 與自訂查詢，開發效率高。

【重點】
- 使用 R2DBC 時，需額外引入對應資料庫的 R2DBC 驅動（如 r2dbc-h2）。
- Spring Boot 會自動偵測 H2 這類內嵌資料庫，並自動載入 schema.sql、data.sql 進行初始化。
- 若需自訂型別（如 Money），可透過 Converter 進行轉換，並在 R2dbcConfiguration 註冊。

範例設定片段：
- application.properties 設定 R2DBC 連線資訊
- R2dbcConfiguration 註冊自訂轉換器

#### 四、R2DBC Repository 的實作與使用

R2DBC Repository 讓我們能以介面方式定義資料存取邏輯，並自動獲得基本 CRUD 與自訂查詢能力。

【重點】
- 只需繼承 ReactiveCrudRepository，並標註 @Repository，即可自動獲得 save、findById、findAll 等方法。
- 支援自訂查詢（@Query），並可回傳 Flux/Mono 以符合反應式設計。
- 實體類別（如 Coffee）需標註 @Table，並正確標示主鍵欄位。

舉例：
CoffeeRepository 介面可定義 findByName(String name) 方法，並用 @Query 指定 SQL 查詢。

#### 五、實戰演示

以咖啡店點餐系統為例，實作流程如下：

1. 設定 R2DBC 連線與資料庫初始化（H2 記憶體資料庫）
2. 定義 Coffee 實體與 Money 型別轉換器
3. 建立 CoffeeRepository，實作基本查詢與自訂查詢
4. 在主程式中呼叫 repository 方法，並以 Flux/Mono 處理結果
5. 執行專案，觀察非阻塞式資料流的執行效果

【重點】
- 反應式查詢結果會以非同步方式回傳，並可在不同執行緒上並發處理
- 可透過 subscribeOn 指定執行緒池，靈活調度資源

#### 六、課程小結與後續展望

本章節我們學會了如何以 R2DBC 進行反應式資料存取，並比較了兩種主要配置方式：

- DatabaseClient：彈性高，適合複雜查詢，但需自行處理資料轉換
- R2DBC Repository：開發效率高，適合標準 CRUD 與簡單查詢

【優缺點比較】
- Repository 方式更適合大多數業務場景，維護性佳
- 若需高度自訂查詢或特殊資料轉換，可搭配 DatabaseClient

【預告】下一章節將介紹多資料源配置，讓你能同時操作多個資料庫，進一步提升微服務架構的彈性與擴展性。

#### 七、Tips：

- 【重點】R2DBC 尚未完全取代 JDBC，部分資料庫支援度有限，建議評估實際需求再導入
- 使用 LocalDateTime 取代 Date，避免型別轉換錯誤
- Money 型別需正確註冊 Converter，確保資料正確存取
- 反應式程式設計需避免阻塞操作，善用 onErrorResume 等錯誤處理機制
- 若遇循環依賴錯誤，可在 application.properties 設定 spring.main.allow-circular-references=true

如有進一步問題，歡迎參考官方文件或加入社群討論。

---
### 36 | 通過AOP打印數據訪問層的摘要（上）

---
### 37 | 通過AOP打印數據訪問層的摘要（下）― [performance-aspect-demo]
#### 一、課程目標

本章節旨在讓學生深入理解Spring微服務架構中，如何利用Spring AOP（面向切面程式設計）來實現性能監控，特別是在資料訪問層的應用。學生將學會：

- Spring AOP的核心概念與常用注解
- 如何自訂切面來攔截資料庫操作，監控方法執行時間
- 整合P6Spy工具進行SQL執行追蹤
- 使用Joda Money進行精確的金額計算與轉換
- 實務中如何配置與優化性能監控

此外，提供的SpringBucks專案示範，讓學生能夠實際操作並體驗AOP性能監控的效果，並掌握金融應用中金額處理的最佳實踐。

相關資源連結：

- Spring AOP官方文件：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop
- Spring Data JPA參考指南：https://docs.spring.io/spring-data/jpa/docs/current/reference/html/
- Joda Money使用指南：https://www.joda.org/joda-money/
- P6Spy設定指南：https://p6spy.readthedocs.io/

#### 二、Spring AOP核心概念與性能監控切面

Spring AOP是Spring框架中實現面向切面程式設計的模組，主要用於處理橫切關注點（Cross-cutting concerns），例如日誌、事務管理和性能監控。

- **切面（Aspect）**：封裝橫切邏輯的類別，使用@Aspect標註。
- **切點（Pointcut）**：定義攔截哪些方法，通常用表達式指定。
- **通知（Advice）**：切面中具體執行的動作，如@Before、@After、@Around等。
- **代理（Proxy）**：Spring透過代理物件攔截方法調用，執行通知。

在性能監控中，我們常用@Around通知包裹目標方法，計算執行時間，並記錄日誌。示例中定義了攔截所有Repository層方法的切點，並在方法執行前後計時，最後輸出格式化的日誌：

```
方法名;執行結果;執行時間ms
```

這種方式能幫助開發者快速定位性能瓶頸，尤其是在資料庫操作層面。

#### 三、SQL執行追蹤與金額轉換實作

為了更細緻地監控資料庫操作，專案整合了P6Spy工具，它能攔截並可視化所有SQL語句，方便追蹤慢查詢與錯誤。

此外，金融應用中金額計算的精確性至關重要，避免浮點數誤差。專案使用Joda Money庫，並透過JPA的AttributeConverter實現Money與Long（以分為單位）之間的轉換，確保資料庫存取與業務邏輯的一致性。

金額轉換器示例：

- 將Money物件轉為Long存入資料庫
- 從資料庫讀取Long值轉回Money物件（台幣）

這種設計讓金額計算更安全、準確，符合金融系統需求。

#### 四、實戰演示：SpringBucks性能監控專案

專案SpringBucks是一個咖啡店管理系統，透過實際業務場景展示Spring AOP性能監控技術。

- **專案結構清晰**：分為model、repository、service、aspect等模組，方便理解與擴展。
- **性能監控切面**：PerformanceAspect類攔截所有Repository方法，記錄執行時間。
- **SQL監控**：整合P6Spy，實時輸出SQL語句與執行細節。
- **金額處理**：使用Joda Money與自訂轉換器，確保金額計算精確。
- **快速啟動**：使用H2內存資料庫，方便開發測試。

學生可透過克隆專案、編譯與執行，觀察日誌輸出，體驗性能監控的實際效果。

#### 五、課程小結與後續展望

本章節重點在於掌握Spring AOP在微服務架構中對資料訪問層的性能監控應用，並結合SQL追蹤與金額轉換實作，提升系統的可觀察性與金融計算的準確性。

兩種配置方式比較：

- **AOP性能監控**：靈活且非侵入式，適合橫切關注點，但會增加少量執行時間開銷。
- **SQL監控工具（P6Spy）**：專注於資料庫層面，提供詳細SQL執行資訊，但需額外配置。

理解這兩者的優缺點，有助於在實務中選擇合適的監控方案。

下一章節將介紹多數據源配置，幫助學生掌握在微服務架構中如何管理多個資料庫連線，進一步提升系統彈性與擴展性。

#### 六、Tips

- 使用@Around通知時，務必呼叫pjp.proceed()以執行目標方法，否則會阻斷流程。
- 切點表達式可靈活定義，常用的如攔截特定包下所有public方法。
- 性能監控日誌中避免輸出敏感資訊，如用戶身份證號、手機號等，確保資料安全。
- 金額計算務必使用Joda Money或BigDecimal，避免浮點數精度問題。
- 在生產環境中，詳細的SQL與性能監控可能影響效能，建議根據需求調整日誌等級。
- 閱讀官方文件時，先從範例入手，逐步理解語法與用法，避免被大量英文資料嚇倒。

這樣的講義結構與內容，能幫助學生系統性理解Spring微服務架構中性能監控的核心技術，並具備實務操作能力。

---
### 38 | SpringBucks實戰項目進度小結 ― [reactive-springbucks]
#### 一、課程目標

本章節將帶領學生深入理解並實作Spring微服務架構中，如何利用響應式程式設計（Reactive Programming）來進行高效能的資料存取與快取管理。重點涵蓋R2DBC非阻塞資料庫操作、Redis快取整合、資料型別轉換器的設計與應用，以及如何透過Spring Boot 3.x打造企業級的響應式微服務。

學習完本章，學生將能：

- 理解響應式資料庫存取的原理與優勢
- 掌握R2DBC與Redis的整合使用方法
- 熟悉自訂資料型別轉換器的設計與註冊
- 實作響應式Repository與Service層，提升系統效能與擴展性

推薦資源：

- Spring Data R2DBC官方文件：https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/
- Project Reactor參考指南：https://projectreactor.io/docs/core/release/reference/
- Reactive Springbucks專案GitHub：https://github.com/SpringMicroservicesCourse/reactive-springbucks

#### 二、主體

##### 1. 響應式架構與R2DBC介紹

響應式架構強調非阻塞與事件驅動，能有效提升系統在高併發環境下的處理能力。R2DBC（Reactive Relational Database Connectivity）是專為響應式設計的資料庫驅動，取代傳統阻塞式JDBC，實現非同步資料存取。

在本專案中，我們使用Spring Data R2DBC結合H2資料庫，透過Mono與Flux封裝資料流，確保資料操作的非阻塞性。這種設計讓系統能更靈活地處理大量請求，避免因等待資料庫回應而阻塞線程。

##### 2. Redis快取整合與響應式操作

為了提升資料讀取效能，專案中整合了Redis作為快取層，並使用Spring Data Redis Reactive模組實現非同步快取操作。快取策略包括：

- 啟動時從資料庫載入資料並快取至Redis
- 查詢時先從Redis快取讀取，若無資料則回落至資料庫
- 設定快取有效期限，確保資料一致性與及時更新

此設計有效降低資料庫負載，提升系統回應速度，並且保持資料的即時性。

##### 3. 自訂資料型別轉換器

資料庫與應用程式間的資料型別不一定完全對應，特別是複雜型別如金額（Money）與日期時間（LocalDateTime）。專案中實作了多個自訂轉換器：

- MoneyReadConverter與MoneyWriteConverter：將資料庫中的Long型別轉換為Joda Money物件，確保財務計算的準確性與型別安全。
- LocalDateTimeToDateConverter與DateToLocalDateTimeConverter：處理日期時間格式的轉換，避免時間格式錯誤。

這些轉換器透過Spring的Converter介面實作，並在R2DBC配置中註冊，確保資料流轉過程中型別一致。

##### 4. Repository與Service層的響應式實作

Repository層使用R2DBC的DatabaseClient進行非同步SQL操作，並回傳Mono或Flux物件，實現響應式資料存取。Service層則負責業務邏輯，結合快取策略與資料庫操作，確保資料一致性與效能。

例如，CoffeeOrderRepository中使用非阻塞方式插入訂單資料，並回傳訂單ID。CoffeeService則負責從快取或資料庫取得咖啡商品資料，並提供給上層呼叫。

##### 5. 配置與序列化定制

專案中覆寫了Spring Boot預設的RedisTemplate配置，將Key序列化為String，Value序列化為JSON格式的Coffee物件，提升資料可讀性與擴展性。這種定制化序列化策略有助於快取資料的管理與調試。

此外，透過application.properties設定R2DBC與Redis連線參數，並調整日誌等級，方便開發與除錯。

#### 三、實戰演示

本章節配合Reactive Springbucks專案進行實作演示，學生將實際操作以下步驟：

1. 啟動本地Redis服務，確保快取功能可用。
2. 下載並編譯Reactive Springbucks專案。
3. 觀察應用啟動日誌，確認資料庫與快取資料載入成功。
4. 透過REST API或測試程式，執行咖啡商品與訂單的CRUD操作，體驗響應式資料流。
5. 查看Redis快取資料，理解快取命中與失效機制。
6. 分析日誌輸出，理解R2DBC與Redis的非阻塞操作流程。

透過實作，學生能更直觀理解響應式微服務架構的設計與運作。

#### 四、課程小結與後續展望

本章節重點在於掌握響應式資料存取與快取整合的核心技術，並透過Reactive Springbucks專案實踐。兩種配置方式的差異與優缺點如下：

- 傳統阻塞式JDBC操作簡單但效能有限，無法充分利用非同步優勢。
- R2DBC響應式操作雖然學習曲線較陡，但能顯著提升系統在高併發下的效能與擴展性。

理解並掌握響應式資料庫與快取技術，將為後續多數據源配置與複雜微服務架構打下堅實基礎。

下一章節將介紹多數據源配置，探討如何在微服務中靈活管理多個資料庫連線，進一步提升系統的彈性與可靠性。

#### 五、Tips

- 在響應式程式設計中，避免使用阻塞式API，確保整個資料流非阻塞。
- 自訂轉換器是確保資料型別安全與一致性的關鍵，務必正確註冊。
- Redis快取的有效期限設定需根據業務需求調整，避免資料過期導致不一致。
- 使用Spring Boot Actuator監控系統狀態，及時發現背壓與資源瓶頸。
- 多多練習Reactor的操作符（map、flatMap、filter等），提升響應式程式設計能力。

以上內容結合理論與實作，幫助學生全面掌握Spring微服務架構中響應式資料存取的核心技術。

---
# Chapter 6：Spring MVC實踐（14講）
### 39 | 編寫第一個Spring MVC Controller ― [simple-controller-demo]
根據提供的內容，我幫你整理一份Spring MVC Controller的教學講義：

#### 一、課程目標

- 理解Spring MVC的核心組件和基本架構
- 掌握Controller的編寫方法和常用註解
- 學會使用Postman等工具測試REST API
- 實作一個基本的咖啡訂單管理系統

相關資源：
- GitHub範例程式碼：simple-controller-demo
- 開發工具：IntelliJ IDEA、Postman
- 參考文件：Spring MVC官方文件

#### 二、Spring MVC核心概念

1. **DispatcherServlet**
- 所有請求的統一入口
- 負責請求的分發和處理

2. **核心組件**
- Controller：處理請求邏輯
- HandlerMapping：請求與Controller的映射
- ViewResolver：視圖解析
- MultipartResolver：檔案上傳處理
- LocalResolver：地區解析
- ThemeResolver：主題解析

#### 三、常用註解說明

1. **請求映射相關**
- @RequestMapping：通用請求映射
- @GetMapping：處理GET請求
- @PostMapping：處理POST請求
- @PutMapping：處理PUT請求
- @DeleteMapping：處理DELETE請求
- @PatchMapping：處理PATCH請求

2. **參數處理相關**
- @RequestBody：處理請求體
- @ResponseBody：處理響應體
- @ResponseStatus：指定響應狀態碼

#### 四、實戰演示

以咖啡訂單系統為例：

```java
@RestController
@RequestMapping("/coffee")
public class CoffeeController {
    @GetMapping("/")
    public List<Coffee> getAll() {
        return coffeeService.findAll();
    }
}

@RestController
@RequestMapping("/order")
public class CoffeeOrderController {
    @PostMapping("/")
    @ResponseStatus(HttpStatus.CREATED)
    public CoffeeOrder create(@RequestBody NewOrderRequest newOrder) {
        // 處理訂單創建邏輯
    }
}
```

#### 五、API測試工具使用

1. **Postman使用步驟**
- 選擇HTTP方法（GET/POST等）
- 輸入請求URL
- 設置請求參數/請求體
- 發送請求並查看響應

2. **常見測試案例**
- 查詢所有咖啡：GET /coffee/
- 創建新訂單：POST /order/

#### 六、課程小結與後續展望

- Spring MVC提供了強大的Web開發功能
- Controller的設計要注重RESTful風格
- 善用測試工具提高開發效率
- 下一章將介紹更多Spring MVC進階特性

#### Tips：

- 使用@RestController可以省略每個方法的@ResponseBody
- URL設計要符合RESTful規範
- 善用Lombok減少樣板代碼
- 記得做好異常處理和參數驗證
---
### 40 | 理解Spring的應用上下文

---
### 41 | 理解請求的處理機制
---
### 42 | 如何定義處理方法（上） ― [complex-controller-demo]

#### 一、課程目標

本章節將帶領學生深入了解Spring MVC中如何定義控制器（Controller）及其處理方法，並結合實際範例說明請求映射（Request Mapping）的多種配置方式。學生將學會如何利用Spring提供的註解靈活控制HTTP請求的路徑、方法、參數、標頭及內容類型，進而設計符合RESTful API規範的微服務介面。

學習重點包括：
- 理解@Controller與@RestController的差異與應用
- 掌握@RequestMapping及其快捷註解（如@GetMapping、@PostMapping）的使用
- 熟悉請求參數、請求體、響應體的註解配置（如@RequestParam、@RequestBody、@ResponseBody）
- 了解如何限制請求的Content-Type與Accept標頭，確保API的正確交互
- 透過實戰範例操作，體會Spring MVC控制器的彈性與強大

相關資源：
- Spring官方文件：[Spring MVC Controller](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-controller)
- 專案範例代碼：complex-controller-demo（咖啡訂單服務）

#### 二、主體

1. **Spring MVC控制器基礎**

Spring MVC中，控制器類別通常使用@Controller或@RestController標註。@RestController是@Controller與@ResponseBody的組合，適合用於REST API，直接將方法返回值序列化為JSON等格式。

2. **請求映射與HTTP方法**

@RequestMapping是定義請求路徑與方法的核心註解。它可設定多個屬性：
- path/value：指定URL路徑
- method：限定HTTP方法（GET、POST等）
- params：限制請求必須包含或不包含特定參數
- headers：限制請求必須包含特定HTTP標頭
- consumes：限定請求的Content-Type
- produces：限定響應的Content-Type

Spring也提供@GetMapping、@PostMapping等快捷註解，簡化常用HTTP方法的映射。

3. **方法參數與返回值**

控制器方法可接受多種參數，如：
- @RequestParam：取得URL查詢參數
- @PathVariable：取得路徑變數
- @RequestBody：將請求體反序列化為Java物件
- @RequestHeader：取得HTTP標頭
- BindingResult：用於驗證結果

返回值可是物件、ResponseEntity等，Spring會根據配置自動序列化。

4. **請求與響應內容類型控制**

利用consumes與produces屬性，可以限制API只接受特定Content-Type的請求，並回傳指定格式的響應。這對於確保API的正確交互與錯誤處理非常重要。

5. **實務範例說明**

以complex-controller-demo專案中的CoffeeController與CoffeeOrderController為例，展示如何：
- 使用@PostMapping限定只接受application/json格式的請求
- 利用@RequestParam取得查詢參數
- 設定produces為application/json;charset=UTF-8，確保響應格式
- 透過Postman測試不同Content-Type與Accept標頭，觀察API行為與錯誤回應（如406 Not Acceptable）

這些範例幫助學生理解如何靈活配置控制器，並掌握常見錯誤的成因與解決方式。

#### 三、實戰演示

- 啟動complex-controller-demo專案
- 使用Postman發送POST請求至/order，Content-Type設為application/json，Body為訂單資料，觀察成功回應
- 嘗試將Content-Type改為text/plain，驗證API回傳415錯誤
- 修改Accept標頭為不支援格式，觀察406錯誤
- 使用@GetMapping與@RequestParam查詢咖啡列表，體會參數映射
- 透過日誌與錯誤訊息，理解Spring如何處理請求與響應

#### 四、課程小結與後續展望

本章節重點在於掌握Spring MVC控制器的定義與請求映射配置，理解如何透過註解靈活控制HTTP請求的路徑、方法、參數與內容類型，並結合實務範例加深印象。兩種主要配置方式（如@RequestMapping與@GetMapping等快捷註解）各有優缺點，快捷註解簡潔明瞭，適合常見場景；而@RequestMapping則更靈活，適合複雜需求。

後續章節將介紹多數據源配置，幫助學生進一步理解微服務架構中資料層的彈性設計與管理，銜接更完整的Spring微服務實踐。

#### 五、Tips：

- 使用@RestController可省略@ResponseBody，簡化API開發
- 利用params與headers屬性可實現更細緻的請求匹配，避免路由衝突
- consumes與produces屬性是API設計中確保資料格式正確的關鍵
- 參考Spring官方文件，熟悉各種方法參數與返回值類型，提升開發效率
- 實務中建議搭配API文件工具（如Swagger）提升團隊協作與維護性

這樣的講義結構與內容，能幫助IT背景學生系統性理解Spring微服務中控制器的設計與實作，並具備實務操作能力。

---
### 43 | 如何定義處理方法（下）― [more-complex-controller-demo]
#### 一、課程目標

本章節旨在讓學生深入理解Spring Boot中Web層的自動配置機制，特別是Spring MVC的處理方法定義與自定義類型轉換的實作。學生將學會如何利用Spring Boot的WebMVC Auto Configuration來自動註冊Converter、Formatter，並掌握表單資料驗證、Multipart檔案上傳的配置與實作技巧。透過實戰專案「咖啡店訂單管理系統」，學生能夠體驗複雜控制器設計、資料驗證、異常處理與多格式請求支援的完整流程。

相關資源連結：
- Spring Boot官方文件：https://spring.io/projects/spring-boot
- Spring MVC參考指南：https://docs.spring.io/spring-framework/reference/web/webmvc.html
- Jakarta Validation規範：https://beanvalidation.org/
- Joda Money文件：https://www.joda.org/joda-money/
- 專案GitHub（More Complex Controller Demo）：請參考配套程式碼目錄

#### 二、Spring Boot WebMVC自動配置與類型轉換

Spring Boot透過WebMVC Auto Configuration自動配置Web相關元件，讓開發者無需手動註冊大量設定。其中，核心在於自動註冊三種型別轉換器：Converter、GenericConverter與Formatter。這些轉換器會從Spring容器中取得並加入到註冊表中，確保請求參數能正確轉換成目標物件。

以自定義的MoneyFormatter為例，它實作了Formatter介面，支援將字串（如"TWD 100.00"或"100.00"）轉換成Money物件，並反向格式化。這種自定義格式化器的註冊，讓Spring MVC能自動處理複雜的貨幣類型轉換，避免浮點數精度問題，提升系統穩定性。

此外，Spring Boot也提供Multipart Auto Configuration，幫助開發者輕鬆配置MultipartResolver，支援檔案上傳功能。透過application.properties設定檔，可以靈活調整檔案大小限制等參數。

#### 三、資料驗證與錯誤處理

在控制器中，使用@Valid註解搭配BindingResult可以實現請求參數的驗證。當驗證失敗時，BindingResult會捕捉錯誤，開發者可自訂錯誤處理邏輯，避免Spring MVC自動拋出異常。這種方式讓錯誤處理更靈活，方便回傳自定義錯誤訊息。

專案中示範了如何在新增咖啡商品的表單中，對名稱與價格欄位進行非空與格式驗證，並在驗證失敗時記錄錯誤訊息或拋出自訂異常。全域異常處理器（@ControllerAdvice）則負責統一捕捉並回應驗證錯誤，提升API一致性。

#### 四、Multipart檔案上傳與批次處理

專案展示了如何使用MultipartFile接收檔案，並透過BufferedReader逐行讀取檔案內容，實現批次新增咖啡商品。每行格式為「名稱 價格」，系統會解析並轉換成Money物件後存入資料庫。

此設計示範了Multipart檔案上傳的實務操作流程，包括檔案讀取、例外處理與資源釋放，讓學生理解如何在Spring Boot中安全且有效地處理檔案上傳需求。

#### 五、實戰演示

本章節配套的「More Complex Controller Demo」專案，完整呈現上述技術的應用。學生可透過以下步驟快速啟動並測試：

1. 克隆專案並進入目錄
2. 使用Maven編譯並啟動Spring Boot應用
3. 利用Postman或curl測試API，包括：
   - 使用Form Data格式新增單筆咖啡商品，支援自定義貨幣格式
   - 使用Multipart格式批次上傳咖啡商品檔案
   - 查詢咖啡商品列表
4. 觀察資料驗證錯誤回應與自定義錯誤處理流程

透過實作，學生能夠鞏固理論知識，並掌握Spring MVC中複雜控制器設計與資料處理的實務技巧。

#### 六、課程小結與後續展望

本章節重點在於理解Spring Boot WebMVC的自動配置機制，掌握自定義類型轉換器（如MoneyFormatter）的實作與註冊，並熟悉表單驗證、異常處理及Multipart檔案上傳的完整流程。這些技術是構建穩健微服務架構的基礎，能有效提升開發效率與系統可維護性。

兩種主要配置方式比較：
- **自動配置**：減少手動設定，快速上手，適合大多數場景
- **自訂控制**：靈活度高，可針對特殊需求調整，適合複雜業務邏輯

後續章節將介紹多數據源配置，幫助學生進一步理解如何在微服務架構中管理多個資料庫連線，實現更靈活的資料存取策略。

#### 七、Tips

- 自定義Formatter與Converter是Spring MVC中處理複雜資料類型轉換的利器，建議多練習實作與應用。
- 使用@Valid與BindingResult搭配，可以有效控制資料驗證流程，避免系統拋出不友善的錯誤訊息。
- Multipart檔案上傳時，務必注意資源釋放與例外處理，避免系統資源浪費或崩潰。
- 利用Spring Boot的自動配置機制，能大幅減少繁瑣設定，提升開發效率，但遇到特殊需求時仍可覆寫預設行為。
- 在實務專案中，建議搭配全域異常處理器統一管理錯誤回應，提升API一致性與可維護性。

這樣的講義結構與內容，能幫助學生系統性掌握Spring微服務架構中Web層的核心技術，並透過實戰專案加深理解與應用。

---
### 44 | Spring MVC中的視圖解析機制（上）
---
### 45 | Spring MVC中的視圖解析機制（下）
---
### 46 | Spring MVC中的常用視圖（上）― [json-view-demo]
#### 一、課程目標

本章節旨在讓學生深入理解Spring微服務架構中，Spring MVC的處理方法定義與實作細節，重點涵蓋：

- Spring Boot中WebMVC的自動配置機制與擴展方式
- 自訂類型轉換器（Converter、Formatter）的設計與應用
- 表單資料綁定與驗證流程
- Multipart檔案上傳的配置與實作
- 如何自訂錯誤處理流程，掌握BindingResult的使用
- 透過實戰範例，理解多格式請求處理（JSON、Form、Multipart）

同時，提供配套的範例程式碼與專案資源，方便學生實際操作與練習。

相關資源連結：

- Spring Boot官方文件：https://spring.io/projects/spring-boot
- Spring Data JPA參考手冊：https://docs.spring.io/spring-data/jpa/docs/current/reference/html/
- Joda Money文件：https://www.joda.org/joda-money/
- 專案範例：[Spring Boot咖啡訂單服務](https://github.com/SpringMicroservicesCourse/json-view-demo)

#### 二、Spring Boot WebMVC自動配置與類型轉換

Spring Boot透過WebMVC Auto Configuration自動配置Web層，核心在於提供一個WebMvcConfigurer的預設實作，讓開發者能輕鬆擴展功能。重點在於：

- **Add Formatters方法**：Spring Boot會自動從Spring容器中取得Converter、GenericConverter與Formatter三種Bean，並註冊到格式化註冊器（FormatterRegistry）中，實現類型轉換的擴展。
- **Converter與Formatter的差異**：Converter主要負責類型間的轉換，而Formatter則同時提供解析（parse）與格式化（print）功能，適合處理複雜格式如貨幣、日期等。
- 透過自訂Formatter（例如MoneyFormatter），可以將複雜的貨幣字串轉換成Joda Money物件，並反向格式化輸出，提升資料處理的精確度與可讀性。

這種設計讓Spring MVC的資料綁定更靈活，方便開發者根據業務需求自訂轉換邏輯。

#### 三、表單綁定與資料驗證

在Spring MVC中，表單資料綁定是核心功能，透過@RequestParam或@RequestBody將HTTP請求參數映射到Java物件。重點包括：

- 使用**@Valid**搭配Jakarta Bean Validation註解（如@NotEmpty、@NotNull）實現資料驗證，確保輸入資料的完整性與正確性。
- 綁定結果會透過BindingResult物件回傳，開發者可檢查是否有錯誤，並自訂錯誤處理邏輯，避免預設的錯誤處理流程介入。
- 範例中展示了如何在Controller中判斷BindingResult是否有錯誤，並主動拋出自訂異常或回傳錯誤訊息，提升錯誤處理的彈性與可控性。

這種方式讓開發者能更細緻地控制表單驗證流程，符合實務中多樣化的錯誤處理需求。

#### 四、Multipart檔案上傳配置與實作

Spring Boot提供Multipart Auto Configuration，簡化檔案上傳的設定。重點如下：

- 內建MultipartResolver，支援標準的multipart/form-data請求格式。
- 可透過application.properties設定檔調整上傳檔案大小限制（如spring.servlet.multipart.max-file-size、max-request-size）。
- Controller中使用MultipartFile參數接收上傳檔案，並可透過InputStream讀取檔案內容進行後續處理。
- 範例中展示了如何解析上傳的文字檔案，將多筆咖啡訂單資料批次新增，實現實務中常見的批量資料匯入功能。

這讓微服務的Web層能靈活處理多種資料輸入方式，提升系統的擴展性與使用者體驗。

#### 五、實戰演示

本章節配套的More Complex Controller Demo範例，涵蓋以下重點：

- 自訂MoneyFormatter實現貨幣字串與Money物件的雙向轉換。
- CoffeeController中展示多種請求處理方式：表單提交（FormUrlEncoded）、JSON請求、Multipart檔案上傳。
- 表單資料驗證與BindingResult錯誤處理示範，包含自訂錯誤回應邏輯。
- 使用Postman模擬API請求，驗證新增咖啡資料、錯誤驗證回應與批量上傳功能。

學生可透過下載並執行範例程式碼，實際體驗Spring MVC在微服務架構中的應用，並嘗試修改與擴展功能，加深理解。

#### 六、課程小結與後續展望

本章節重點在於掌握Spring Boot自動配置下的Web層擴展機制，尤其是類型轉換與資料綁定的細節，並實作Multipart檔案上傳功能。兩種配置方式的差異與優缺點：

- **自動配置方式**：方便快速開發，減少樣板程式碼，但對細節控制較少。
- **自訂配置方式**：靈活度高，可精細調整轉換與驗證邏輯，但需要更多程式碼維護。

理解這些差異有助於學生在實務中根據需求選擇合適的實作策略。

下一章節將介紹多數據源配置，幫助學生進一步掌握微服務架構中資料庫的多樣化管理與整合。

#### 七、Tips

- 在自訂Formatter時，務必考慮資料格式的多樣性與錯誤處理，避免轉換異常導致系統錯誤。
- 使用BindingResult檢查驗證錯誤，能有效避免因資料不合法導致的系統異常，提升API穩定性。
- Multipart檔案上傳時，注意設定合理的檔案大小限制，防止惡意攻擊或資源耗盡。
- 多利用Postman等工具模擬各種請求格式，確保API在不同情境下的正確性與健壯性。
- 透過分層架構設計（Controller-Service-Repository），保持程式碼清晰且易於維護。

這樣的教學結構能幫助學生系統性掌握Spring微服務架構中Web層的核心技術，並具備實務操作能力。

---
### 47 | Spring MVC中的常用視圖（下）― [thymeleaf-view-demo]
根據提供的內容，我幫你整理一份關於Spring MVC視圖解析機制的講義:

#### 一、課程目標

本節課程將探討Spring MVC中的視圖解析機制,特別是@ResponseBody註解的處理流程。學習重點包括:
- 理解@ResponseBody處理請求的完整流程
- 掌握Spring MVC中的重定向機制
- 了解不同視圖解析器的應用場景

相關資源:
- Spring MVC官方文件
- 示範專案程式碼
- 課堂練習環境

#### 二、@ResponseBody處理流程

1. HandleAdapter處理過程
- 在調用Controller方法後立即處理返回對象
- 通過RequestMappingHandlerAdapter進行處理
- 最終由ResponseBodyMethodProcessor完成處理

2. 處理步驟詳解
- 首先在HandleAdapter中獲取ReturnValueHandlers
- 執行目標方法獲取返回值
- 選擇合適的MessageConverter進行轉換
- 將結果寫入Response

> 🔍 重點提示: Spring MVC提供多種ReturnValueHandler,針對不同返回類型進行處理

#### 三、實戰演示

以Debug方式展示一個GET請求的完整處理流程:

1. 請求進入
```java
@GetMapping("/coffee/{id}")
public Coffee getCoffeeById(@PathVariable Long id) {
    return coffeeService.getCoffee(id);
}
```

2. 關鍵斷點位置:
- RequestMappingHandlerAdapter.invokeHandlerMethod
- ResponseBodyMethodProcessor.handleReturnValue 

3. 處理過程觀察:
- 設置ReturnValueHandlers
- 方法調用獲取返回值
- 選擇MappingJackson2HttpMessageConverter
- 輸出JSON響應

#### 四、重定向機制

Spring MVC提供兩種重定向方式:

1. redirect重定向
- 執行302跳轉
- 客戶端發起新請求
- URL會改變
- 會丢失request信息

2. forward轉發  
- 服務器內部跳轉
- URL不變
- 保留request信息

> ⚠️ 注意: 在微服務架構中使用redirect需要特別注意,因為可能跳轉到不同服務器

#### 五、課程小結與後續展望

- 理解了@ResponseBody的處理機制
- 掌握了不同類型返回值的處理方式
- 了解重定向的使用場景與注意事項

下節課程將介紹:
- Spring MVC常用視圖技術
- Thymeleaf模板引擎的使用

#### Tips

1. 開發建議
- 合理使用@ResponseBody,避免濫用
- 注意重定向可能帶來的問題
- 選擇合適的MessageConverter

2. 調試技巧
- 善用斷點調試了解處理流程
- 觀察ReturnValueHandlers的選擇過程
- 注意響應格式的設置


---
### 48 | 靜態資源與緩存 ― [cache-demo2]
根據提供的內容，我幫你整理一份關於Spring靜態資源與快取的講義：

#### 一、課程目標

本節課程將介紹Spring框架中靜態資源處理與快取機制的實作方式，讓學生了解:
- 如何在Spring Boot中配置和管理靜態資源
- 如何實作HTTP快取控制
- 企業級應用中靜態資源處理的最佳實踐

相關資源:
- Spring Boot官方文檔
- 示範專案: cache-demo2

#### 二、靜態資源配置基礎

Spring Boot提供了豐富的靜態資源支持，核心配置位於WebMvcConfigurer的addResourceHandlers方法中。

重要配置項目:
1. 靜態資源路徑模式(預設為根路徑)
```properties
spring.mvc.static-path-pattern=/static/**
```

2. 資源搜尋路徑:
- /static
- /public 
- /resources
- /META-INF/resources

> [!TIP] 建議
> 建議將靜態資源統一放在指定目錄下,方便管理

#### 三、快取控制實作

Spring Boot中的快取配置主要通過ResourceProperties進行設置:

1. 全局快取配置
```properties
spring.web.resources.cache.cachecontrol.max-age=20s
```

2. 程式控制快取
```java
@GetMapping("/coffee/{id}")
public ResponseEntity<Coffee> getCoffee(@PathVariable Long id) {
    return ResponseEntity
        .ok()
        .cacheControl(CacheControl.maxAge(10, TimeUnit.SECONDS))
        .body(coffeeService.getCoffee(id));
}
```

#### 四、實戰演示

使用cache-demo2專案展示:
1. 靜態資源訪問測試
2. 快取控制效果驗證
3. 使用Postman觀察HTTP響應頭

#### 五、企業級最佳實踐

推薦的靜態資源架構:
1. 使用CDN分發靜態資源
2. 設置專門的靜態資源服務器
3. 採用CMS系統管理資源
4. 在Gateway層實現快取控制
5. 考慮使用Squid或Varnish做中間層快取

> [!NOTE] 重點提醒
> 不建議在Spring Boot應用中直接處理靜態資源,應交由專門的服務來處理

#### 六、Tips

1. 快取時間單位預設為秒
2. 測試時可使用瀏覽器開發者工具觀察快取行為
3. 生產環境建議:
   - 設置適當的快取策略
   - 考慮資源版本控制
   - 實施監控機制
---
### 49 | Spring MVC中的異常處理機制 ― [exception-demo]
根據提供的內容，我幫你整理出一份Spring MVC異常處理機制的講義：

#### 一、課程目標

本章節將介紹Spring MVC的異常處理機制，學習如何優雅地處理系統中的各種異常情況。

重點：
- 理解Spring MVC異常處理的核心組件
- 掌握兩種主要的異常處理方式
- 學會實作全域性的異常處理機制

#### 二、異常處理核心架構

Spring MVC的異常處理主要依賴HandlerExceptionResolver介面及其實現類：

1. 核心組件：
- ExceptionHandlerExceptionResolver
- ResponseStatusExceptionResolver 
- DefaultHandlerExceptionResolver
- HandlerExceptionResolverComposite

2. 處理流程：
- 當Controller拋出異常時，會被DispatcherServlet捕獲
- 異常會依序經過各個HandlerExceptionResolver進行處理
- 如果某個Resolver可以處理該異常，則返回對應的ModelAndView

#### 三、異常處理方式

1. @ResponseStatus註解：
```java
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class FormValidationException extends RuntimeException {
    // 異常實作
}
```

2. @ExceptionHandler方法：
```java
@RestControllerAdvice
public class GlobalControllerAdvice {
    @ExceptionHandler(ValidationException.class)
    public Map<String, String> handleValidationException(ValidationException ex) {
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        return response;
    }
}
```

#### 四、實戰演示

以咖啡訂單系統為例：

1. 表單驗證異常處理：
```java
@PostMapping("/")
public Coffee addCoffee(@Valid CoffeeForm form, BindingResult result) {
    if (result.hasErrors()) {
        throw new FormValidationException("表單驗證失敗");
    }
    return coffeeService.saveCoffee(form);
}
```

2. JSON請求異常處理：
```java
@PostMapping(path = "/", consumes = MediaType.APPLICATION_JSON_VALUE)
public Coffee addJsonCoffee(@Valid @RequestBody CoffeeForm form) {
    // 驗證失敗會自動拋出ValidationException
    return coffeeService.saveCoffee(form);
}
```

#### 五、課程小結與後續展望

異常處理的最佳實踐：
- 統一使用@RestControllerAdvice進行全域異常處理
- 為重要的自訂異常添加@ResponseStatus註解
- 根據API類型選擇合適的異常處理策略

#### 六、Tips

1. @RestControllerAdvice的優先級低於Controller中的@ExceptionHandler
2. ExceptionHandler方法可以接受多種參數類型
3. 建議將異常處理邏輯統一管理，便於維護
4. 異常訊息應清晰明確，便於調試與問題排查
---
### 50 | 瞭解Spring MVC的切入點 ― [springbucks2]
根據提供的內容，我幫你整理一份關於Spring MVC攔截器的教學講義：

#### 一、課程目標

本章節將介紹Spring MVC的攔截器(Interceptor)機制，學習如何實作和配置攔截器來處理橫切關注點(Cross-cutting Concerns)。

學習重點：
- 理解HandlerInterceptor介面的生命週期
- 掌握攔截器的配置方式
- 實作效能監控攔截器
- 了解攔截器的應用場景

相關資源：
- Spring MVC官方文件
- 示範專案：SpringBucks

#### 二、攔截器基礎概念

HandlerInterceptor介面定義了三個核心方法：

1. preHandle
- 在方法處理前執行
- 返回true繼續執行，false則終止請求
- 常用於權限驗證等預處理操作

2. postHandle
- 在方法執行後，視圖渲染前執行
- 可用於修改Model或視圖

3. afterCompletion  
- 在整個請求完成後執行
- 可進行資源清理等操作

> 📌 注意：非同步請求不會執行postHandle和afterCompletion方法

#### 三、實戰演示：效能監控攔截器

以SpringBucks專案為例，實作一個效能監控攔截器：

```java
@Component
public class PerformanceInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(...) {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        request.setAttribute("stopWatch", stopWatch);
        return true;
    }
    
    @Override
    public void afterCompletion(...) {
        StopWatch stopWatch = (StopWatch) request.getAttribute("stopWatch");
        stopWatch.stop();
        
        log.info("請求處理摘要 - URL: {}, 耗時: {}ms", 
                request.getRequestURI(),
                stopWatch.getTotalTimeMillis());
    }
}
```

配置攔截器：
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new PerformanceInterceptor())
               .addPathPatterns("/coffee/**", "/order/**");
    }
}
```

#### 四、課程小結與後續展望

攔截器的主要應用場景：
- 權限驗證
- 效能監控
- 日誌記錄
- 快取處理
- 異常處理

Tips：
- 合理使用攔截器，避免過多攔截器影響效能
- 注意攔截器的執行順序
- 建議在開發環境啟用詳細日誌，生產環境適當調整

下一章節將介紹：Spring Security整合與權限控制

---
### 51 | SpringBucks實戰項目進度小結
---
### 52 | 課程答疑
---
# Chapter 7：訪問Web資源（5講）
### 53 | 通過RestTemplate訪問Web資源
根據提供的內容，我幫你整理一份關於使用RestTemplate訪問Web資源的教學講義：

#### 一、課程目標

本章節將介紹如何使用Spring提供的RestTemplate來訪問Web資源，特別是如何呼叫REST API並處理JSON回應。

學習重點：
- 了解RestTemplate的基本用法
- 掌握不同HTTP方法的調用方式
- 學習URI的動態構建
- 理解響應處理的多種方式

相關資源：
- Spring官方文件
- 示範專案：simple-resttemplate-demo

#### 二、RestTemplate基礎概念

RestTemplate提供了多種與HTTP方法對應的方法：

1. GET相關方法
- getForObject：直接獲取響應內容並轉換為指定對象
- getForEntity：獲取完整的ResponseEntity，包含狀態碼和標頭

2. POST相關方法
- postForObject：發送POST請求並獲取響應對象
- postForEntity：發送POST請求並獲取完整ResponseEntity

3. 其他HTTP方法
- put：發送PUT請求
- delete：發送DELETE請求

> 📌 注意：Spring Boot並未提供RestTemplate的自動配置，需要手動創建實例

#### 三、實戰演示

以訪問咖啡服務為例：

```java
@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }
}

// 使用範例
@Autowired
private RestTemplate restTemplate;

// GET請求示例
Coffee coffee = restTemplate.getForObject(
    "http://localhost:8080/coffee/{id}",
    Coffee.class,
    1
);

// POST請求示例
Coffee newCoffee = Coffee.builder()
    .name("美式咖啡")
    .price(BigDecimal.valueOf(25))
    .build();
Coffee response = restTemplate.postForObject(
    "http://localhost:8080/coffee",
    newCoffee,
    Coffee.class
);
```

#### 四、URI構建

使用UriComponentsBuilder動態構建請求URL：

```java
URI uri = UriComponentsBuilder
    .fromUriString("http://localhost:8080/coffee/{id}")
    .build(1);
```

#### 五、課程小結與後續展望

RestTemplate的主要應用場景：
- 呼叫外部REST API
- 微服務間的通信
- 第三方服務整合

Tips：
- 建議使用建構子注入RestTemplate
- 適當處理異常情況
- 考慮使用連接池優化性能
- 生產環境中處理金錢時使用專門的Money對象

下一章節將介紹：使用WebClient作為響應式Web客戶端

---
### 54 | RestTemplate的高階用法 ― [complex-resttemplate-demo]

#### 一、課程目標

本章節將帶領學生深入掌握RestTemplate在Spring微服務架構中的進階應用，重點包括：

- 處理複雜資料型別（如Joda Money）與自訂序列化器
- 使用ParameterizedTypeReference解決泛型集合的Java泛型擦除問題
- 支援多種HTTP方法與多格式（JSON、XML）響應處理
- 理解RestTemplate配置的最佳實踐與錯誤處理

相關資源：
- Github範例專案 complex-resttemplate-demo
- Spring官方RestTemplate文件

#### 二、RestTemplate進階特性詳解

1. 複雜資料型別處理  
   - 使用Joda Money物件替代BigDecimal，避免浮點數精度問題  
   - 自訂MoneySerializer與MoneyDeserializer，實現Money物件的JSON序列化與反序列化  
   - 支援XML與JSON格式的API響應，透過Accept標頭指定期望格式  

1. 泛型集合處理  
```
使用ParameterizedTypeReference<List<Coffee>>保留泛型資訊，確保Jackson能正確轉換
避免因泛型擦除導致的ClassCastException（LinkedHashMap轉換錯誤）
Java泛型擦除導致直接使用List<Coffee>.class無法正確反序列化  
使用ParameterizedTypeReference<List<Coffee>>保留泛型資訊，確保Jackson能正確轉換
避免因泛型擦除導致的ClassCastException（LinkedHashMap轉換錯誤）
```

3. 多種HTTP方法與請求構建  
   - 使用RequestEntity建構複雜請求，設定標頭如Accept  
   - 支援GET、POST等多種HTTP方法的進階用法  
   - 建構動態URI，靈活調整請求參數  

4. RestTemplate配置最佳實踐  
   - 將RestTemplate配置獨立成@Configuration類別，避免循環依賴  
   - 採用建構子注入方式注入RestTemplate  
   - 實作適當的異常處理機制，提升系統穩定性  

#### 三、實戰演示

1. RestTemplate配置  
```java
@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }
}
```

2. 發送XML格式GET請求  
```java
URI uri = UriComponentsBuilder.fromUriString("http://localhost:8080/coffee/?name={name}").build("mocha");
RequestEntity<Void> req = RequestEntity.get(uri).accept(MediaType.APPLICATION_XML).build();
ResponseEntity<String> resp = restTemplate.exchange(req, String.class);
System.out.println(resp.getBody()); // 輸出XML格式的咖啡資料
```

3. 使用Money物件POST請求  
```java
Coffee request = Coffee.builder()
    .name("Americano")
    .price(Money.of(CurrencyUnit.of("TWD"), 125.00))
    .build();
Coffee response = restTemplate.postForObject("http://localhost:8080/coffee", request, Coffee.class);
System.out.println("Created Coffee ID: " + response.getId());
```

4. 泛型集合響應處理  
```java
ParameterizedTypeReference<List<Coffee>> ptr = new ParameterizedTypeReference<List<Coffee>>() {};
ResponseEntity<List<Coffee>> list = restTemplate.exchange("http://localhost:8080/coffee", HttpMethod.GET, null, ptr);
list.getBody().forEach(c -> System.out.println(c));
```

5. 錯誤示範與解析  
- 直接使用List.class會導致ClassCastException，因為Jackson無法獲取泛型資訊，將JSON物件轉為LinkedHashMap  
- 使用ParameterizedTypeReference解決此問題，保留泛型型別資訊，確保型別安全  

#### 四、課程小結與後續展望

- RestTemplate提供強大且靈活的HTTP客戶端功能，適合微服務間的同步通信  
- 使用ParameterizedTypeReference是處理泛型集合的關鍵技巧，避免泛型擦除帶來的問題  
- 自訂序列化器能優雅處理複雜資料型別，提升資料傳輸的準確性  
- 下一章節將介紹WebClient，實現響應式非阻塞的Web客戶端，提升系統效能與擴展性  

#### 五、Tips

- 使用建構子注入RestTemplate，避免循環依賴  
- 設定Accept標頭，明確告知服務端期望的響應格式（JSON或XML）  
- 泛型集合響應必須使用ParameterizedTypeReference，避免ClassCastException  
- 自訂序列化器與反序列化器是處理特殊資料型別（如Money）的最佳方案  
- 適當捕獲並處理RestTemplate異常，提升系統健壯性  

這份講義結構清晰，內容詳盡，適合IT背景學生理解RestTemplate的進階用法，並能在微服務架構中靈活應用。

---
### 55 | 簡單定制RestTemplate ― [advanced-resttemplate-demo]
#### 一、課程目標

本章節將帶領學生深入了解如何在Spring微服務架構中，進階自訂RestTemplate的底層HTTP連線池管理、Keep-Alive策略與超時設定。透過實務範例，學生將學會如何優化HTTP請求的效能與穩定性，避免系統因連線資源耗盡或無限等待而hang死，提升微服務間通訊的可靠度與效率。

學習重點包括：
- 理解Spring RestTemplate底層的HTTP請求工廠（ClientHttpRequestFactory）及其多種實現。
- 掌握Apache HttpClient連線池與Keep-Alive策略的自訂方法。
- 設定合理的連線與讀取超時，保障系統資源。
- 了解如何關閉HTTP Client的自動重置機制，避免重複請求導致的業務錯誤。

相關資源連結：
- Spring Boot官方文件：https://docs.spring.io/spring-boot/docs/current/reference/html/
- Apache HttpClient5官方文件：https://hc.apache.org/httpcomponents-client-5.3.x/index.html
- Spring RestTemplate官方文件：https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html
- 專案範例代碼：https://github.com/SpringMicroservicesCourse/advanced-resttemplate-demo

#### 二、Spring RestTemplate底層請求工廠與多種實現

Spring的RestTemplate是微服務間常用的HTTP客戶端工具，其底層透過ClientHttpRequestFactory來建立HTTP請求。預設情況下，Spring使用SimpleClientHttpRequestFactory，基於JDK內建的HttpURLConnection實現，適合簡單場景。

然而，為了應對高併發與複雜需求，Spring也支援多種更強大的實現：
- Apache HttpComponents（HttpClient）：提供連線池管理、Keep-Alive策略、連線重用等高級功能。
- Netty：非阻塞IO的HTTP客戶端，適合反應式應用。
- OKHttp：Android開發者熟悉的高效HTTP客戶端。

本章節重點在於如何利用Apache HttpClient進行連線池與Keep-Alive的自訂，提升RestTemplate的效能與穩定性。

#### 三、Apache HttpClient連線池與Keep-Alive策略自訂

在高併發環境下，HTTP連線的管理至關重要。Apache HttpClient提供了PoolingHttpClientConnectionManager來管理連線池，避免每次請求都建立新連線，節省資源與時間。

主要設定包括：
- 最大連線數（MaxTotal）：整體可用連線數量上限。
- 每個路由最大連線數（DefaultMaxPerRoute）：針對特定目標主機的連線數限制。
- 連線存活時間（Keep-Alive Timeout）：決定連線在空閒狀態下保持多久可被重用。

此外，透過自訂Keep-Alive策略，可以從HTTP回應標頭中解析Timeout值，動態調整連線存活時間，提升連線利用率。

範例中，我們設定最大200個連線，單一路由最多20個，並將連線存活時間預設為30秒。這樣的配置能有效支援高併發請求，同時避免連線過早關閉導致的效能損失。

#### 四、超時設定與自動重置機制

為了防止系統因等待下游服務回應過久而資源耗盡，必須設定合理的連線超時（Connection Timeout）與讀取超時（Read Timeout）。例如，連線超時設定為100毫秒，讀取超時設定為500毫秒，能確保系統在異常狀況下快速失敗並釋放資源。

另外，Apache HttpClient預設會在某些錯誤情況下自動重置連線，但在金融交易等敏感場景中，這可能導致重複請求與業務錯誤。範例中示範如何關閉自動重置機制，避免重複執行關鍵操作。

#### 五、實戰演示

本章節提供一個基於Spring Boot 3.2.5與Apache HttpClient5的進階RestTemplate範例專案，示範如何：
- 引入Apache HttpClient依賴。
- 建立PoolingHttpClientConnectionManager並設定連線池參數。
- 自訂Keep-Alive策略，從HTTP回應標頭動態取得Timeout。
- 設定連線與讀取超時。
- 關閉HTTP Client自動重置機制。
- 將自訂HttpClient整合至RestTemplate。

學生可透過GitHub專案（advanced-resttemplate-demo）克隆並執行，實際體驗配置效果與程式碼結構。

#### 六、課程小結與後續展望

本章節重點在於提升Spring微服務中HTTP通訊的效能與穩定性，透過自訂RestTemplate底層的HTTP連線池與Keep-Alive策略，解決高併發下連線資源耗盡與系統hang死的問題。

兩種主要配置方式比較：
- 預設SimpleClientHttpRequestFactory：簡單易用，適合低流量場景，但缺乏連線池管理。
- Apache HttpClient自訂連線池：適合高併發，提供細緻的連線管理與超時控制，但配置較複雜。

理解這些差異有助於學生根據實際需求選擇合適方案。

下一章節將介紹多數據源配置，幫助學生掌握更複雜的微服務資料管理策略，銜接後續學習。

#### 七、Tips

- **務必設定超時**：避免系統因無限等待下游服務而資源耗盡。
- **連線池參數需依流量調整**：過小會造成頻繁建立連線，過大則浪費資源。
- **關閉自動重置機制適用於敏感操作**：避免重複請求導致業務錯誤。
- **閱讀官方文件**：Apache HttpClient與Spring官方文件提供豐富範例與最佳實踐。
- **使用環境變數管理敏感資訊**：提升系統安全性與可維護性。

這樣的講義結構與內容，能幫助學生系統性理解並實作Spring微服務中HTTP通訊的進階優化，為後續更複雜的微服務架構打下堅實基礎。

---
### 56 | 通過WebClient訪問Web資源  ― [webclient-demo]

根據提供的內容，我幫你整理一份關於WebClient的教學講義：

#### 一、課程目標

本課程旨在介紹Spring WebClient，一個現代化的非同步HTTP客戶端工具。學習重點包括：
- 了解WebClient的基本概念與優勢
- 掌握WebClient的創建與配置方法
- 實踐各種HTTP請求操作
- 學習響應式程式設計在HTTP客戶端中的應用

> 💡 **實務意義**：WebClient逐漸取代傳統的RestTemplate，是Spring生態系統中推薦的HTTP客戶端解決方案。

#### 二、WebClient基礎概念

WebClient是一個以Reactive方式處理HTTP請求的客戶端，具有以下特點：
- 非阻塞式設計
- 支援響應式程式設計
- 支援兩種HTTP底層實現：
  - Reactor Netty（推薦）
  - Jetty
  
> 🔑 **核心優勢**：高效能、非阻塞、支援響應式程式流

#### 三、WebClient配置與創建

創建WebClient有兩種主要方式：
```java
// 方式1：直接創建
WebClient webClient = WebClient.create();

// 方式2：使用Builder模式（推薦）
WebClient webClient = WebClient.builder()
    .baseUrl("http://localhost:8080")
    .defaultHeader("Accept", "application/json")
    .build();
```

> 📝 **注意**：Spring Boot並不會自動配置WebClient實例，需要手動創建。

#### 四、實戰演示

以下展示WebClient的常見操作：

1. **GET請求示例**：
```java
webClient.get()
    .uri("/coffee/{id}", 1)
    .accept(MediaType.APPLICATION_JSON)
    .retrieve()
    .bodyToMono(Coffee.class)
    .subscribe(coffee -> System.out.println(coffee));
```

2. **POST請求示例**：
```java
Coffee newCoffee = new Coffee("美式咖啡");
webClient.post()
    .uri("/coffee")
    .bodyValue(newCoffee)
    .retrieve()
    .bodyToMono(Coffee.class)
    .subscribe(coffee -> System.out.println("Coffee created: " + coffee));
```

> 🛠️ **實作提示**：使用`bodyToMono()`處理單一響應，使用`bodyToFlux()`處理多個響應。

#### 五、課程小結與後續展望

1. **核心要點回顧**：
   - WebClient是非阻塞式的HTTP客戶端
   - 支援響應式程式設計範式
   - 提供豐富的API支援各種HTTP操作

2. **應用場景**：
   - 微服務間的通訊
   - 外部API整合
   - 高併發場景下的HTTP請求處理

#### 六、Tips

- 🎯 善用Builder模式進行WebClient配置
- ⚠️ 注意非阻塞操作的執行順序可能不同於程式碼順序
- 💡 使用`subscribe()`方法來觸發請求執行
- 🔍 錯誤處理建議使用`onStatus()`方法
- 🚀 大量請求時考慮使用連接池配置

---
### 57 | SpringBucks實戰項目進度小結  ― [customer-service]
#### 一、課程目標

本章節旨在讓學生深入理解如何在Spring微服務架構中，使用RestTemplate進行服務間的HTTP資源訪問，並掌握高效能連線池管理與自訂Keep-Alive策略的實作方法。透過實際的Customer Service專案範例，學生將學會如何完成咖啡訂單的查詢、建立與管理，並理解微服務間通訊的核心技術與最佳實踐。

學習重點包括：
- RestTemplate的基本用法與進階配置
- Apache HttpClient5連線池與Keep-Alive策略設定
- 微服務間HTTP請求的GET與POST操作流程
- 服務啟動與測試流程

實務意義在於提升微服務架構中服務間通訊的效能與穩定性，並降低開發與維護成本。

相關資源連結：
- Spring Boot官方文件：https://docs.spring.io/spring-boot/docs/current/reference/html/
- Apache HttpClient5官方文件：https://hc.apache.org/httpcomponents-client-5.3.x/index.html
- Spring RestTemplate官方文件：https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html
- Customer Service專案GitHub：https://github.com/SpringMicroservicesCourse/customer-service

#### 二、RestTemplate與HTTP資源訪問基礎

RestTemplate是Spring框架中用於同步HTTP請求的核心工具，能夠方便地發送GET、POST等HTTP方法，實現微服務間的資料交換。在本專案中，我們使用RestTemplate來訪問外部REST API，完成咖啡訂單的查詢與建立。

重點標籤：
- RestTemplate：Spring提供的HTTP客戶端工具
- GET請求：用於讀取資源，如取得咖啡菜單列表
- POST請求：用於建立資源，如建立新的咖啡訂單

比喻說明：RestTemplate就像是微服務間的郵差，負責將請求信件送達目標服務，並帶回回覆信件。

#### 三、Apache HttpClient5連線池與Keep-Alive策略

為了提升HTTP請求的效能與穩定性，我們在RestTemplate底層整合了Apache HttpClient5，並自訂連線池管理與Keep-Alive策略。

核心概念：
- 連線池（PoolingHttpClientConnectionManager）：管理多個HTTP連線，避免每次請求都重新建立連線，提升效率。
- Keep-Alive策略（CustomConnectionKeepAliveStrategy）：控制連線在空閒時的存活時間，減少頻繁斷線重連。

設定重點：
- 最大連線數設定為200，單一路由最大連線數20，確保高併發場景下的連線資源充足。
- 設定30秒閒置自動關閉連線，避免資源浪費。

這些設定確保微服務在高流量下仍能保持良好響應速度與穩定性。

#### 四、Customer Service專案實作流程解析

本專案示範了完整的服務間通訊流程，包含以下三個主要步驟：

1. **讀取咖啡菜單**  
   使用GET請求從web-service取得所有咖啡品項，並將結果列印出來。這是服務間資料讀取的典型範例。

2. **建立訂單**  
   透過POST請求，將新訂單資料（包含客戶姓名與咖啡品項）送至web-service，並接收回傳的訂單ID與狀態碼（201表示成功建立）。

3. **查詢訂單**  
   使用GET請求查詢特定訂單的詳細資訊，確認訂單狀態與內容。

這三個步驟串連起來，完整呈現微服務間的資料流與操作流程。

#### 五、專案架構與執行環境說明

專案採用Spring Boot 3.2.5作為核心框架，搭配Apache HttpClient5實現高效HTTP連線管理。開發工具包含Maven與Lombok，方便專案建置與簡化Java程式碼。

專案結構清晰，主要程式碼位於customer-service/src/main/java/tw/fengqing/spring/springbucks/customer/，包含model、support等模組，方便維護與擴充。

執行前需先啟動web-service服務（預設port 8080），確保Customer Service能正常訪問API。

快速啟動步驟：
- 克隆專案
- 編譯專案
- 執行Spring Boot應用

#### 六、課程小結與後續展望

本章節透過Customer Service專案，讓學生掌握了Spring微服務架構中服務間HTTP通訊的核心技術，包含RestTemplate的使用、HttpClient5連線池管理與Keep-Alive策略設定，以及完整的訂單操作流程。

兩種配置方式的差異與優缺點：
- **基本RestTemplate用法**：簡單易用，適合低流量場景，但缺乏連線管理，可能導致效能瓶頸。
- **整合HttpClient5連線池**：提升效能與穩定性，適合高併發環境，但配置較複雜，需要調整參數以符合實際流量。

透過本章學習，學生能建立完整的微服務間通訊概念，為後續多數據源配置與更複雜架構打下基礎。

下一章節將介紹多數據源配置，進一步擴展微服務架構的資料管理能力。

#### 七、Tips

- 在微服務間通訊中，務必設定合理的timeout，避免系統因等待過久而hang死。
- 重要程式區塊加上清楚註解，使用團隊熟悉的專業術語，有助於維護與協作。
- 連線池與Keep-Alive策略參數需根據實際流量調整，避免資源浪費或連線不足。
- 測試時確保相關服務已啟動，避免因服務未啟動導致連線失敗。
- 使用環境變數管理機敏資訊，提升系統安全性。

以上即為本章節的完整講義內容，方便講師授課與學生複習，並結合理論與實作，提升學習效果。

# Chapter 8：Web開發進階 (9講)
### 58 | 設計好的RESTful Web Service（上）

博士的論文
- 成熟度
- 如何設計步驟

---
### 59 | 設計好的RESTful Web Service（下）  ― []

- php 和 aspx 名稱避免攻擊，不過這樣並不是很有效

---
### 60 | 什麼是HATEOAS  ― []

---
### 61 | 使用Spring Data REST實現簡單的超媒體服務（上）  ― [hateoas-waiter-service]
#### 一、課程目標

本章節將帶領學生深入了解如何利用Spring Data REST與HATEOAS（超媒體應用語言）快速構建符合REST規範的微服務API。學生將學會：

- Spring Data REST如何自動生成RESTful API，減少重複程式碼。
- HATEOAS的核心概念及其在API導航中的應用。
- 如何設計實體類別與Repository，並透過超媒體連結實現資源的自描述。
- 分頁、搜尋與多格式（JSON/XML）支援的實作方式。
- 透過實戰範例掌握Spring微服務架構中Web服務的進階開發技巧。

同時，提供以下資源方便學生實際操作與練習：

- 專案範例倉庫：https://github.com/SpringMicroservicesCourse/hateoas-waiter-service
- Spring Data REST官方文件：https://docs.spring.io/spring-data/rest/docs/current/reference/html/
- HATEOAS規範說明：https://restfulapi.net/hateoas/
- Spring Boot官方指南：https://spring.io/guides

#### 二、Spring Data REST與HATEOAS基礎介紹

Spring Data REST是一個強大的框架，能根據JPA Repository自動生成RESTful API端點，讓開發者不必手動撰寫Controller，大幅提升開發效率。它遵循REST設計原則，並且內建支援HATEOAS，讓API回應中自動包含超媒體連結，幫助客戶端理解資源間的關係與操作方式。

HATEOAS（Hypertext As The Engine Of Application State）是一種REST架構風格的核心概念，強調API回應中應包含可導引後續操作的超連結。這些連結讓API不只是資料提供者，更像是有導航功能的應用，提升API的自描述性與可用性。

舉例來說，當我們查詢咖啡資源時，回應中不僅有咖啡的資料，還會包含指向該咖啡詳細資訊、更新、刪除等操作的連結，讓客戶端能依此進行後續請求。

#### 三、專案架構與核心技術說明

本專案是一個咖啡廳訂單管理系統，利用Spring Boot 3.2.5搭配Spring Data REST與HATEOAS實現。主要技術棧包括：

- Spring Data JPA：負責資料持久化，操作資料庫。
- Spring Data REST：自動生成REST API。
- Hibernate 6.4.4：ORM框架，管理實體與資料庫映射。
- Joda Money：處理貨幣類型，確保價格資訊的準確性。
- Jackson：負責JSON與XML序列化與反序列化。
- H2 Database：內嵌式資料庫，方便開發與測試。

專案結構清晰，包含實體類別（Coffee、CoffeeOrder）、Repository層、序列化支援類別，以及主應用程式配置。這樣的分層設計有助於維護與擴展。

#### 四、實體類別與Repository設計重點

- 實體類別Coffee代表咖啡品項，包含名稱與價格兩個主要欄位。價格使用Joda Money類型，並透過自訂轉換器MoneyConverter處理資料庫存取，確保貨幣資訊的正確性與多幣別支援。
- Repository介面CoffeeRepository繼承JpaRepository，並使用@RepositoryRestResource註解自訂API路徑為"/coffee"。此介面定義了兩個查詢方法：根據名稱列表查詢並排序，以及根據單一名稱查詢，這些方法會自動轉換成RESTful搜尋端點。
- 透過Spring Data REST，這些Repository會自動暴露為REST API，並且支援分頁、排序與搜尋功能，減少手動撰寫Controller的工作量。

#### 五、應用程式配置與API路徑管理

- 主應用程式類別WaiterServiceApplication中，透過@Bean註冊Hibernate6Module，解決延遲載入問題，避免序列化異常。
- 使用RepositoryRestConfigurer設定API基礎路徑為"/api"，並暴露實體ID欄位，方便前端識別資源。
- 這樣的配置讓API結構清晰且易於管理，符合企業級微服務架構的標準。

#### 六、API使用與實戰演示

- 啟動應用後，訪問`http://localhost:8080/api`即可看到所有可用資源的超媒體連結。
- 透過`/api/coffee`端點可取得咖啡列表，回應中包含每個咖啡的詳細資料與自動生成的超連結（self、search等）。
- 支援分頁查詢，例如`/api/coffee?page=0&size=3`取得前三筆資料，並可依ID排序。
- 搜尋功能透過`/api/coffee/search/findByName?name=latte`實現，方便根據名稱查找特定咖啡。
- API回應格式支援JSON與XML，滿足不同客戶端需求。
- 這些功能展示了Spring Data REST與HATEOAS如何協助快速構建功能完整且易於擴展的微服務API。

#### 七、課程小結與後續展望

本章節介紹了Spring Data REST與HATEOAS的核心概念與實作方法，透過自動化API生成與超媒體驅動，顯著提升微服務Web開發效率與API品質。學生應掌握：

- Spring Data REST如何根據JPA Repository自動生成REST端點。
- HATEOAS如何透過超連結實現API的自描述與導航。
- 分頁、搜尋與多格式支援的實務操作。
- 實體類別與Repository設計的最佳實踐。

接下來，我們將進一步探討多數據源配置，學習如何在Spring微服務架構中管理多個資料庫連線，提升系統的靈活性與擴展性。

#### 八、Tips

- 使用@RepositoryRestResource可自訂API路徑，讓URL更語意化且符合REST設計。
- 利用Spring Data REST的搜尋功能，避免手動撰寫複雜查詢Controller。
- HATEOAS的超媒體連結讓API更具自描述性，方便前端動態導航。
- 分頁與排序是處理大量資料時不可或缺的功能，務必熟悉其用法。
- 在生產環境中，建議搭配Spring Security加強API安全性。
- 使用Swagger/OpenAPI整合API文件，提升團隊協作效率。

這樣的講義結構與內容，能幫助學生系統性理解Spring微服務架構中Web服務的進階開發，並具備實務操作能力。

---
### 62 | 使用Spring Data REST實現簡單的超媒體服務(下)   ― [hateoas-customer-service]
#### 一、課程目標

本章節將帶領學生深入理解並實作Spring微服務架構中，如何利用Spring Data REST與Spring HATEOAS技術，打造符合REST標準的超媒體服務（HATEOAS）。學生將學會如何動態探索API資源連結，並透過程式碼實現資源的CRUD操作與關聯管理，進而掌握微服務間鬆耦合且動態互動的設計理念。

學習重點包括：
- HATEOAS的核心概念與優勢
- Spring Data REST自動生成REST端點的機制
- 使用Spring HATEOAS動態解析API連結
- RESTful資源的增刪查改操作實作
- 多對多關聯的標準管理方式（text/uri-list格式）
- 高效HTTP連線池配置與管理

實務意義在於幫助學生理解微服務架構中，如何設計與實作符合REST最高成熟度模型的API，提升系統擴展性與維護性。

推薦資源：
- Spring HATEOAS官方文件：https://spring.io/projects/spring-hateoas
- Spring Data REST參考指南：https://docs.spring.io/spring-data/rest/docs/current/reference/html/
- HAL規格說明：https://tools.ietf.org/html/draft-kelly-json-hal-08
- HttpClient 5.x文件：https://hc.apache.org/httpcomponents-client-5.2.x/

#### 二、HATEOAS與Spring Data REST基礎概念

HATEOAS（Hypermedia as the Engine of Application State）是REST架構中最高層級的成熟度模型，強調API回應中包含可動態探索的超連結，讓客戶端不需預先硬編碼所有端點，而是透過連結自動發現可用操作。

Spring Data REST結合Spring HATEOAS，能自動生成符合HAL格式的REST API，並在回應中附帶資源的相關連結（_links），方便客戶端動態操作。

這種設計帶來的好處是：
- **鬆耦合**：服務端可自由調整API結構，客戶端只需依賴連結關係
- **動態探索**：客戶端透過連結自動導航，減少硬編碼與錯誤
- **標準遵循**：符合REST最佳實踐，提升系統一致性與可維護性

#### 三、專案架構與技術棧介紹

本專案基於Spring Boot 3.2.5與Java 21，整合Spring Data REST與Spring HATEOAS，並使用Apache HttpClient 5.x實現高效HTTP連線池管理。

主要模組包括：
- **資料模型**：Coffee（咖啡）、CoffeeOrder（訂單）、OrderState（訂單狀態）
- **業務邏輯**：CustomerRunner負責執行API探索與操作流程
- **連線管理**：自訂連線池與KeepAlive策略，確保高效穩定的HTTP請求

專案結構清晰，方便擴展與維護。

#### 四、HATEOAS連結探索與資源操作實作

1. **動態取得API資源連結**

透過向API根端點發送GET請求，解析回應中的`_links`欄位，取得指定資源的URI。此處使用Map結構解析HAL格式，避免直接使用HATEOAS物件導致序列化問題。

範例程式碼說明：
- 向`http://localhost:8080/api`發送請求
- 從回應中取得`coffees`或`coffeeOrders`的連結
- 利用取得的連結進行後續操作

2. **CRUD操作示範**

- **新增咖啡**：向`coffees`連結發送POST請求，建立新咖啡資源
- **查詢咖啡列表**：GET請求取得分頁的咖啡資料
- **建立訂單**：向`coffeeOrders`連結POST新訂單
- **關聯咖啡與訂單**：使用`text/uri-list`格式，將咖啡URI關聯到訂單的items集合，符合Spring Data REST多對多關聯標準

3. **使用Postman或程式碼模擬操作**

示範如何透過Postman發送POST、GET、DELETE等請求，並觀察回應狀態碼與資源變化，幫助學生理解API互動流程。

#### 五、高效HTTP連線池配置

為了提升微服務間的通訊效能與穩定性，專案中使用Apache HttpClient 5.x配置連線池，並自訂KeepAlive策略。

重點配置包括：
- 最大連線數與單路由最大連線數設定，避免連線瓶頸
- 連線與回應超時設定，防止請求阻塞
- 閒置連線自動清理，減少資源浪費
- 禁用自動重試，避免重複請求導致資料不一致

這些設定確保在高併發環境下，HTTP請求能快速且穩定地完成。

#### 六、實戰演示

本章節提供一個完整的實戰範例：HATEOAS Customer Service。

演示流程：
- 啟動waiter-service服務（port 8080）
- 執行Customer Service應用程式
- 程式自動探索API根端點，取得coffees與coffeeOrders連結
- 查詢咖啡菜單，新增一杯美式咖啡
- 建立新訂單並將咖啡關聯至訂單項目
- 查詢並列出所有訂單與其關聯咖啡

同時示範如何使用Postman模擬相同操作，幫助學生理解API互動細節。

#### 七、課程小結與後續展望

本章節透過實作Spring Data REST與Spring HATEOAS，讓學生掌握了微服務架構中超媒體服務的設計與實踐。重點在於理解HATEOAS的動態連結探索機制，以及如何透過標準格式管理資源關聯，實現鬆耦合且擴展性高的微服務通訊。

後續章節將介紹多數據源配置，進一步擴展微服務架構的資料管理能力，銜接更複雜的實務需求。

#### 八、Tips

- **理解HATEOAS的核心價值**：API回應中包含操作連結，讓客戶端能動態導航，避免硬編碼端點。
- **使用Map解析HAL格式**：避免直接使用HATEOAS物件，減少序列化錯誤。
- **多對多關聯使用text/uri-list格式**：符合Spring Data REST官方標準，確保關聯操作正確。
- **HTTP連線池配置不可忽視**：適當設定連線數與超時，提升系統效能與穩定性。
- **實務中多用Postman測試API**：幫助理解請求與回應細節，快速定位問題。
- **詳細日誌記錄**：方便除錯與性能分析，尤其在分散式微服務環境中非常重要。

這份講義結構清晰，內容豐富，適合IT背景學生理解Spring微服務架構中HATEOAS的實作與應用，並能透過實戰範例加深印象，為後續更複雜的微服務設計打下堅實基礎。

---
### 63 | 分布式環境中如何解決Session的問題  ― [session-demo]
根據提供的內容，我幫你整理一份關於分散式環境中Session管理的教學講義：

#### 一、課程目標

本課程旨在幫助學生理解分散式環境中Session管理的挑戰與解決方案，特別聚焦於Spring Session的實現方式。

學習重點：
- 理解分散式環境中Session管理的問題
- 掌握三種主要的Session解決方案
- 學習使用Spring Session + Redis實現分散式Session管理

相關資源：
- Spring Session官方文件：https://spring.io/projects/spring-session
- Redis官方文件：https://redis.io/documentation

#### 二、分散式Session的三種解決方案

1. **Sticky Session（黏性會話）**
- 原理：通過負載均衡將來自同一用戶的請求都導向同一台伺服器
- 優點：實現簡單
- 缺點：伺服器故障時會導致Session丟失

2. **Session Replication（會話複製）**
- 原理：在所有伺服器之間複製Session資訊
- 優點：高可用性
- 缺點：
  - 複製成本高
  - 大量訪問時效能降低
  - Session一致性難以保證

3. **Centralized Session（集中式會話）** 🌟推薦方案
- 原理：使用Redis或資料庫集中存儲Session
- 優點：
  - 可靠性高
  - 易於擴展
  - 資料一致性好
- 實現方式：Spring Session + Redis

#### 三、Spring Session實現原理

核心機制：
- 通過封裝HTTP ServletRequest返回自定義的Session實現
- 使用SessionRepositoryFilter處理請求
- 支援多種後端存儲（Redis、JDBC等）

關鍵組件：
```java
@EnableRedisHttpSession  // 啟用Redis HTTP Session支援
public class SessionConfig {
    // Spring Session配置
}
```

#### 四、實戰演示

基本配置步驟：
1. 添加依賴：
```xml
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

2. 配置Redis連接：
```properties
spring.redis.host=localhost
spring.redis.port=6379
```

3. 示例代碼：
```java
@RequestMapping("/hello")
public String printSession(HttpSession session, String name) {
    String storedName = (String) session.getAttribute("name");
    if (storedName == null) {
        session.setAttribute("name", name);
        storedName = name;
    }
    return "hello " + storedName;
}
```

#### 五、課程小結與後續展望

總結：
- 分散式Session管理是微服務架構中的關鍵問題
- Spring Session提供了優雅的解決方案
- Redis作為Session存儲後端具有高性能和可靠性

後續主題：
- Session安全性管理
- Redis叢集配置
- 多數據源配置

#### Tips：

1. 生產環境建議：
- 配置Redis密碼
- 啟用Redis持久化
- 設置合適的Session超時時間

2. 常見問題處理：
- Session資料丟失：檢查Redis連接
- 效能問題：配置合適的連接池
- 安全性：確保Redis服務器安全配置

---
### 64 | 使用WebFlux代替Spring MVC（上）  ― []
---
### 65 | 使用WebFlux代替Spring MVC（下）  ― [webflux-waiter-service]
未完成

---
### 66 | SpringBucks實戰項目進度小結
---
# Chapter 9：重新認識Spring Boot (8講)
### 67 | 認識Spring Boot的組成部分
---
### 68 | 瞭解自動配置的實現原理
---
### 69 | 動手實現自己的自動配置  ― [autoconfigure-demo,geektime-spring-boot-autoconfigure,greeting]

未完成

---
### 70 | 如何在低版本Spring中快速實現類似自動配置的功能  ― [geektime-autoconfigure-backport]

未完成

---
### 71 | 瞭解起步依賴及其實現原理

---
### 72 | 定制自己的起步依賴  ― [geektime-spring-boot-starter]

未完成

---
### 73 | 深挖Spring Boot的配置加載機制  ― [property-source-demo]

未完成
# Chapter 10：運行中的Spring Boot (11講)
---
### 75 | 認識Spring Boot的各類Actuator Endpoint
---
### 76 | 動手定制自己的Health Indicator  ― [indicator-demo]
#### 一、課程目標

本章節將帶領學生深入了解Spring微服務架構中，如何利用Spring Boot Actuator實作健康檢查指標（Health Indicator）與效能監控。學生將學會自定義健康檢查邏輯，掌握監控應用程式運行狀況的核心技術，並能實際操作範例專案，提升微服務的穩定性與可維護性。

重點包括：
- 理解Spring Boot Actuator的健康檢查機制與自定義擴展
- 實作自訂的Health Indicator，監控業務關鍵指標（如咖啡庫存）
- 整合效能攔截器，追蹤API響應時間與效能瓶頸
- 配置與使用Actuator的監控端點，掌握應用狀態與資訊

推薦資源：
- Spring Boot Actuator官方文件：https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html
- Micrometer監控指標：https://micrometer.io/docs
- 專案範例代碼與說明：indicator-demo資料夾內的程式碼與README

#### 二、Spring Boot健康檢查指標概述

健康檢查是微服務架構中不可或缺的功能，用以監控服務的運行狀態，確保系統穩定。Spring Boot Actuator提供了豐富的健康檢查端點，並允許開發者自定義Health Indicator來反映特定業務狀況。

- **Health Indicator**：一個介面，負責回傳服務的健康狀態（UP、DOWN等）及詳細資訊。
- **自帶指標**：Spring Boot內建多種健康檢查，如資料庫連線、磁碟空間等。
- **自定義指標**：可根據業務需求，實作自訂的健康檢查邏輯，例如監控咖啡庫存。

比喻來說，健康檢查就像醫生定期檢查病人的生命跡象，確保系統「身體」健康，及早發現問題。

#### 三、自定義Health Indicator實作詳解

以專案中的`CoffeeIndicator`為例，展示如何實作自訂健康檢查：

- 透過`HealthIndicator`介面覆寫`health()`方法。
- 取得業務資料（如咖啡庫存數量）。
- 根據條件回傳健康狀態：
  - 庫存大於0，回傳`Health.up()`，並附帶庫存數量與訊息。
  - 庫存為0，回傳`Health.down()`，提示缺貨狀態。

程式碼範例：
```java
@Component
public class CoffeeIndicator implements HealthIndicator {
    @Autowired
    private CoffeeService coffeeService;

    @Override
    public Health health() {
        long count = coffeeService.getCoffeeCount();
        if (count > 0) {
            return Health.up()
                    .withDetail("count", count)
                    .withDetail("message", "We have enough coffee.")
                    .build();
        } else {
            return Health.down()
                    .withDetail("count", 0)
                    .withDetail("message", "We are out of coffee.")
                    .build();
        }
    }
}
```

重點標籤：自定義健康檢查、HealthIndicator介面、狀態回傳（UP/DOWN）、詳細資訊顯示

#### 四、健康檢查端點與詳細資訊設定

- **健康檢查端點URL**：`http://localhost:8080/actuator/health`
- 回傳JSON格式，包含整體健康狀態及各指標詳細資訊。
- 透過設定`management.endpoint.health.show-details=always`，可顯示所有健康指標的詳細狀態，方便診斷。

此外，`/actuator/info`端點提供應用程式的基本資訊，如作者、版本等，可自訂擴充。

這些端點是微服務監控的入口，能即時反映系統狀態，協助運維人員快速掌握服務健康。

#### 五、效能監控與攔截器設計

為了追蹤API的響應時間與效能瓶頸，專案中實作了`PerformanceInterceptor`：

- 利用Spring MVC的`HandlerInterceptor`介面。
- 在請求前啟動計時器，請求後停止並記錄耗時。
- 記錄請求URI、HTTP方法、狀態碼、異常資訊及耗時數據。
- 監控路徑包括`/coffee/**`與`/order/**`。

此設計有助於發現效能瓶頸，優化系統響應速度。

#### 六、專案結構與快速啟動

專案以Spring Boot 3.4.5為核心，結合Spring Data JPA、Spring Web MVC與Actuator，並使用H2內嵌資料庫方便開發測試。

主要目錄結構：
- controller：REST API控制器
- model：資料模型
- repository：資料存取層
- service：業務邏輯層
- support：自定義健康指標與資訊貢獻者

快速啟動步驟：
1. 克隆專案
2. 使用Maven編譯
3. 執行Spring Boot應用
4. 使用curl或瀏覽器訪問監控端點驗證

#### 七、實戰演示

本節將帶領學生動手實作並測試自定義健康指標：

- 實作`CoffeeIndicator`，監控咖啡庫存。
- 修改資料庫初始資料，模擬庫存充足與缺貨兩種狀態。
- 使用`curl`或瀏覽器訪問`/actuator/health`，觀察健康狀態變化。
- 配置`show-details=always`，查看詳細健康資訊。
- 透過日誌觀察`PerformanceInterceptor`記錄的API響應時間。

此演示幫助學生理解健康檢查的實際應用與效能監控的重要性。

#### 八、課程小結與後續展望

本章節重點在於掌握Spring Boot Actuator的健康檢查與效能監控機制，並實作自定義Health Indicator以反映業務狀態。透過實戰範例，學生能理解如何設計符合業務需求的健康檢查邏輯，並利用監控端點即時掌握系統狀況。

兩種配置方式比較：
- **內建指標**：快速且涵蓋常見系統狀態，適合基礎監控。
- **自定義指標**：靈活反映業務特性，提升監控精準度，但需額外開發與維護。

後續章節將介紹多數據源配置，進一步擴展微服務架構的資料管理能力，銜接更複雜的系統設計。

#### 九、Tips

- 健康檢查邏輯應貼近實際業務，避免僅檢查技術層面。
- 設定`show-details=always`有助於開發與測試，生產環境應注意資訊安全。
- 效能監控數據需定期分析，及早發現瓶頸與異常。
- 自定義Health Indicator可繼承Spring Boot內建類別，減少重複程式碼。
- 使用內嵌資料庫（如H2）方便快速開發與測試，但生產環境需替換為正式資料庫。

以上內容結合理論與實作，幫助學生建立完整的Spring微服務健康監控知識體系。

---
### 77 | 通過Micrometer獲取運行數據  ― [metrics-demo]
#### 一、課程目標

本章節旨在讓學生理解並掌握Spring微服務架構中，如何利用Spring Boot Actuator與Micrometer實現系統的健康檢查與度量指標監控。學生將學會自定義健康指標（Health Indicator），並透過實際範例了解如何監控系統內部資源狀態，如資料庫連線與磁碟空間，提升微服務的穩定性與可觀察性。

同時，課程將介紹一個基於Spring Boot 3.x的微服務監控示範專案，涵蓋從度量指標收集、健康檢查到效能監控的完整流程，幫助學生將理論與實務結合。

推薦資源：
- Spring Boot 官方文件：https://spring.io/projects/spring-boot
- Micrometer 官方文件：https://micrometer.io/
- Spring Boot Actuator 文件：https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html
- Prometheus 官方文件：https://prometheus.io/docs/

#### 二、Spring微服務監控與健康檢查概述

在微服務架構中，系統的穩定運行與即時監控至關重要。Spring Boot Actuator提供了豐富的監控端點，能夠自動收集系統健康狀態與各種度量指標。Micrometer作為度量指標的核心框架，支援多種監控系統（如Prometheus、Grafana），讓我們能夠從多維度掌握服務狀態。

健康檢查（Health Indicator）是判斷服務是否正常運作的關鍵機制。Spring Boot內建多種健康指標，如資料庫連線、磁碟空間等，但在實務中，我們常需要根據公司內部設施或特殊需求，自行定義健康指標。

#### 三、自定義Health Indicator的實作原理與範例

自定義Health Indicator的核心在於實作Spring提供的HealthIndicator介面，或繼承現有的指標類別，並覆寫檢查邏輯。這樣可以根據特定條件回傳健康狀態（UP、DOWN等）及詳細訊息。

以資料庫連線檢查為例，我們可以注入DataSource，透過執行簡單的查詢語句來判斷資料庫是否可用。若查詢成功，回傳UP狀態；若失敗，則回傳DOWN並附帶錯誤訊息。

另一個常見範例是磁碟空間檢查，透過檢測指定目錄的可用空間大小，判斷是否低於預設閾值，從而決定健康狀態。

實作步驟：
1. 實作HealthIndicator介面或繼承AbstractHealthIndicator。
2. 在checkHealth方法中撰寫檢查邏輯。
3. 使用Health.Builder設定狀態與訊息。
4. 將自定義指標註冊為Spring Bean。

這種方式讓我們能靈活擴展健康檢查，滿足不同系統需求。

#### 四、Spring Boot微服務監控系統示範專案介紹

本專案以咖啡廳訂單系統為例，展示如何整合Spring Boot Actuator與Micrometer來實現完整的監控體系。專案特色包括：

- 自動收集訂單數量、API響應時間等業務指標。
- 自定義健康檢查指標，確保系統穩定。
- 效能監控攔截器，記錄API呼叫詳細效能資料。
- 支援Prometheus與Grafana，實現多維度監控與視覺化。

專案結構清晰，涵蓋控制器、服務層、資料存取層與自定義指標實作，方便學生理解微服務架構中各層的監控責任。

快速啟動步驟：
- 安裝Java 21與Maven 3.8以上。
- 克隆專案並編譯執行。
- 透過`http://localhost:8080/actuator/health`與`/metrics`端點查看監控資料。

#### 五、實戰演示：自定義Health Indicator開發流程

1. 建立一個類別實作HealthIndicator介面，例如`CoffeeIndicator`。
2. 注入需要監控的資源，如DataSource。
3. 在`health()`方法中撰寫檢查邏輯，例如執行簡單SQL查詢確認資料庫連線。
4. 根據檢查結果回傳Health.up()或Health.down()，並附加詳細訊息。
5. 將此類別註冊為Spring Bean，Spring Boot Actuator會自動將其納入健康檢查報告。
6. 啟動應用後，透過`/actuator/health`端點查看自定義指標狀態。

此外，可設定`management.endpoint.health.show-details=always`，讓健康檢查回傳更詳細的訊息，方便排查問題。

透過此演示，學生能實際體驗如何擴展Spring Boot的健康檢查功能，並理解背後的設計理念。

#### 六、課程小結與後續展望

本章節重點在於掌握Spring Boot微服務架構中健康檢查與監控的核心技術，特別是自定義Health Indicator的實作方法。透過實務範例，學生了解如何根據系統需求設計健康檢查邏輯，並結合Micrometer與Actuator實現全面監控。

兩種配置方式比較：
- **內建指標**：快速且穩定，適合一般需求，但彈性有限。
- **自定義指標**：高度彈性，可針對特殊需求設計，但需額外開發與維護。

後續課程將介紹多數據源配置，幫助學生進一步理解複雜微服務架構中資料管理與監控的整合，銜接更高階的實務應用。

#### 七、Tips

- 健康檢查狀態建議使用UP、DOWN、UNKNOWN等標準狀態，方便監控系統識別。
- 自定義指標時，避免執行過於複雜或耗時的操作，以免影響系統效能。
- 使用`show-details=always`設定可在開發與測試階段提供詳細診斷資訊，生產環境則建議限制權限。
- 利用Micrometer的標籤（Tag）功能，實現多維度指標分析，提升監控精度。
- 整合Prometheus與Grafana，建立視覺化儀表板，提升監控的可讀性與即時反應能力。

這樣的教學結構能幫助學生從理論到實作，全面掌握Spring微服務架構中的監控與健康檢查技術。

---
### 78 | 通過Spring Boot Admin瞭解程序的運行狀態  ― [sba-client-demo,sba-server-demo]
#### 一、課程目標

本章節旨在讓學生理解並掌握如何利用Spring Boot Admin架構，實現Spring微服務應用的集中監控與管理。學生將學習Spring Boot Admin Server與Client的配置與運作原理，並了解如何透過安全機制保護監控端點，確保系統運行的安全與穩定。此外，課程將提供實務操作範例，幫助學生快速上手並應用於實際專案中。

相關資源連結：
- Spring Boot Admin官方文件：https://codecentric.github.io/spring-boot-admin/current/
- Spring Boot Actuator文件：https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html
- Spring Security參考手冊：https://docs.spring.io/spring-security/reference/

#### 二、Spring Boot Admin架構概述與核心概念

Spring Boot Admin是一套專為Spring Boot應用設計的集中監控管理平台，包含兩個主要組件：

- **Admin Server**：集中管理多個Spring Boot應用，提供統一的Web介面，展示應用狀態、健康檢查、指標數據等。
- **Admin Client**：嵌入於各個Spring Boot應用中，負責將應用狀態自動註冊並回報給Admin Server。

這種架構讓微服務系統的監控變得集中且標準化，方便運維人員即時掌握系統健康狀況。

重點標籤：集中監控、應用註冊、自動化管理、標準化監控端點

#### 三、Spring Boot Admin Server配置與安全設計

Admin Server負責提供監控管理介面，核心配置包括：

- 設定應用名稱與服務埠號（預設8080）
- 整合Spring Security，實現身份認證與授權，保護管理介面
- 配置HTTP安全規則，允許靜態資源與登入頁面匿名訪問，其他請求需認證
- 啟用CSRF保護，並針對特定端點（如註冊與Actuator端點）排除CSRF檢查，確保註冊流程順暢
- 支援多種通知方式（郵件、簡訊等），方便異常狀況即時告警

範例說明：透過SecurityFilterChain配置類別，設定登入頁面、登出URL及授權規則，確保管理介面安全且易用。

重點標籤：身份認證、授權控制、CSRF保護、通知整合

#### 四、Spring Boot Admin Client配置與運作機制

Admin Client嵌入於微服務應用中，主要功能包括：

- 啟動時自動向Admin Server註冊，實現自動發現
- 暴露完整的Spring Boot Actuator端點，提供健康狀態、指標、環境變數等監控資訊
- 整合Spring Security，保護監控端點，避免未授權訪問
- 支援元資料配置，將額外認證資訊傳遞給Admin Server，強化安全性
- 最小化配置即可整合現有Spring Boot應用，降低導入門檻

範例說明：在application.properties中設定應用名稱、服務埠號、Admin Server URL及認證資訊，並在主應用類別中使用@SpringBootApplication啟動。

重點標籤：自動註冊、Actuator端點、安全保護、元資料傳遞

#### 五、實戰演示：Spring Boot Admin Server與Client整合

實作步驟：

1. 分別克隆並啟動Spring Boot Admin Server與Client專案。
2. Server端設定管理介面認證帳密，並啟用Admin Server功能。
3. Client端配置連接Server的URL與認證資訊，暴露Actuator端點。
4. 啟動Client應用，確認自動註冊成功。
5. 透過瀏覽器登入Admin Server管理介面，查看Client應用的即時狀態、健康檢查、執行緒與記憶體使用等詳細資訊。
6. 演示如何透過管理介面新增自訂資訊，並觀察狀態變化。

此過程中強調安全配置的重要性，避免監控資料被未授權訪問。

重點標籤：自動註冊驗證、即時狀態監控、端點暴露、安全登入

#### 六、課程小結與後續展望

本章節介紹了Spring Boot Admin的Server與Client兩大組件，並詳細說明其配置、安全設計與運作流程。Server提供集中管理與安全保護，Client則負責應用狀態的自動註冊與監控資料回報。兩者結合實現了微服務架構下的統一監控平台。

優缺點比較：
- Server端集中管理，方便統一監控與告警，但需妥善配置安全與效能。
- Client端自動註冊與端點暴露簡化整合，但需注意安全認證與敏感資訊保護。

後續章節將介紹多數據源配置，進一步擴展Spring微服務架構的實務應用。

#### 七、Tips

- 監控端點暴露時，務必限制存取權限，避免敏感資訊外洩。
- 生產環境建議使用環境變數管理密碼，並啟用HTTPS保障傳輸安全。
- 監控資料收集頻率需合理設定，避免對應用效能造成負擔。
- 可擴展通知機制，結合郵件、簡訊或Slack，提升異常反應速度。
- 版本相容性重要，確保Admin Server與Client版本匹配，避免不必要的錯誤。

這樣的架構與實踐，能幫助學生建立完整的Spring微服務監控管理能力，為後續進階學習打下堅實基礎。

---
### 79 | 如何定制Web容器的運行參數  ― [tomcat-demo]
#### 一、課程目標

本章節旨在讓學生深入理解Spring Boot中微服務架構下的Web容器配置，特別是Tomcat容器的定制與優化技巧。學生將學會如何透過設定檔與程式碼兩種方式來調整Tomcat的壓縮功能、連線池等參數，並掌握API效能監控與錯誤處理的實務操作。這些技能對於提升微服務應用的效能與穩定性至關重要。

同時，課程將結合咖啡廳點餐系統的實作範例，幫助學生將理論與實務結合，快速上手Spring Boot微服務的開發與部署。

推薦資源：
- Spring Boot官方文件：https://spring.io/projects/spring-boot
- Tomcat容器配置說明：https://tomcat.apache.org/tomcat-10.0-doc/config/
- Joda Money使用指南：https://www.joda.org/joda-money/

#### 二、Spring Boot微服務架構中的Tomcat容器配置

在微服務架構中，Web容器是承載服務的基礎，Tomcat作為Spring Boot的預設容器，其配置直接影響服務的效能與穩定性。Tomcat容器的配置主要有兩種方式：

1. **透過設定檔(application.properties)配置**  
   這是最簡單且常用的方式，透過設定檔即可啟用壓縮功能、設定壓縮的最小響應大小等。例如：
   ```
   server.compression.enabled=true
   server.compression.min-response-size=512B
   ```
   這樣設定後，當響應大小超過512字節時，Tomcat會自動對回應內容進行gzip壓縮，減少網路傳輸量，提高響應速度。

2. **透過程式碼自訂配置**  
   當需要更細緻或動態的配置時，可以實作`WebServerFactoryCustomizer<TomcatServletWebServerFactory>`介面，並覆寫`customize`方法，程式碼示例如下：
   ```java
   @Override
   public void customize(TomcatServletWebServerFactory factory) {
       Compression compression = new Compression();
       compression.setEnabled(true);
       compression.setMinResponseSize(DataSize.ofBytes(512));
       factory.setCompression(compression);
   }
   ```
   這種方式靈活且可擴展，適合複雜場景下的容器調整。

#### 三、API效能監控與錯誤處理

為了確保微服務的穩定運行與快速響應，效能監控不可或缺。本專案中實作了自定義攔截器`PerformanceInterceptor`，用於記錄每個API請求的處理時間、狀態碼及異常資訊，方便後續分析與優化。

攔截器核心程式碼片段：
```java
@Slf4j
public class PerformanceInterceptor implements HandlerInterceptor {
    @Override
    public void afterCompletion(HttpServletRequest request, 
                                HttpServletResponse response, 
                                Object handler, 
                                Exception ex) throws Exception {
        log.info("{};{};{};{};{}ms", 
                 request.getRequestURI(), 
                 request.getMethod(), 
                 response.getStatus(), 
                 ex == null ? "-" : ex.getClass().getSimpleName(),
                 System.currentTimeMillis() - startTime);
    }
}
```
此攔截器能幫助開發者即時掌握API的效能瓶頸與錯誤狀況。

錯誤處理方面，建議在開發環境中開啟詳細的錯誤堆疊資訊（`server.error.include-stacktrace=always`），方便除錯；而在生產環境中則應關閉，以避免敏感資訊外洩，並提供友善的錯誤頁面。

#### 四、貨幣處理與資料庫整合

微服務中常涉及複雜的資料處理，專案中使用Joda Money來處理貨幣相關的操作，確保金額的精確與一致性。透過JPA的`AttributeConverter`，將Money物件轉換為資料庫可存取的長整數（以分為單位），示例如下：

```java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Long> {
    @Override
    public Long convertToDatabaseColumn(Money attribute) {
        return attribute == null ? null : attribute.getAmountMinorLong();
    }
}
```

這種轉換方式避免了浮點數計算誤差，提升資料庫操作的準確性。

#### 五、實戰演示

本專案以咖啡廳點餐系統為例，展示了Spring Boot微服務的完整開發流程：

- 克隆專案並使用Maven編譯與執行
- 透過RESTful API查詢咖啡資料，並測試壓縮功能
- 觀察API效能監控日誌，理解攔截器的運作
- 模擬錯誤情境，體驗錯誤處理機制
- 調整Tomcat容器配置，體會設定檔與程式碼配置的差異

這些實作讓學生能夠將理論知識轉化為實際技能。

#### 六、課程小結與後續展望

本章節重點在於掌握Spring Boot微服務架構中Tomcat容器的配置與優化，並結合效能監控與錯誤處理，提升服務品質。兩種配置方式各有優缺點：

- **設定檔配置**：簡單快速，適合大多數場景，但彈性較低。
- **程式碼配置**：靈活可擴展，適合複雜需求，但開發成本較高。

理解這些差異有助於學生根據實際需求選擇合適的方案。

接下來的章節將介紹多數據源配置，幫助學生進一步掌握微服務中資料庫的高級管理技巧，為複雜業務場景做好準備。

#### 七、Tips

- 在生產環境中，務必關閉詳細錯誤堆疊輸出，避免敏感資訊外洩。
- 壓縮功能可有效減少網路流量，但需根據響應大小調整`min-response-size`，避免過度壓縮帶來的CPU負擔。
- 自定義攔截器是監控API效能的利器，建議結合日誌系統與監控平台使用。
- 使用Joda Money處理貨幣，避免浮點數誤差，確保財務數據準確。
- 多利用Spring Boot官方文件與社群資源，持續學習與實踐。

這樣的講義結構與內容，能幫助學生系統性理解Spring微服務架構中Web容器的配置與優化，並具備實務操作能力。

---
### 80 | 如何配置容器支持HTTP：2（上）  ― [ssl-waiter-service,ssl-customer-service]

#### 課程目標

本章節將深入探討 Spring Boot 微服務間的 SSL 安全通信配置，透過實際的 waiter-service 和 customer-service 兩個服務的互動，讓學生掌握：

- **SSL 憑證管理**：使用 keytool 生成自簽憑證
- **Spring Boot SSL 配置**：服務端 HTTPS 設定
- **HttpClient5 客戶端配置**：支援 SSL 的 HTTP 客戶端設定
- **微服務安全通信**：服務間的安全數據交換

> **實務意義**：在生產環境中，微服務間的安全通信是基本要求，本章節的技術將直接應用於企業級微服務架構開發。

**相關資源**：
- [Spring Boot SSL 官方文檔](https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.ssl)
- [Apache HttpClient5 文檔](https://hc.apache.org/httpcomponents-client-5.2.x/)

#### 一、SSL 憑證基礎與生成

在微服務架構中，服務間的安全通信是確保數據完整性和機密性的關鍵。我們首先需要建立 SSL 憑證作為安全通信的基礎。

**keytool 憑證生成**
```bash
keytool -genkey -alias springbucks -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore springbucks.p12 -validity 365
```

> **重點**：PKCS12 格式是現代 Java 應用程式的標準憑證格式，支援密碼保護和私鑰存儲。

**憑證參數說明**：
- `-alias springbucks`：憑證別名，用於識別憑證
- `-storetype PKCS12`：使用 PKCS12 格式，相容性最佳
- `-keyalg RSA`：使用 RSA 演算法，安全性高
- `-keysize 2048`：2048 位金鑰長度，符合現代安全標準
- `-validity 365`：憑證有效期一年

#### 二、服務端 SSL 配置 (ssl-waiter-service)

服務端需要配置 HTTPS 來提供安全的 API 端點。我們將 waiter-service 配置為 SSL 服務端。

**application.properties 配置**
```properties
server.port=8443
server.ssl.key-store=classpath:springbucks.p12
server.ssl.key-store-password=spring
server.ssl.key-store-type=PKCS12
```

> **重點**：Spring Boot 自動配置會根據這些屬性設定內嵌的 Tomcat 伺服器支援 SSL。

**Spring Boot 3.x 升級要點**：
- 包名從 `javax.persistence` 升級到 `jakarta.persistence`
- `Hibernate5Module` 升級為 `Hibernate6Module`
- 時區設定為 `Asia/Taipei` 符合台灣環境

**Maven 依賴管理最佳實踐**：
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.joda</groupId>
            <artifactId>joda-money</artifactId>
            <version>${joda-money.version}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

> **重點**：使用 `dependencyManagement` 統一管理版本，避免版本衝突。

#### 三、客戶端 SSL 配置 (ssl-customer-service)

客戶端需要配置 HttpClient5 來支援 SSL 通信，這是本章節的核心技術重點。

**HttpClient5 與 HttpClient4 的差異**：
- 包名從 `org.apache.http` 改為 `org.apache.hc.client5.http`
- API 設計更加現代化，支援更好的連接管理
- SSL 配置方式有所改變

**SSL 配置核心代碼**：
```java
// 載入 p12 憑證
SSLContext sslContext = org.apache.hc.core5.ssl.SSLContextBuilder.create()
    .loadTrustMaterial(keyStore.getURL(), keyPass.toCharArray())
    .build();

// 配置連接管理器
PoolingHttpClientConnectionManager connectionManager = 
    PoolingHttpClientConnectionManagerBuilder.create()
        .setSSLSocketFactory(
            SSLConnectionSocketFactoryBuilder.create()
                .setSslContext(sslContext)
                .setHostnameVerifier(NoopHostnameVerifier.INSTANCE)
                .build()
        )
        .build();
```

> **重點**：`NoopHostnameVerifier.INSTANCE` 用於忽略主機名驗證，適用於自簽憑證的開發環境。

**主機名驗證問題解決**：
```
Certificate for <localhost> doesn't match common name of the certificate subject: fengqing
```

這個錯誤是因為憑證的 Common Name (CN) 與連接的主機名不匹配，使用 `NoopHostnameVerifier` 可以解決此問題。

#### 四、JSON 序列化與反序列化配置

微服務間需要交換複雜的數據結構，特別是貨幣類型的處理。

**Money 類型序列化問題**：
```java
@JsonDeserialize(using = MoneyDeserializer.class)
private Money price;
```

> **重點**：在 Spring Boot 3.x 中，需要明確指定反序列化器，因為 Jackson 版本的行為有所改變。

**MoneyDeserializer 實現**：
```java
@Override
public Money deserialize(JsonParser p, DeserializationContext ctxt) 
    throws IOException, JsonProcessingException {
    return Money.of(CurrencyUnit.of("CNY"), p.getDecimalValue());
}
```

#### 五、實戰演示

讓我們實際運行這兩個服務來驗證 SSL 通信的完整性。

**1. 啟動 waiter-service**
```bash
cd ssl-waiter-service
mvn spring-boot:run
```

**2. 測試 waiter-service SSL 端點**
```bash
curl -k -v https://localhost:8443/coffee/1
```

> **重點**：`-k` 參數忽略憑證驗證，`-v` 顯示詳細的 SSL 握手過程。

**3. 啟動 customer-service**
```bash
cd ssl-customer-service
java -jar target/customer-service-0.0.1-SNAPSHOT.jar
```

**4. 驗證結果**
```
Coffee: Coffee(id=1, name=espresso, price=CNY 100.00, ...)
Order Request Status Code: 201 CREATED
Order ID: 1
```

> **重點**：成功顯示表示 SSL 通信完全正常，包括憑證驗證、數據序列化和服務間調用。

#### 六、課程小結與後續展望

**技術要點總結**：

1. **SSL 憑證管理**：使用 keytool 生成 PKCS12 格式憑證
2. **服務端配置**：Spring Boot 自動配置 SSL 支援
3. **客戶端配置**：HttpClient5 的 SSL 配置與主機名驗證
4. **數據序列化**：複雜類型的 JSON 序列化處理
5. **版本升級**：Spring Boot 2.x 到 3.x 的遷移要點

**兩種配置方式的比較**：

| 項目 | 傳統配置 | Spring Boot 自動配置 |
|------|----------|---------------------|
| **複雜度** | 高，需要手動配置 | 低，自動化程度高 |
| **靈活性** | 高，可完全自定義 | 中等，遵循約定 |
| **維護性** | 低，配置分散 | 高，集中管理 |
| **學習曲線** | 陡峭 | 平緩 |

**後續學習方向**：
- 多數據源配置與管理
- 微服務監控與健康檢查
- 服務發現與負載均衡
- 分散式事務處理

#### 七、Tips

**開發環境最佳實踐**：
1. 使用自簽憑證時，記得配置 `NoopHostnameVerifier`
2. 生產環境應使用 CA 簽發的憑證
3. 定期更新憑證，避免過期問題

**常見問題解決**：
1. **憑證載入失敗**：檢查 p12 檔案路徑和密碼
2. **主機名驗證錯誤**：使用 `NoopHostnameVerifier` 或配置正確的主機名
3. **JSON 反序列化錯誤**：明確指定 `@JsonDeserialize` 註解

**效能優化建議**：
1. 使用連接池管理 HTTP 連接
2. 配置適當的超時時間
3. 啟用連接重用策略

> **重點**：本章節的技術是微服務安全通信的基礎，掌握這些技能將為後續的企業級微服務開發奠定堅實基礎。

---
### 81 | 如何配置容器支持HTTP/2（下） ― [http2-waiter-service,http2-customer-service]
我來為您製作一份關於 HTTP/2 與 Spring Boot 微服務架構的教學講義，基於我們剛才的實作經驗。
#### 一、課程目標

**學習重點**
- 理解 HTTP/2 協議在微服務架構中的重要性
- 掌握 Spring Boot 中 HTTP/2 的配置與實作
- 學習 SSL/TLS 安全連接的建立與管理
- 實作客戶端與服務端的 HTTP/2 通信

**實務意義**
> [!IMPORTANT] HTTP/2 是現代微服務架構的關鍵技術，提供更高效的網絡通信、更好的並發處理能力，以及更低的延遲，特別適合微服務間的頻繁通信需求。

**相關資源**
- Spring Boot 官方文檔：HTTP/2 配置指南
- 實作程式碼：`http2-waiter-service` 與 `http2-customer-service`
- 測試工具：curl、Postman 等 HTTP 客戶端

#### 二、HTTP/2 協議基礎

**協議演進**
HTTP/2 是 HTTP 協議的重大升級，主要改進包括：
- **多路復用**：單一連接可處理多個請求
- **伺服器推送**：主動向客戶端推送資源
- **頭部壓縮**：減少網絡傳輸量
- **二進制協議**：提高解析效率

> [!NOTE] 在微服務架構中，服務間通信頻繁，HTTP/2 的多路復用特性能顯著提升整體性能。

**Spring Boot 支援**
Spring Boot 3.x 原生支援 HTTP/2，配置方式：
```properties
server.http2.enabled=true
server.port=8443
server.ssl.key-store=classpath:springbucks.p12
server.ssl.key-store-type=PKCS12
server.ssl.key-store-password=spring
```

#### 三、Maven 依賴管理最佳實踐

**版本統一管理**
> [!IMPORTANT] 在微服務專案中，統一的依賴管理是確保服務穩定性的關鍵。

**最佳實踐結構**
```xml
<properties>
    <!-- 自定義依賴版本管理 -->
    <joda-money.version>2.0.2</joda-money.version>
    <commons-lang3.version>3.17.0</commons-lang3.version>
</properties>

<dependencyManagement>
    <dependencies>
        <!-- 自定義版本依賴定義 -->
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- 移除版本指定，使用 dependencyManagement -->
</dependencies>
```

**實作要點**
- 將所有版本定義移到 `dependencyManagement`
- 移除 `dependencies` 中的版本標籤
- 使用 `properties` 變數統一管理版本
- 添加清楚註解說明版本覆蓋原因

#### 四、實戰演示

**服務端配置 (Waiter Service)**
```java
@SpringBootApplication
@EnableJpaRepositories
@EnableCaching
public class WaiterServiceApplication implements WebMvcConfigurer {
    
    @Bean
    public Hibernate6Module hibernate6Module() {
        return new Hibernate6Module();
    }
    
    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jacksonBuilderCustomizer() {
        return builder -> {
            builder.indentOutput(true);
            builder.timeZone(TimeZone.getTimeZone("Asia/Shanghai"));
        };
    }
}
```

**客戶端配置 (Customer Service)**
```java
@Bean
public ClientHttpRequestFactory requestFactory() {
    OkHttpClient okHttpClient = new OkHttpClient.Builder()
        .sslSocketFactory(sslContext.getSocketFactory(), 
                         (X509TrustManager) tmf.getTrustManagers()[0])
        .hostnameVerifier((hostname, session) -> true)
        .build();
    return new OkHttp3ClientHttpRequestFactory(okHttpClient);
}
```

**測試驗證**
```bash
# HTTP/2 協議測試
curl -k -I https://localhost:8443/coffee/1

# 完整回應測試
curl -k -v https://localhost:8443/coffee/1
```

> [!TIP] 使用 `-k` 參數忽略自簽憑證驗證，`-v` 參數查看詳細的 HTTP/2 協議資訊。

#### 五、關鍵技術要點

**SSL/TLS 配置**
- 使用 PKCS12 格式的憑證檔案
- 配置信任管理器處理自簽憑證
- 支援 TLS 1.3 協議

**HTTP/2 協議特徵**
```
ALPN: server accepted h2
[HTTP/2] [1] OPENED stream
SSL connection using TLSv1.3
```

**JSON 序列化優化**
- 使用 `Hibernate6Module` 處理 JPA 實體
- 自定義 `Money` 類型的序列化器
- 配置時區為亞洲/上海

#### 六、課程小結與後續展望

**配置方式總結**

| 配置方式 | 優點 | 缺點 |
|---------|------|------|
| HTTP/2 + SSL | 安全性高、性能優 | 配置複雜 |
| HTTP/1.1 | 配置簡單 | 性能較差 |

**實務應用場景**
- 微服務間的高頻通信
- 需要低延遲的 API 調用
- 大量並發請求處理

**後續學習方向**
- 多數據源配置與管理
- 服務發現與負載均衡
- 監控與可觀測性
- 容器化部署與 Kubernetes

#### 七、Tips

> [!TIP] **開發環境配置**
> - 使用自簽憑證進行開發測試
> - 生產環境必須使用正式的 SSL 憑證
> - 定期更新依賴版本以修復安全漏洞

> [!TIP] **性能優化**
> - 啟用 HTTP/2 伺服器推送
> - 配置適當的連接池大小
> - 監控 HTTP/2 流的使用情況

> [!TIP] **故障排除**
> - 檢查 SSL 憑證配置
> - 驗證 HTTP/2 協議支援
> - 查看詳細的 curl 輸出資訊

> [!TIP] **最佳實踐**
> - 統一管理 Maven 依賴版本
> - 使用中文註解提高團隊協作效率
> - 建立完整的測試覆蓋率

這份講義涵蓋了 HTTP/2 微服務架構的核心概念、實作技巧和最佳實踐，適合 IT 背景的學生深入學習 Spring Boot 微服務開發。

---
###   82 | 如何編寫命令行運行的程序 ― [command-line-demo]
#### 一、課程目標

本章節旨在讓學生理解如何使用Spring Boot開發非Web類型的命令行應用程式，掌握Spring Boot在命令行環境下的生命週期管理與執行流程。學生將學會如何關閉Web功能、使用CommandLineRunner與ApplicationRunner執行初始化邏輯、控制執行順序，以及設定應用程式退出碼。這些技能對於微服務架構中需要背景任務或批次處理的服務開發非常實用。

相關資源：
- Spring Boot官方文件：https://spring.io/projects/spring-boot
- CommandLineRunner說明：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.command-line-runner
- ApplicationRunner說明：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-runner
- Exit Code管理：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.exit-code

#### 二、Spring Boot命令行應用程式概述

Spring Boot不僅適合開發Web應用，也能用於命令行工具或背景服務。透過設定`WebApplicationType.NONE`，可以關閉內建的Web伺服器，專注於命令行操作。這種設計適合需要快速啟動且不依賴HTTP介面的微服務組件。

專案示範中，主程式入口使用`SpringApplicationBuilder`設定`web(WebApplicationType.NONE)`，確保不啟動Web環境。這是命令行應用的基礎設定。

#### 三、Runner組件與執行順序控制

Spring Boot提供兩種Runner介面用於啟動後執行程式碼：

- **CommandLineRunner**：接收原始字串陣列參數，適合直接處理命令列輸入。
- **ApplicationRunner**：接收解析後的`ApplicationArguments`，方便參數管理。

兩者功能相似，差異在於參數處理方式。專案中示範了`FooCommandLineRunner`與`BarApplicationRunner`，分別實作這兩個介面，並透過`@Order`註解控制執行順序，數字越小越先執行。

這種設計讓複雜的初始化邏輯可以拆分成多個Runner，依序執行，提升程式結構清晰度與維護性。

#### 四、退出碼管理與應用程式結束流程

在Linux或類Unix系統中，程式結束時會回傳退出碼，0代表正常結束，非0代表異常。Spring Boot透過實作`ExitCodeGenerator`介面，讓開發者自訂退出碼。

專案中`MyExitCodeGenerator`固定回傳1，表示異常結束。`ExitApplicationRunner`則在最後執行，取得Spring應用上下文，呼叫`SpringApplication.exit()`取得退出碼，並用`System.exit()`終止程式。

這樣的設計確保命令行應用能正確反映執行狀態，方便外部系統判斷任務是否成功。

#### 五、實戰演示

1. 克隆專案並進入目錄：
```
git clone <repository-url>
cd command-line-demo
```

2. 編譯專案：
```
mvn clean compile
```

3. 執行應用程式：
```
mvn package -DskipTests
java -jar target/command-line-0.0.1-SNAPSHOT.jar
```

執行結果會依序輸出：
- Foo（CommandLineRunner）
- Bar（ApplicationRunner）
- Exit with 1（退出碼）

此流程展示了Runner的執行順序與退出碼管理。

#### 六、課程小結與後續展望

本章節介紹了Spring Boot命令行應用的核心概念，包括關閉Web功能、Runner介面使用、執行順序控制與退出碼管理。這些技術讓我們能夠開發輕量且專注於命令行任務的微服務組件。

兩種Runner介面功能相似，選擇依需求而定；退出碼管理則是確保應用程式能正確反映執行狀態的關鍵。

下一章節將帶領大家學習多數據源配置，進一步提升微服務架構的靈活性與擴展性。

#### 七、Tips

- 使用`@Order`註解控制Runner執行順序，避免初始化衝突。
- 退出碼非0代表異常，務必根據業務邏輯設定合理退出碼。
- 在Runner中妥善處理異常，避免程式異常終止。
- 使用`application.properties`或環境變數管理配置，方便不同環境切換。
- 透過`ApplicationContextAware`取得應用上下文，方便操作Spring容器資源。
---
### 83 | 瞭解可執行Jar背後的秘密  ― [jar-demo]
#### 一、課程目標

本章節旨在讓學生深入理解Spring Boot可執行JAR包的內部結構與運作原理，掌握如何將Spring微服務應用打包成可直接執行的JAR，並學會如何配置與部署這類應用。透過實際範例「Waiter Service」專案，學生將了解微服務架構中應用打包、啟動與監控的實務操作，為後續微服務開發與部署打下堅實基礎。

同時，提供官方文件與專案資源連結，方便學生實際操作與深入學習。

相關資源：
- Spring Boot官方文件（可執行JAR章節）：https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html
- 專案GitHub倉庫（Waiter Service範例）：https://github.com/username/jar-demo.git

#### 二、Spring Boot可執行JAR包結構與原理解析

Spring Boot的可執行JAR包是一種將應用程式及其所有依賴打包成單一檔案的技術，方便部署與執行。這種JAR包內部包含以下幾個主要部分：

- **Manifest檔案**：JAR的清單檔，指定了啟動類（Main-Class）和其他元數據，確保JVM能找到應用入口。
- **Spring Boot Loader**：一組特殊的類和資源，負責在啟動時載入JAR內的類與依賴，實現自解壓與類載入功能。
- **應用程式的class檔案**：編譯後的Java類與資源，放置於`BOOT-INF/classes/`目錄下。
- **依賴的JAR包**：所有第三方依賴被打包在`BOOT-INF/lib/`目錄中。

這種結構使得JAR包能夠像一個獨立的可執行檔案，直接透過`java -jar`命令啟動，而不需額外解壓或配置。

值得注意的是，這個JAR包本身不包含JDK或JRE，執行時仍需系統安裝Java環境。

#### 三、可執行JAR包的啟動流程與配置

Spring Boot可執行JAR的啟動是透過Manifest中指定的`Main-Class`來觸發Spring Boot Loader，Loader會尋找並執行註冊了`@SpringBootApplication`的啟動類（例如`WaiterServiceApplication`）。

此外，Spring Boot支援在同名的`.conf`設定檔中配置啟動參數，例如JVM參數、Spring Profile等，方便在不同環境下調整應用行為。

實務中，這類JAR包也可被包裝成系統服務（如systemd服務），實現開機自動啟動與管理。

#### 四、Waiter Service專案實戰介紹

本專案是一個基於Spring Boot 3.4.5的咖啡館服務系統，涵蓋咖啡品項管理、訂單處理、效能監控等功能，並完整展示可執行JAR包的打包與部署。

專案技術棧包括Spring Data JPA、Spring Cache、Spring Boot Actuator等，並使用H2資料庫作為示範。

專案結構清晰，分層明確，包含Controller、Service、Repository等模組，方便學生理解微服務架構的分層設計。

專案提供多種啟動方式：
- `java -jar`命令直接執行
- 直接執行設定為executable的JAR檔
- Maven插件啟動

並且示範如何使用設定檔與環境變數調整啟動參數，及如何將應用部署為系統服務。

#### 五、實戰演示：從打包到部署

1. 使用Maven指令`mvn clean package -DskipTests`打包專案，生成可執行JAR。
2. 使用解壓工具（如7-Zip）檢視JAR包內容，理解其內部結構。
3. 編輯`waiter-service.conf`設定檔，配置JVM參數與Spring Profile。
4. 透過`java -jar`或直接執行JAR檔啟動應用，並使用`ps aux | grep java`確認程序運行。
5. 示範如何將JAR包與設定檔複製到系統目錄，並建立systemd服務檔案，實現服務化管理。
6. 使用`systemctl`指令啟動、停止與檢查服務狀態。

透過這些步驟，學生能夠完整體驗Spring Boot微服務應用的打包、配置與部署流程。

#### 六、課程小結與後續展望

本章節重點在於理解Spring Boot可執行JAR包的結構與啟動機制，掌握如何將微服務應用打包成獨立可執行檔，並學會基本的部署與服務化管理技巧。

兩種主要的啟動方式（`java -jar`與直接執行executable JAR）各有優缺點：
- `java -jar`方式靈活，適合開發與測試環境。
- 直接執行方式方便系統服務化，但需注意檔案權限與環境配置。

後續課程將深入介紹多數據源配置，幫助學生進一步掌握複雜微服務架構中資料庫管理的實務技巧。

#### 七、Tips

- **理解Manifest與Loader的角色**：Manifest指定入口類，Loader負責類載入，這是可執行JAR的核心機制。
- **配置檔與環境變數分工**：環境變數用於設定JVM與Spring Profile，配置檔用於應用內參數，兩者配合使用更靈活。
- **服務化部署注意安全性**：建議使用專用系統用戶執行服務，並設定適當檔案權限。
- **監控與日誌管理不可忽視**：利用Spring Boot Actuator監控應用健康狀態，並設定日誌輪轉避免磁碟空間耗盡。
- **多嘗試官方文件與範例**：官方文件提供詳細參數與配置說明，實際操作能加深理解。

這樣的講義結構與內容，能幫助學生系統掌握Spring微服務架構中可執行JAR包的核心知識，並具備實務操作能力。

---
### 84 | 如何將Spring Boot應用打包成Docker鏡像文件  ― [docker-demo]
#### 一、課程目標

本章節將帶領學生了解如何將Spring Boot微服務應用程式打包成Docker鏡像，並透過容器化技術實現快速部署與跨平台運行。學生將學會Docker鏡像的基本概念、Dockerfile的撰寫技巧，以及如何結合Maven插件自動化建置流程。實務上，這能大幅提升微服務的部署效率與環境一致性，對於現代微服務架構的持續交付與運維至關重要。

相關資源連結：
- Spring Boot官方文件：https://spring.io/projects/spring-boot
- Docker官方文件：https://docs.docker.com/
- Dockerfile Maven Plugin：https://github.com/spotify/dockerfile-maven
- 專案範例倉庫（docker-demo）：本章節示範專案

#### 二、Docker鏡像與容器基礎概念

首先，理解Docker鏡像是本章的基礎。Docker鏡像是一個靜態的模板，包含了構建容器所需的所有指令與檔案。它是不可變的，且採用分層結構，允許鏡像基於其他鏡像進行增量構建。這種分層設計類似於疊積木，讓我們能重複利用基礎鏡像，節省空間與時間。

Docker容器則是鏡像的運行實例，類似於一個輕量級的虛擬機，但啟動速度更快，資源消耗更低。透過Dockerfile，我們可以定義鏡像的建置流程，包括基礎鏡像、工作目錄、複製檔案、暴露端口、啟動命令等。

#### 三、Spring Boot應用的Docker化實作

本專案示範了一個基於Spring Boot的咖啡廳微服務系統，並展示如何將其打包成Docker鏡像。核心技術棧包括Spring Boot 3.4.5、Spring Data JPA、Spring Boot Actuator、Hibernate 6，以及輕量級的H2資料庫。

Dockerfile範例如下：
- 使用OpenJDK 21作為基礎鏡像
- 設定工作目錄為/app
- 複製編譯好的JAR檔案到容器中
- 暴露8080端口
- 以java -jar啟動應用程式

這樣的設定確保了容器內的環境與應用程式一致，方便跨平台部署。

#### 四、Maven與Docker整合自動化建置

為了簡化Docker鏡像的建置流程，專案中使用了Dockerfile Maven Plugin。這個插件能讓我們直接透過Maven指令完成鏡像的建置與標籤管理，無需手動執行Docker命令。

配置中，我們指定了鏡像的Repository前綴、版本號等參數，並結合Dockerfile定義的建置步驟。執行`mvn clean package`後，插件會自動根據Dockerfile生成鏡像，並可透過`docker images`指令確認建置結果。

這種方式大幅提升CI/CD流程的自動化與穩定性。

#### 五、容器運行與應用驗證

建置完成後，我們可以使用Docker命令啟動容器，並將容器的8080端口映射到本機。透過curl指令或瀏覽器訪問`http://localhost:8080/actuator/health`，即可檢查應用程式的健康狀態。

此外，透過REST API端點如`/coffee/1`，可以驗證微服務的功能是否正常。這種快速驗證方式有助於開發與測試階段的效率提升。

#### 六、課程小結與後續展望

本章節重點在於掌握Spring Boot微服務應用的Docker化流程，從鏡像概念、Dockerfile撰寫，到Maven插件自動化建置與容器運行驗證，形成一套完整的容器化部署實務。

兩種主要配置方式比較：
- 手動Docker命令建置：靈活但繁瑣，適合小型專案或臨時測試。
- Maven插件自動化建置：流程標準化，適合持續整合與大型專案。

後續章節將介紹多數據源配置，進一步深化微服務架構的資料管理能力，敬請期待。

#### 七、Tips

- **環境一致性**是容器化的最大優勢，確保開發、測試、生產環境無差異。
- Docker鏡像分層設計類似疊積木，善用基礎鏡像可節省建置時間與空間。
- Maven與Docker整合插件能大幅簡化建置流程，推薦在CI/CD中使用。
- 運行容器時，注意端口映射與資源配置，避免衝突與資源不足。
- 常見問題如建置失敗或容器啟動異常，先檢查日誌與端口狀態，並確認插件版本相容性。

這樣的教學架構能幫助學生從理論到實作，全面掌握Spring微服務的Docker化部署技巧。

---
### 85 | SpringBucks實戰項目進度小結
#### 一、課程目標

本章節主要聚焦於Spring微服務架構中的監控與網路通訊配置，讓學生理解如何利用Spring Boot與相關工具實現微服務的健康監控、HTTP/HTTPS及HTTP2的支持，以及命令行程序的開發與應用。透過實務操作，學生將能掌握微服務的監控指標設計、網路安全配置與服務打包部署的核心技術。

重點標籤：#微服務監控 #HTTP2支持 #命令行程序 #Docker打包 #SpringBoot實作

推薦資源：
- Spring Boot官方文檔：https://spring.io/projects/spring-boot
- Micrometer監控框架介紹：https://micrometer.io/
- Docker官方教學：https://docs.docker.com/get-started/
- HTTPS與HTTP2基礎知識：https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Overview

#### 二、監控與指標設計

在微服務架構中，監控是確保系統穩定運行的關鍵。課程中介紹了如何利用Micrometer框架來設計自訂的監控指標（Metrics），例如在SpringBucks專案中，針對Coffee數量設置健康狀態判斷指標，當數量大於0表示服務健康，等於0則表示不健康。這種指標設計有助於快速判斷服務狀態，並及時響應異常。

此外，課程提到不建議直接使用Spring Boot Actuator的內建Name作為生產環境監控指標，建議整合專業的監控系統如Prometheus，以達到更完善的運維管理。

重點標籤：#Micrometer #自訂監控指標 #服務健康判斷 #Prometheus整合

#### 三、HTTP/HTTPS與HTTP2配置

網路通訊是微服務間互動的基礎，課程詳細說明了如何在Spring Boot中配置Web服務以支持HTTPS與HTTP2。透過調整最大連接數、顯示數等參數，提升服務的性能與安全性。

特別演示了如何生成自簽發證書，讓學生理解HTTPS的基本原理與實作流程。並且介紹了HTTP2的優勢，如多路復用與頭部壓縮，提升通訊效率。課程也鼓勵學生進一步探索HTTP3相關技術，保持對最新網路協議的敏感度。

重點標籤：#HTTPS配置 #HTTP2支持 #自簽發證書 #網路安全 #性能優化

#### 四、命令行程序開發與服務打包

微服務架構中，命令行工具常用於管理與部署。課程中回顧了如何開發命令行程序，並詳細說明了包的運行順序與配置，確保服務啟動流程的正確性。

此外，介紹了將應用程序打包成Docker映像的流程，這是現代微服務部署的標準做法。透過Docker容器化，服務能夠在不同環境中保持一致性與可移植性，方便持續集成與交付。

重點標籤：#命令行程序 #包運行順序 #Docker打包 #容器化部署

#### 五、實戰演示

本章節的實戰演示涵蓋了以下內容：

- 利用Micrometer設計並實現自訂監控指標，監控Coffee數量與訂單計數。
- 配置Spring Boot Web服務支持HTTPS與HTTP2，並生成自簽發證書。
- 使用HTTP客戶端訪問自訂的Pulse Endpoint，理解HTTP通訊流程。
- 開發命令行程序，設定包的運行順序，確保服務啟動流程。
- 將應用程序打包成Docker映像，實現容器化部署。

這些演示幫助學生將理論知識轉化為實際操作能力，提升對微服務架構的理解與應用。

#### 六、課程小結與後續展望

本章節透過監控指標設計與網路通訊配置，讓學生掌握了微服務健康狀態監控與安全高效通訊的核心技術。兩種配置方式（監控指標與HTTP配置）各有優缺點：監控指標能即時反映服務狀態，但需與專業監控系統整合；HTTP2提升性能，但配置較複雜且需考慮兼容性。

接下來的課程將聚焦於多數據源配置，幫助學生理解如何在微服務中管理多個資料庫連接，進一步提升系統的靈活性與擴展性。

重點標籤：#監控與HTTP配置比較 #多數據源配置預告

#### 七、Tips

- 在生產環境中，建議使用專業監控系統（如Prometheus）整合Micrometer指標，避免直接依賴Spring Boot Actuator的內建指標名稱。
- HTTPS配置中，自簽發證書適合測試環境，生產環境應使用受信任的憑證。
- HTTP2雖然提升性能，但部分舊版客戶端可能不支持，需做好兼容性測試。
- Docker打包時，注意映像大小與啟動速度，優化容器性能。
- 命令行程序的包運行順序影響服務啟動，務必確認配置正確，避免啟動失敗。

這些實務建議有助於學生在未來開發與運維中避免常見問題，提升微服務架構的穩定性與效率。

---
# Chapter 11：Spring Cloud及Cloud Native概述 (5講)
### 86 | 簡單理解微服務
#### 一、課程目標

本章節將帶領大家理解Spring微服務架構的核心概念與設計理念，特別聚焦於微服務（WIFU）相較於傳統單體應用的優勢與挑戰。透過理論與實務的結合，幫助學生掌握微服務的彈性、可擴展性與可維護性，為後續深入SpringCloud組件的學習打下堅實基礎。

重點標籤：#微服務概念 #彈性設計 #可擴展性 #系統解耦

推薦資源：  
- Sanyoman的WIFU實戰教程（實務操作參考）  
- Spring官方文檔（https://spring.io/projects/spring-cloud）

#### 二、微服務架構的基本認識

微服務架構（WIFU）是一種將大型單體應用拆分成多個獨立服務的設計模式。每個服務專注於特定業務功能，並且可以獨立部署與擴展。這種架構的最大優勢在於**故障隔離**，當某個服務出現問題時，不會影響整個系統的運作，提升系統的穩定性與可靠性。

比喻來說，傳統單體應用就像一棟大樓，任何一個房間出問題，整棟樓都可能受影響；而微服務則像是一個社區裡的多棟獨立房屋，某一棟出狀況，其他房屋依然正常運作。

重點標籤：#故障隔離 #獨立部署 #系統穩定性

#### 三、微服務的彈性與可擴展性

在單體應用中，系統的擴容或縮容通常是整體一起進行，這不僅浪費資源，也缺乏彈性。微服務架構允許針對特定服務進行擴展，例如在促銷活動期間，只擴展會員服務或交易服務，避免不必要的資源浪費。

此外，微服務的彈性體現在它能夠容忍部分服務的失效，避免整個系統崩潰。這種設計讓系統更具韌性，能夠應對突發狀況。

重點標籤：#彈性擴展 #資源優化 #系統韌性

#### 四、團隊與服務的劃分

微服務架構促進了團隊的專責化，每個團隊負責一組相關的服務，如交易團隊、會員團隊等。這種劃分讓開發與維護更為高效，團隊間的依賴減少，溝通成本降低。

這種模式也使得服務之間的邊界更加清晰，方便管理與升級。

重點標籤：#團隊專責 #服務邊界 #高效協作

#### 五、微服務開發與測試的挑戰

微服務雖然帶來許多好處，但也增加了開發與測試的複雜度。由於服務間存在依賴關係，測試時需要同時部署多個服務，這對環境配置與測試流程提出更高要求。

為解決這些問題，可以採用模擬服務（Mock）、契約測試等技術，或建立穩定的測試環境，確保開發效率與測試品質。

重點標籤：#測試複雜度 #依賴管理 #模擬服務

#### 六、實戰演示

本次實戰將示範如何從單體應用逐步拆分為微服務架構，並展示如何利用SpringCloud組件實現服務註冊與發現、負載均衡等功能。透過實際操作，學生能更直觀理解微服務的運作機制與優勢。

#### 七、課程小結與後續展望

本章節介紹了微服務架構的基本概念、彈性設計、團隊劃分及開發測試挑戰，幫助大家建立起微服務的整體認知。微服務相較於單體應用，在故障隔離與擴展性上有明顯優勢，但也帶來了系統複雜度的提升。

接下來，我們將深入探討多數據源配置，進一步擴展微服務架構的實務應用，為複雜系統的數據管理提供解決方案。

#### 八、Tips

- 微服務架構並非一開始就適合所有專案，建議從單體應用逐步演進，根據實際需求調整架構。  
- 理解服務間的依賴關係，有助於設計更穩健的系統。  
- 利用SpringCloud的豐富組件，可以大幅簡化微服務的開發與管理。  
- 測試環境的搭建是微服務成功的關鍵，務必重視自動化測試與持續整合。  

希望大家能透過本章節的學習，對Spring微服務架構有清晰且全面的認識，為後續深入實作做好準備。

---
### 87 | 如何理解雲原生(Cloud Native) 
#### 一、課程目標

本章節將帶領大家深入理解「云原生（Cloud Native）」的核心概念，並探討其在Spring微服務架構中的實務應用。學習重點包括：

- 理解云原生應用的特性與價值，如何從一開始就設計具備雲端能力的應用。
- 掌握DevOps與持續交付（Continuous Delivery）的重要性，並了解如何透過這些方法提升軟體交付效率與品質。
- 認識微服務架構與容器技術在云原生環境中的角色與優勢。
- 了解CNCF（Cloud Native Computing Foundation）及其生態系統，掌握主流開源工具與技術。

相關資源連結：

- CNCF官方網站：https://www.cncf.io/
- Spring官方微服務架構教學：https://spring.io/microservices
- 容器技術入門（Docker、Kubernetes）：https://kubernetes.io/zh/docs/home/
- DevOps與持續交付實踐指南：https://www.atlassian.com/devops

#### 二、云原生的核心概念與價值

云原生應用的最大特點是「從誕生之初就具備雲端能力」，這意味著應用不依賴於特定的基礎設施或雲服務商，能夠靈活部署於任何雲環境。這種設計理念幫助企業提升開發與運維效率，降低成本，並加速產品交付。

在實務上，云原生強調以下幾點：

- **彈性與可擴展性**：應用能根據需求自動調整資源。
- **自動化運維**：透過監控、日誌與自動恢復機制，減少人工干預。
- **快速迭代與交付**：結合DevOps與持續交付，縮短從開發到部署的周期。

比喻來說，云原生就像是為雲端量身打造的「智能工廠」，從設計、生產到維護都高度自動化且靈活。

#### 三、DevOps與持續交付在云原生中的角色

DevOps打破了傳統開發與運維的壁壘，讓兩者緊密合作，共同負責軟體的設計、部署與運維。這種協作模式促使開發人員在編寫程式時就考慮到部署與監控的需求，提升整體產品的穩定性與可維護性。

持續交付則是實現快速且可靠軟體發布的關鍵。它讓軟體產品在整個生命週期中，隨時保持可交付狀態，能夠快速響應市場需求與用戶反饋。

舉例來說，傳統瀑布式開發像是「長跑賽」，需要經過多個階段才能完成；而持續交付則像是「接力賽」，每個階段都能快速交棒，讓產品持續進步。

#### 四、微服務架構與容器技術

微服務架構將大型應用拆分為多個獨立且專注的服務，每個服務負責特定功能，彼此通過輕量級通信協議協作。這種架構提升了系統的靈活性與可維護性，方便團隊分工與快速迭代。

容器技術（如Docker）則為微服務提供了理想的運行環境。容器封裝了應用及其依賴，確保在不同環境中一致運行，並且能快速啟動與擴展。Kubernetes等容器編排工具則負責管理大量容器的部署、擴展與監控。

可以把微服務比喻成「工廠中的各個生產線」，而容器就是「標準化的生產設備」，兩者結合讓整個生產流程更高效且可控。

#### 五、CNCF與云原生生態系統

CNCF（Cloud Native Computing Foundation）是推動云原生技術發展的重要組織，類似於Linux基金會，聚合了眾多開源項目與社群資源。它涵蓋了容器、監控、服務網格、持續交付等多個領域的技術。

常見的CNCF項目包括：

- Kubernetes：容器編排平台
- Prometheus：監控系統
- Envoy：服務網格代理
- ETCD：分布式鍵值存儲

這些工具共同構建了云原生應用的基礎設施，幫助開發者更好地管理複雜的分布式系統。

#### 六、實戰演示

本次實戰將示範如何使用Spring Boot搭配Docker容器，快速構建並部署一個簡單的微服務應用。演示內容包括：

- 建立Spring Boot微服務專案
- 撰寫Dockerfile並打包容器映像
- 使用Docker命令啟動容器並測試服務
- 簡介Kubernetes部署流程（視時間而定）

透過實作，學生能夠體會云原生技術的實際操作流程，並理解各環節的關鍵點。

#### 七、課程小結與後續展望

本章節我們深入探討了云原生的核心理念，強調了DevOps、持續交付、微服務與容器技術在Spring微服務架構中的應用。這些技術共同促成了高效、靈活且可擴展的軟體開發與運維模式。

兩種配置方式（傳統與云原生）在開發流程、部署彈性與運維成本上有明顯差異，理解這些差異有助於選擇適合的架構方案。

接下來，我們將進入多數據源配置的學習，這是微服務架構中常見且重要的技術挑戰，將為後續的系統設計與實作打下堅實基礎。

#### 八、Tips

- 在設計微服務時，務必考慮服務的獨立部署與擴展性，避免過度耦合。
- 持續交付需要良好的自動化測試與監控機制，確保每次發布的品質。
- 容器技術不僅提升部署效率，也方便環境一致性管理，建議多加練習Docker與Kubernetes操作。
- 多關注CNCF生態系統的最新動態，掌握行業趨勢與最佳實踐。

如果有任何問題，歡迎在課堂或留言區提出，我們一起深入討論。

---
### 88 | 12-Factor App（上）
#### 一、課程目標

本章節將帶領大家深入了解Spring微服務架構中的最佳實踐方法，特別是以The Trifactor App為範例，介紹如何打造一套標準化、可擴展且易於維護的微服務系統。透過本課程，學生將掌握微服務開發中的核心概念與實務技巧，並能理解如何降低環境差異、提升系統穩定性與擴展性。

同時，提供The Trifactor App官方中文文檔連結，方便學生進一步閱讀與實作練習。

#### 二、The Trifactor App最佳實踐概述

The Trifactor App由Heroku團隊提出，旨在為SaaS服務提供一套標準化的開發與部署方法。雖然它原本針對RubyGem平台，但其理念與方法同樣適用於多種語言與後端架構，對於任何想打造高品質微服務的開發者都有參考價值。

這套方法強調：

- **標準化與自動化流程**：降低新手入門門檻，提升團隊協作效率。
- **雲平台友好**：支持多雲遷移，減少平台鎖定風險。
- **環境一致性**：減少開發、測試與生產環境間的差異，降低上線風險。

#### 三、The Trifactor App的十二條核心原則詳解

1. **Codebase（代碼庫）**  
   每個應用對應一個代碼庫，避免多個代碼庫混淆部署。這有助於版本管理與持續集成，確保每次部署的代碼來源明確。

2. **依賴管理**  
   明確列出所有外部依賴，避免隱藏依賴導致環境不一致或部署失敗。

3. **配置管理**  
   將配置與代碼分離，通常透過外部配置文件或配置中心管理。不同環境（開發、測試、生產）可使用不同配置，確保靈活性與安全性。

4. **後端服務**  
   將所有依賴的資源（如資料庫、快取服務）視為後端服務，無論本地或遠端，統一管理與調用。

5. **構建、發布與運行流程分離**  
   建議使用CI/CD工具（如Jenkins）分別負責構建、測試、發布與運行，確保流程清晰且可追蹤。

6. **無狀態進程**  
   應用應設計為無狀態，方便水平擴展。無狀態意味著任何實例都能處理請求，擴展時只需增加實例數量。

7. **端口綁定**  
   應用自行綁定端口，並透過反向代理或負載均衡器對外提供服務，方便容器化與動態調度。

8. **並發模型**  
   優先使用多進程擴展而非多線程，提升系統穩定性與擴展彈性。多進程架構更適合分布式環境。

9. **優雅重啟與發布**  
   支持平滑重啟，避免服務中斷，提升系統可用性。

10. **開發與測試環境一致性**  
    確保開發、測試與生產環境盡可能一致，避免因環境差異導致的潛在問題。

11. **日誌管理**  
    將日誌視為事件流，結構化輸出，方便集中收集與分析，提升故障排查效率。

12. **後台進程**  
    將背景任務獨立為單獨進程，方便管理與監控，提升系統穩定性。

#### 四、實戰演示

本節將示範如何根據The Trifactor App原則，使用Spring Boot建立一個無狀態的微服務應用，並展示：

- 如何分離配置並使用配置中心管理多環境配置。
- 使用Docker容器綁定端口並部署。
- 利用Jenkins實現構建、測試與發布的自動化流程。
- 實現日誌結構化輸出並整合ELK日誌分析平台。

透過實作，學生能更直觀理解理論與實務的結合。

#### 五、課程小結與後續展望

本章節介紹了The Trifactor App的十二條最佳實踐，強調標準化、無狀態設計與環境一致性對微服務架構的重要性。這些原則有助於提升系統的可維護性、擴展性與穩定性。

下一章節將深入探討多數據源配置，幫助學生掌握在複雜微服務環境中如何有效管理多個資料庫連接，進一步提升系統靈活性與性能。

#### 六、Tips

- 無狀態設計是微服務擴展的關鍵，避免在服務中保存用戶狀態，改用外部存儲（如Redis）管理會話。
- 配置中心（如Spring Cloud Config）能大幅簡化多環境配置管理，推薦實務中採用。
- 日誌結構化輸出不僅方便分析，也利於監控與告警系統的整合。
- 優雅重啟能避免因服務中斷導致用戶體驗下降，生產環境必須重視。

如果想深入了解，建議參考The Trifactor App官方中文文檔，並結合實際專案練習，將理論轉化為實戰能力。

---
### 89 | 12-Factor App（下）
#### 一、課程目標

本章節將深入探討12-Factor App中與Spring微服務架構密切相關的實踐原則，特別聚焦於代碼庫管理、依賴管理、無狀態服務設計、部署自動化以及應用的啟動與優雅關閉等核心概念。透過理論與實務結合，幫助學生理解如何在微服務環境中保持應用的可維護性、可擴展性與穩定性。

同時，提供實際操作資源與工具建議，讓學生能夠在課後進行練習與驗證，提升實戰能力。

#### 二、主體

1. **代碼庫與多環境部署管理**

   在微服務架構中，每個系統應該擁有且僅有一套代碼庫（Codebase），這是保持代碼一致性與可追蹤性的關鍵。透過同一套代碼結合不同的配置文件，可以實現多環境（開發、測試、預發、生產）部署，確保環境間的差異最小化。

   例如，在金融行業中，可能會有不同的安全隔離區（如PCIe隔離區、手機隔離區），同一套應用可根據配置部署於不同區域，滿足安全與合規需求。

   **重點標籤：#單一代碼庫 #多環境配置 #安全隔離**

2. **依賴管理的透明與衝突避免**

   微服務應明確列出所有依賴，避免隱藏依賴帶來的風險。使用依賴管理工具（如Maven的group ID、artifact ID）清晰定義依賴版本，防止版本衝突與同名類問題。

   建議使用掃描工具（如Duplicate Finder）檢查依賴庫中是否存在同名類，及早發現並解決衝突，避免運行時錯誤。

   此外，透過運行時接口集中管理依賴信息，有助於快速響應安全升級需求，及時通知相關系統負責人。

   **重點標籤：#依賴透明 #版本衝突 #安全升級**

3. **嚴格分離組件與運行環境**

   組件的發佈流程應嚴格控制，包含自動化測試、掃描與安全檢查，只有通過所有檢查的版本才能進入下一環節。這樣確保系統品質與穩定性。

   發佈過程應盡量自動化，避免人工操作帶來的錯誤與不一致。無狀態服務設計是微服務的核心優勢，方便擴展與重啟，但在某些情況下可適度保留緩存等狀態以提升性能，重啟時再從後端重新加載。

   **重點標籤：#自動化發佈 #無狀態服務 #性能優化**

4. **快速啟動與優雅關閉**

   應用啟動速度直接影響擴容效率與開發測試體驗，快速啟動能提升整體運維效率。

   優雅關閉則是指在關閉服務時，先停止接受新請求，等待現有請求處理完畢後再關閉，避免中斷用戶操作或數據不一致。例如數據庫中間件在重啟時，會先拒絕新連接，待現有連接清空後才關閉。

  這種設計能減少系統故障風險，提升用戶體驗。

   **重點標籤：#快速啟動 #優雅關閉 #用戶體驗**

5. **環境一致性的重要性**

   測試環境、預發環境與生產環境應盡可能保持一致，避免因環境差異導致的問題。例如測試使用MySQL，生產使用Oracle，或不同版本的驅動，可能引發兼容性錯誤。

   環境一致性有助於提前發現問題，降低上線風險。

   **重點標籤：#環境一致性 #兼容性 #風險降低**

#### 三、實戰演示

- 演示如何使用Spring Boot配置多環境屬性文件，實現同一套代碼在不同環境的部署。
- 使用Maven依賴管理工具，展示如何列出依賴並使用Duplicate Finder掃描依賴衝突。
- 演示Spring Boot應用的快速啟動與優雅關閉配置，包含如何實現優雅關閉的事件監聽與資源釋放。
- 實作一個簡單的無狀態服務，並示範如何在服務中加入緩存以提升性能，及重啟時的緩存重建流程。

#### 四、課程小結與後續展望

本章節重點在於理解12-Factor App中代碼庫管理、依賴透明、無狀態設計、發佈自動化及應用啟動關閉的最佳實踐。這些原則有助於提升Spring微服務的穩定性與可維護性。

兩種配置方式（無狀態與適度狀態緩存）各有優缺點，無狀態設計簡化擴展與重啟，但適度緩存可提升性能，需根據實際需求選擇。

下一章將介紹多數據源配置，進一步擴展微服務架構的數據管理能力，敬請期待。

#### 五、Tips：

- 始終保持依賴清單的透明與版本一致，避免隱藏依賴帶來的風險。
- 自動化測試與安全掃描是發佈流程中不可或缺的環節，確保系統品質。
- 優雅關閉能有效避免服務中斷，提升用戶體驗，建議在所有微服務中實現。
- 環境一致性是降低上線風險的關鍵，盡量使用相同的數據庫版本與配置。
- 無狀態服務設計是微服務架構的核心，但可根據性能需求適度保留狀態。

如果有任何問題，歡迎在留言區提出，我們一起討論解決方案。

---
### 90 | 認識Spring Cloud的組成部分
#### 一、課程目標

本章節旨在讓學生全面了解Spring Cloud的組成部分及其在微服務架構中的角色。透過本課程，學生將掌握Spring Cloud如何提供一套統一且便捷的編程模型，協助解決分布式系統中常見的服務發現、負載均衡、配置管理、消息傳遞與追蹤等問題。學習後，學生能夠理解Spring Cloud的核心功能，並能在實務中專注於業務邏輯的開發，而非底層基礎設施的實現。

相關資源連結：
- Spring Cloud官方文件：https://spring.io/projects/spring-cloud
- Spring Cloud GitHub範例：https://github.com/spring-cloud/spring-cloud-samples
- Eureka服務註冊與發現教學：https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-eureka-server.html

#### 二、Spring Cloud的核心組成與設計理念

Spring Cloud提供了一套統一的編程模型，類似於Spring框架中我們熟悉的各種Template（如JDBC Template、REST Template、Mongo Template），用以簡化分布式系統的開發。它將服務註冊與發現、負載均衡、配置管理、消息中介、分布式追蹤等功能抽象成多個子模組，並通過統一的接口進行調用。

例如，服務發行與註冊部分，Spring Cloud定義了一個Discovery Client接口，無論底層使用Eureka、Zookeeper還是阿里巴巴的iOS，開發者都可以透過同一套API來操作，實現了技術棧的解耦與靈活替換。這種設計讓開發者不必關心底層細節，而能專注於業務邏輯的實現。

此外，Spring Cloud還提供了負載均衡（Load Balancer）和服務網關（Gateway）等功能，幫助微服務系統實現流量分發與安全控制。這些功能的封裝使得微服務架構的搭建更加高效且穩定。

#### 三、Spring Cloud的主要功能模組介紹

1. **服務註冊與發現**  
   Spring Cloud支持多種服務註冊中心，如Eureka、Zookeeper等。服務啟動時會自動註冊，其他服務可通過註冊中心查詢並調用，實現動態服務管理。

2. **配置管理**  
   透過Spring Cloud Config，微服務可以集中管理配置，支持配置的動態刷新，提升系統的可維護性與靈活性。

3. **消息驅動與事件流**  
   Spring Cloud Streaming提供了對消息中介（如RabbitMQ、Kafka）的封裝，方便微服務間的異步通信與事件驅動架構實現。

4. **分布式追蹤**  
   利用Spring Cloud Sleuth與Zipkin，實現跨服務的請求追蹤，幫助開發者定位性能瓶頸與錯誤。

5. **服務網關**  
   Spring Cloud Gateway作為API入口，負責路由轉發、安全認證與流量控制，提升系統的安全性與可擴展性。

6. **安全管理**  
   Spring Cloud Security提供了基於OAuth2等標準的安全機制，保障微服務間的安全通信（本課程不深入探討，感興趣可自行學習）。

7. **多雲平台支持**  
   Spring Cloud支持多種公有雲平台，如Google Cloud、Microsoft Azure及阿里巴巴雲，方便微服務在不同環境中部署與運行。

#### 四、版本管理與Spring Cloud Release Train

Spring Cloud採用一種稱為Release Train（發行列車）的版本管理策略，將多個子模組的版本統一管理。每個Release Train以倫敦地鐵站的字母排序命名（如Greenwich），並包含多個Service Release（SR）版本，方便開發者追蹤與升級。

這種版本管理方式避免了子模組版本混亂，確保整體系統的兼容性與穩定性。學生在實際開發中只需關注當前使用的Release Train版本即可。

#### 五、實戰演示

本課程後續將以Greenwich版本為基礎，示範如何搭建一個簡單的服務註冊與發現系統，並展示如何使用Spring Cloud Config進行配置管理，最後演示Spring Cloud Streaming的消息傳遞機制。透過實作，學生能夠更直觀地理解Spring Cloud的運作流程與應用場景。

#### 六、課程小結與後續展望

本章節介紹了Spring Cloud的整體架構與主要組成部分，強調了其統一編程模型的設計理念，並說明了各模組在微服務架構中的作用。Spring Cloud讓開發者能夠專注於業務邏輯，減少基礎設施的開發負擔。

接下來的課程將深入探討服務註冊與發現的實作細節，並介紹多數據源配置，幫助學生建立更完整的微服務架構知識體系。

#### 七、Tips

- Spring Cloud的核心價值在於「抽象與封裝」，理解這一點有助於快速掌握其使用方法。  
- 服務註冊中心的選擇應根據實際需求與環境決定，Eureka適合Netflix生態，Zookeeper則更通用。  
- 配置管理的動態刷新功能能大幅提升系統靈活性，建議在開發中充分利用。  
- 分布式追蹤是微服務調試與性能優化的重要工具，建議配合Zipkin等工具使用。  
- 版本管理策略（Release Train）有助於避免依賴衝突，升級時務必確認各子模組版本兼容性。  

希望透過本章節的學習，大家能夠對Spring Cloud有一個全面且深入的認識，為後續微服務架構的實踐打下堅實基礎。

---
# Chapter 12：服務註冊與發現 (9講)
### 91 | 使用Eureka作為服務註冊中心  ― [eureka-server,eureka-waiter-service]
#### 一、課程目標

本章節將帶領學生深入了解Spring微服務架構中「服務註冊與發現」的核心機制，重點聚焦於Netflix Eureka的應用與實作。學生將學習如何搭建Eureka服務註冊中心，並實作一個微服務（以咖啡店服務員微服務為例）來註冊並發現服務。透過理論與實作結合，掌握微服務動態管理的關鍵技術，提升系統的可用性與擴展性。

同時，課程會介紹Eureka的高可用部署策略、健康檢查機制與負載均衡整合，並分享實務中常見的最佳實踐與注意事項。

推薦學生參考以下資源以加深理解與實作能力：
- Spring Cloud Netflix 官方文件：https://cloud.spring.io/spring-cloud-netflix/reference/html/
- Eureka Wiki：https://github.com/Netflix/eureka/wiki
- Spring Boot Actuator 官方文件：https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html
- 微服務架構模式：https://microservices.io/patterns/service-registry.html

#### 二、主體

##### 1. 服務註冊中心 Eureka 的核心概念與架構

Eureka 是Netflix開源的服務註冊與發現框架，作為微服務架構中服務動態管理的核心元件。它允許微服務實例在啟動時向Eureka Server註冊自己的服務資訊，並能從中獲取其他服務的可用實例清單，實現服務間的動態調用。

**重點標籤：服務註冊、服務發現、健康檢查、負載均衡**

Eureka的設計採用AP模式，強調高可用性與可擴展性，並具備自我保護機制，能在網路分割時保護已註冊的服務資訊不被錯誤剔除。

##### 2. 搭建Eureka服務註冊中心

透過Spring Boot與Spring Cloud Netflix Eureka的整合，只需在主啟動類加上`@EnableEurekaServer`註解，即可快速啟用服務註冊中心。配置檔案中設定伺服器埠號（預設8761），並關閉自身註冊與服務獲取（單機模式）以避免循環註冊。

Eureka Server提供Web管理介面，方便即時監控註冊服務狀態。生產環境建議部署多個Eureka實例形成叢集，避免單點故障。

**重點標籤：@EnableEurekaServer、單機模式、叢集部署、自我保護機制**

##### 3. 微服務客戶端的服務註冊與發現

以咖啡店服務員微服務為例，展示如何在Spring Boot應用中啟用Eureka Client功能。只需加上`@EnableDiscoveryClient`註解，並在`application.properties`中設定服務名稱與Eureka Server地址，服務啟動時會自動向Eureka註冊。

此微服務實作了咖啡產品管理與訂單處理的業務邏輯，並整合Actuator提供健康檢查與監控指標，確保服務狀態透明且可被監控。

**重點標籤：@EnableDiscoveryClient、spring.application.name、服務自動註冊、健康檢查**

##### 4. 健康檢查與監控機制

微服務透過Spring Boot Actuator暴露健康檢查端點，Eureka Server會定期檢查服務狀態，確保只將健康的服務實例納入服務清單。服務端也可自定義健康指標（如咖啡產品庫存狀態），提升監控的精準度。

此外，整合Micrometer與Prometheus可收集業務指標，幫助運維團隊即時掌握系統效能與健康狀況。

**重點標籤：Actuator、HealthIndicator、自定義健康檢查、Micrometer、Prometheus**

##### 5. 金額處理與資料持久化

咖啡店微服務使用Joda Money庫處理金額，避免浮點數精度問題，並透過JPA與H2資料庫實現資料持久化。此設計確保業務邏輯的準確性與資料一致性。

**重點標籤：Joda Money、資料庫持久化、JPA**

##### 6. 生產環境部署與最佳實踐

- 建議Eureka Server以叢集方式部署，避免單點故障。
- 生產環境需加入安全機制（如Spring Security）保護註冊中心。
- 調整心跳與續約時間參數以優化效能。
- 監控與告警系統不可或缺，確保服務穩定運行。
- 服務名稱需唯一，避免註冊衝突。

**重點標籤：叢集部署、安全防護、效能調優、監控告警**

#### 三、實戰演示

1. 啟動Eureka Server專案，確認管理介面可正常存取（http://localhost:8761）。
2. 啟動咖啡店服務員微服務，觀察其自動註冊至Eureka Server。
3. 使用curl或瀏覽器調用咖啡產品API，驗證服務功能。
4. 查看Actuator健康檢查端點，確認服務狀態為UP。
5. 模擬服務異常，觀察Eureka如何剔除不健康實例。
6. 展示如何配置Eureka叢集，提升高可用性。

#### 四、課程小結與後續展望

本章節介紹了Spring微服務架構中服務註冊與發現的核心技術，透過Netflix Eureka實作服務註冊中心與微服務客戶端，並結合健康檢查與監控機制，確保系統的動態管理與高可用性。

兩種配置方式（單機模式與叢集模式）各有優缺點：單機模式簡單易用，適合開發與測試；叢集模式適合生產環境，能避免單點故障但配置較複雜。

下一章節將介紹多數據源配置，幫助學生理解如何在微服務中管理多個資料來源，進一步提升系統的靈活性與擴展性。

#### 五、Tips：

- 在開發環境中，使用隨機埠（server.port=0）避免埠號衝突。
- 服務名稱（spring.application.name）必須唯一，否則會導致註冊衝突。
- 使用Actuator監控端點時，生產環境應限制存取權限，避免敏感資訊外洩。
- Joda Money是處理貨幣計算的好幫手，避免浮點數誤差。
- 定期檢查Eureka Server的自我保護機制設定，確保在網路異常時服務資訊不被錯誤剔除。
- 叢集部署時，確保各Eureka實例間的service-url配置正確，避免註冊資訊不同步。

這樣的講義結構與內容，能幫助學生系統性掌握Spring微服務架構中服務註冊與發現的關鍵技術，並具備實務操作能力。

---
### 92 | 使用Spring Cloud Loadbalancer訪問服務 ― [ribbon-customer-service,eureka-server,eureka-waiter-service]

#### 一、課程目標

本章節將介紹如何在 Spring Cloud 微服務架構中實現服務發現和負載均衡，主要聚焦於：
- 使用 Discovery Client 和 Eureka Client 進行服務發現
- 透過 Ribbon 實現客戶端負載均衡
- 實作 RestTemplate 與負載均衡的整合
- 建立完整的服務調用流程

#### 二、服務發現機制

1. **兩種服務發現方式**
- Eureka Client：直接提供服務發現功能
- Discovery Client：Spring Cloud 提供的抽象層
> 💡 建議使用 Discovery Client，因為它提供更好的跨平台相容性，未來切換註冊中心時不需要修改程式碼

2. **Discovery Client 使用方式**
```java
@EnableDiscoveryClient  // 啟用服務發現
public class CustomerServiceApplication {
    private void showServiceInstances() {
        discoveryClient.getInstances("waiter-service")
            .forEach(s -> log.info("Host: {}, Port: {}", 
                s.getHost(), s.getPort()));
    }
}
```

#### 三、負載均衡實現

1. **Ribbon 負載均衡配置**
```java
@LoadBalanced  // 啟用負載均衡
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```

2. **負載均衡實現原理**
- 透過 ClientHttpRequestInterceptor 接口實現
- RibbonLoadBalancerClient 處理負載均衡邏輯
- 自動將服務名稱轉換為實際的服務實例地址

#### 四、實戰演示

1. **專案配置**
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

2. **關鍵配置說明**
```properties
spring.application.name=customer-service
server.port=0  # 使用隨機端口
```

3. **服務調用示例**
```java
// 使用服務名稱替代具體的 IP 和端口
String serviceUrl = "http://waiter-service/coffee/";
Coffee coffee = restTemplate.getForObject(serviceUrl, Coffee.class);
```

#### 五、課程小結與後續展望

1. **核心概念回顧**
- 服務發現提供了動態獲取服務實例的能力
- 負載均衡實現了請求的自動分配
- RestTemplate 整合使服務調用更簡單

2. **實務應用建議**
- 優先使用 Discovery Client 進行服務發現
- 善用 @LoadBalanced 注解實現負載均衡
- 注意配置超時和重試機制

#### Tips

1. **效能優化**
- 適當配置連線池大小
- 設定合理的超時時間
- 實作重試機制

2. **常見問題處理**
- 服務無法發現：檢查服務註冊狀態
- 負載均衡失效：確認 @LoadBalanced 注解
- 調用超時：調整超時設定

3. **最佳實踐**
- 使用服務名稱而非具體 IP/端口
- 實作健康檢查機制
- 保持適當的日誌級別

> 📚 參考資源：
> - [Spring Cloud 官方文件](https://spring.io/projects/spring-cloud)
> - [Netflix Ribbon 文件](https://github.com/Netflix/ribbon)
> - [Spring Cloud Netflix 整合指南](https://cloud.spring.io/spring-cloud-netflix/reference/html/)

---
### 93 | 使用Feign訪問服務 ― [feign-customer-serivce,eureka-server,eureka-waiter-service]
#### 一、課程目標

本章節旨在讓學生理解並掌握Spring微服務架構中，如何利用Spring Cloud OpenFeign實現宣告式服務調用。學生將學會如何透過Feign簡化微服務間的通訊，並了解服務註冊與發現的整合方式，提升開發效率與系統效能。此外，課程將介紹HTTP客戶端優化與貨幣處理的實務技巧，幫助學生在實際專案中應用。

相關資源連結：
- Spring Boot官方文件：https://spring.io/projects/spring-boot
- Spring Cloud官方文件：https://spring.io/projects/spring-cloud
- Spring Cloud OpenFeign文件：https://spring.io/projects/spring-cloud-openfeign
- OpenFeign官方文件：https://github.com/OpenFeign/feign
- Apache HttpClient5文件：https://hc.apache.org/httpcomponents-client-5.2.x/
- Joda Money文件：https://www.joda.org/joda-money/

#### 二、Spring Cloud OpenFeign簡介與核心概念

Spring Cloud OpenFeign是一個宣告式的REST客戶端框架，允許開發者透過定義介面來調用遠端服務，無需手動撰寫HTTP請求程式碼。這種方式大幅減少樣板程式碼，提高程式碼的可讀性與維護性。

- **宣告式服務調用**：只需在介面上使用@FeignClient註解，Spring Cloud會自動生成代理實現，讓你像調用本地方法一樣調用遠端API。
- **服務註冊與發現整合**：Feign與Eureka整合，能自動從註冊中心獲取服務實例，實現動態調用與負載均衡。
- **Context ID區分多介面**：當同一服務有多個Feign介面時，使用contextId避免衝突，確保調用正確。

比喻來說，Feign就像一個智能的遠端服務代理，幫你包裝好所有複雜的HTTP細節，你只要專注於呼叫介面方法即可。

#### 三、Feign客戶端的實作細節與配置

1. **介面定義**  
   使用@FeignClient註解定義服務介面，指定服務名稱、路徑與contextId。例如：

   ```
   @FeignClient(name = "waiter-service", contextId = "coffee", path = "/coffee")
   public interface CoffeeService {
       List<Coffee> getAll();
       Coffee getById(Long id);
       Coffee getByName(String name);
   }
   ```

   建議不要在介面上使用@RequestMapping，避免Spring Cloud的已知問題，改為在方法上完整定義路徑。

2. **服務調用**  
   直接注入Feign介面，呼叫方法即可完成遠端調用，無需手動處理HTTP請求。

3. **HTTP客戶端優化**  
   自定義HttpClient5配置，設定連線池大小、連線存活時間、Keep-Alive策略等，提升連線效能與穩定性。

4. **貨幣處理**  
   使用Joda Money處理貨幣計算，避免浮點數誤差，並自訂序列化與反序列化器確保資料正確傳輸。

5. **配置說明**  
   透過application.properties或YML設定Feign的連線超時、讀取超時、壓縮等參數，靈活調整客戶端行為。

#### 四、實戰演示

- 啟動Eureka Server與waiter-service，確保服務註冊中心正常運作。
- 啟動Feign Customer Service，透過Feign介面呼叫waiter-service的API。
- 示範取得咖啡列表、根據ID或名稱查詢咖啡、建立訂單並查詢訂單狀態。
- 觀察程式碼簡潔度與調用流程，體會Feign帶來的便利。
- 展示自定義HTTP客戶端配置如何提升效能。

#### 五、課程小結與後續展望

本章節介紹了Spring Cloud OpenFeign的宣告式服務調用方式，強調了其簡潔性與與Eureka服務發現的整合優勢。透過Feign，開發者能大幅減少樣板程式碼，提升系統維護性與開發效率。自定義HTTP客戶端配置與貨幣處理則是實務中不可忽視的細節，能有效提升系統穩定性與準確性。

後續章節將介紹多數據源配置，幫助學生進一步掌握複雜微服務架構中資料管理的技巧，銜接更完整的微服務設計能力。

#### 六、Tips

- **避免在Feign介面上使用@RequestMapping**，改為在方法上定義完整路徑，避免Spring Cloud已知問題。
- **使用contextId區分同一服務的多個Feign介面**，防止調用衝突。
- **合理配置HTTP客戶端連線池與超時參數**，提升服務調用效能與穩定性。
- **整合Joda Money處理貨幣計算**，避免浮點數誤差帶來的問題。
- **撰寫清楚的程式碼註解與測試**，確保團隊協作與系統品質。
- **多參考官方文件與社群資源**，持續學習Feign與Spring Cloud的最佳實踐。

這樣的講義結構與內容，能幫助學生從理論到實作，全面理解並應用Spring微服務架構中的Feign服務調用技術。

---
### 94 | 深入理解服務發現背後的DiscoveryClient
#### 一、課程目標

本章節旨在讓學生深入理解Spring Cloud中服務發現（Service Discovery）背後的核心機制，特別是DiscoveryClient的角色與運作方式。學生將學習如何透過Spring Cloud的抽象層，實現服務的註冊與發現，並以Eureka為例，掌握服務註冊的流程與生命週期管理。透過本課程，學生能夠理解微服務架構中服務註冊與發現的重要性，並具備實作與調試的能力。

相關資源：
- Spring Cloud官方文件
- Eureka服務註冊中心
- Spring Cloud Commons模組（包含DiscoveryClient相關抽象）

#### 二、DiscoveryClient與服務註冊的核心概念

在微服務架構中，服務註冊與發現是確保服務間能夠動態互相尋址與調用的關鍵。Spring Cloud提供了DiscoveryClient這個抽象，負責服務的發現功能。最早DiscoveryClient同時涵蓋了服務註冊與發現，但隨著版本演進，服務註冊被拆分成獨立的Service Registration抽象，專門負責將服務註冊到註冊中心。

- **DiscoveryClient**：負責查詢服務清單，實現服務發現。
- **Service Registration**：負責將服務註冊到註冊中心，管理服務狀態。

這種分離設計讓系統更具彈性，能夠支援不同的註冊中心（如Eureka、Consul等），並且統一DiscoveryClient的使用介面。

#### 三、以Eureka為例的服務註冊流程

以Eureka為例，Spring Cloud透過Eureka Service Registration實現服務註冊。註冊的服務資訊會被封裝在Eureka Registration物件中，包含服務的基本資料與狀態。

Spring Cloud提供了Eureka Auto Service Registration的自動配置，利用Spring的生命週期管理（Lifecycle）機制，在應用啟動時自動完成服務註冊。其流程如下：

1. 啟動時檢查服務埠號與狀態。
2. 若尚未註冊且服務狀態正常，呼叫Service Registration的註冊方法。
3. 註冊成功後，發布事件並標記服務為運行中。
4. 停止服務時，呼叫取消註冊方法，將服務狀態設為DOWN。

這種自動化流程減少了開發者手動管理註冊的負擔，確保服務狀態與註冊中心同步。

#### 四、DiscoveryClient的服務發現機制

DiscoveryClient提供了根據服務ID查詢服務實例的功能。以Eureka DiscoveryClient為例，它透過Eureka Client查詢註冊中心，取得指定服務的所有實例清單，並返回給調用方。

這使得微服務能夠動態獲取其他服務的位置，實現負載均衡與容錯。Spring Cloud還提供了負載均衡抽象（如Ribbon、Spring Cloud LoadBalancer），與DiscoveryClient結合使用，提升服務調用的穩定性與效率。

#### 五、實戰演示

示範如何在Spring Boot應用中啟用DiscoveryClient與Eureka Auto Service Registration：

- 在`application.yml`中配置Eureka服務註冊中心地址。
- 使用`@EnableDiscoveryClient`註解啟用服務發現功能。
- 觀察應用啟動時，服務如何自動註冊到Eureka。
- 使用DiscoveryClient API查詢其他服務實例。
- 演示服務停止時自動取消註冊的流程。

透過實作，學生能夠理解服務註冊與發現的全流程，並掌握相關API的使用。

#### 六、課程小結與後續展望

本章節介紹了Spring Cloud中服務註冊與發現的核心抽象，特別是DiscoveryClient與Service Registration的分工與運作。以Eureka為例，說明了服務如何自動註冊與取消註冊，並透過DiscoveryClient查詢服務實例。

- **優點**：抽象分離提高彈性，支援多種註冊中心；自動化註冊減少手動配置。
- **缺點**：依賴註冊中心穩定性，版本升級需注意API變化。

下一章節將介紹多數據源配置，進一步擴展微服務架構的靈活性與可擴展性。

#### 七、Tips

- 理解Spring的生命週期管理（Lifecycle）對掌握自動註冊機制非常重要。
- Eureka Registration物件是服務註冊資訊的核心，熟悉其結構有助於調試。
- 實務中，建議結合負載均衡器使用DiscoveryClient，提升服務調用的可靠性。
- 可以參考Spring Cloud Commons模組，深入了解DiscoveryClient的抽象設計。

這樣的結構與內容安排，能幫助學生系統性掌握Spring微服務架構中服務發現的核心技術，並具備實務操作能力。

---
### 95 | 使用Zookeeper作為服務註冊中心 ― [zk-waiter-service,zk-customer-service]
#### 一、課程目標

- 說明本章學習重點與實務意義
  - 了解如何使用 Apache Zookeeper 作為 Spring Cloud 的服務註冊與發現中心，並能在本地或 Docker 上快速部署測試。
  - 掌握服務自動註冊、動態發現、負載均衡（Spring Cloud LoadBalancer）與 HTTP 客戶端最佳化（Apache HttpClient 5）等實作要點。
  - 能評估 Zookeeper 作為註冊中心在一致性、可用性與部署場景（單機房 vs 多機房）的利弊，並與其他註冊中心（如 Eureka）作比較，形成選擇依據。

- 實作與練習資源（請同學事先 clone、啟動）
  - 專案範例：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 12 服務註冊與發現/zk-waiter-service/README.md]]
  - 客戶端範例：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 12 服務註冊與發現/zk-customer-service/README.md]]
  - 講義參考（語音轉錄）：[[95 | 使用Zookeeper作为服务注册中心]]
  - 官方文件：
    - Spring Cloud Zookeeper: https://spring.io/projects/spring-cloud-zookeeper
    - Apache Zookeeper: https://zookeeper.apache.org/
    - Spring Cloud LoadBalancer: https://spring.io/projects/spring-cloud-loadbalancer
    - Apache HttpClient 5: https://hc.apache.org/httpcomponents-client-5.3.x/

#### 一、主體 — 1：Zookeeper 基本概念與設計考量

- 說明
  - Zookeeper 是成熟的分散式協調服務，設計類似檔案系統（節點/路徑、順序式操作），具備多副本、Leader/Followers 架構。
  - 在 CAP 理論中屬於 CP（強一致性 + 可分區容忍性），因此在網路分割或寫入競爭時，Zookeeper 會優先保證一致性。

- 重點標示
  - 【重點】Zookeeper 屬 CP，適合對一致性要求高、讀多寫少的情境。
  - 【重點】生產環境至少部署 3 個節點（推薦 3 或 5 節點），避免單點故障。

- 比喻說明
  - 把 Zookeeper 想成「全局一致的電話簿」，每一筆改動要先協調完成，才能對外提供穩定的查詢結果；這個設計讓資料一致，但在大量寫入或跨機房情境會影響可用性或延遲。

- 過渡語句
  - 了解基本特性後，接下來看 Spring Cloud 如何與 Zookeeper 整合、設定與程式碼實作。

#### 一、主體 — 2：在 Spring Cloud 中整合 Zookeeper（設定與依賴）

- 說明
  - 只需引入 Spring Cloud Zookeeper Discovery 的 dependency，並在設定檔中指定 connect-string（Zookeeper 位址），服務會在啟動時自動向 Zookeeper 註冊。
  - 在 Spring Boot 專案中常把服務名稱設為 spring.application.name，server.port 可設 0（隨機分配）便於多實例測試。

- 範例設定（重點）
  - 【重點】application.properties 範例：
    - spring.cloud.zookeeper.connect-string=localhost:2181
    - spring.application.name=customer-service / waiter-service
    - server.port=0
    - management.endpoint.health.show-details=always

- 實務提醒
  - 在同一機房內使用 Zookeeper 最為合適；跨機房會因 network partition 與延遲造成問題，建議為每個機房部署獨立的 Zookeeper 集群並採多註冊中心策略。

- 過渡語句
  - 有了設定，下一步是檢視專案中的核心程式碼，了解如何做 HTTP 客戶端與負載均衡整合。

#### 一、主體 — 3：HTTP 客戶端與負載均衡實作要點

- 說明
  - 範例專案使用 Apache HttpClient 5 配合 RestTemplate（加上 @LoadBalanced）透過服務名稱呼叫其他微服務，由 LoadBalancer 負責選擇實例。
  - 自訂 HttpClient 可以優化連線池、閒置連線清理與重試策略，避免大量短連線導致資源耗盡。

- 重要程式碼解讀（說明每一項為何重要）
  - 連線池設定（PoolingHttpClientConnectionManager）
    - 【重點】setMaxTotal 與 setDefaultMaxPerRoute：根據實際負載調整，避免連線耗盡。
    - evictIdleConnections：清理閒置連線，降低資源泄漏風險。
    - disableAutomaticRetries：有些情境下避免自動重試造成重複副作用，需由上層控制重試邏輯。
  - RestTemplate 與 @LoadBalanced
    - 【重點】使用 @LoadBalanced 的 RestTemplate 可直接用 "http://service-name/..." 呼叫，透過 Spring Cloud LoadBalancer 實現實例選擇。

- 範例呼叫流程
  - customer-service 使用 restTemplate.exchange("http://waiter-service/coffee/", ...) 取得 waiter-service 的咖啡清單，LoadBalancer 自動選擇 waiter 的某一實例並發送請求。

- 過渡語句
  - 理論與程式碼做完後，我們示範如何在本地或 Docker 上快速部署並驗證服務註冊狀態。

#### 一、實戰演示（教學步驟與檢查點）

- 準備
  - 確認 Java 21、Maven、Docker（可選）已安裝。
  - 下載範例專案：
    - waiter-service：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 12 服務註冊與發現/zk-waiter-service/README.md]]
    - customer-service：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 12 服務註冊與發現/zk-customer-service/README.md]]

- 步驟
  1. 啟動 Zookeeper（推薦 Docker）：
     - docker run -d --name spring-zookeeper -p 2181:2181 apache/zookeeper:3.9.3
  2. 編譯並啟動 waiter-service：
     - mvn clean compile
     - mvn spring-boot:run
  3. 使用 Zookeeper CLI 檢查註冊路徑：
     - docker exec -it spring-zookeeper zkCli.sh
     - ls /services
     - get /services/waiter-service/[instance-id]  // 觀察註冊的 metadata（host, port, instance-id）
  4. 啟動 customer-service，檢查是否發現 waiter-service 並成功呼叫。
  5. 在應用端觀察日誌，確認 DiscoveryClient 與 Actuator 健康狀態。

- 驗證重點（標示）
  - 【重點】Zookeeper 上應可看到 /services/waiter-service 與 /services/customer-service 節點。
  - 【重點】customer-service 的日誌應顯示呼叫 waiter-service 並處理回應。

- 常見錯誤檢查
  - Zookeeper 連接失敗：docker ps | grep zookeeper / telnet localhost 2181
  - 服務未註冊：檢查 spring.cloud.zookeeper.connect-string 是否正確、應用是否成功啟動
  - 負載均衡失效：確認 RestTemplate 有 @LoadBalanced 注入

#### 一、課程小結與後續展望

- 小結（Zookeeper 使用上的優缺點）
  - 【優點】
    - 強一致性（CP），註冊資訊一致且可靠。
    - 成熟穩定、監控工具與社群資源豐富。
  - 【缺點】
    - CP 特性在網路分區或跨機房情境下會影響可用性與延遲。
    - 大量寫入場景效能較差（適合讀多寫少）。
  - 【重點】在同一機房或對一致性要求高的場景，Zookeeper 是合適選擇；若需求偏向高可用性與快速 failover（AP），可考慮 Eureka 或其他 AP 類解法。

- 兩種配置方式差異（簡短比較：Zookeeper vs Eureka）
  - Zookeeper（CP）：一致性優先、適合讀多寫少、建議 3+ 節點同機房部署。
  - Eureka（AP，由 Netflix 設計）：可用性優先、容忍網路分裂時仍提供服務發現（但一致性較弱），較適合大規模、跨機房彈性需求。
  - 【重點】註冊中心的選擇應以系統對一致性 vs 可用性的需求、部署拓撲與運維能量為主。

- 後續章節預告
  - 下一章將介紹「多數據源配置」，探討如何在 Spring Boot 中配置多個資料來源、交易管理與資料庫路由，銜接微服務內部的資料層設計。

#### 一、Tips

- 【Tip】部署建議：生產環境的 Zookeeper 至少 3 節點，建議在同一機房內以降低延遲與分裂風險。
- 【Tip】若系統需跨機房，建議採用多註冊中心（每機房一組），或選擇以客戶端快取與容錯設計來降低註冊中心故障影響。
- 【Tip】連線池參數需根據實際 RPS 調整；開發環境使用預設值即可，壓力測試時再微調。
- 【Tip】避免在生產環境中直接使用最新未穩定版本（例如 beta），以穩定版本為主。
- 【Tip】實作重試策略時考慮冪等性（避免重試導致重複寫入），可在 HTTP 層或業務層實作去重或回滾機制。

結語：本章透過範例專案（[[.../zk-waiter-service/README.md]]、[[.../zk-customer-service/README.md]]）實作了 Zookeeper 的註冊與發現流程，並示範了 HTTP 客戶端、負載均衡與健康檢查的整合方式。請同學動手部署範例、觀察 Zookeeper 中的 /services 節點，並思考在真實系統中如何在一致性與可用性之間做取捨。有需要我可以把示範步驟擴充成逐步教學腳本或提供故障模擬練習題。

---
### 96 | 使用Consul作為服務註冊中心 ― [consul-waiter-service,consul-customer-service]
#### 一、課程目標

本章節將帶領學生深入了解如何使用 **Consul** 作為 Spring 微服務架構中的服務註冊與發現中心。學生將學習 Consul 的核心特性、服務發現機制、健康檢查、DNS 整合及與 Spring Cloud 的整合方式，並透過實際範例掌握如何在微服務中實現動態服務註冊與負載均衡。

學習重點包括：
- 理解 Consul 的服務註冊與發現原理及其優勢
- 掌握 Consul 的多種服務發現方式（HTTP API、DNS、Nginx 整合）
- 熟悉 Spring Cloud 如何整合 Consul 進行服務註冊與發現
- 實作健康檢查與負載均衡機制
- 透過範例操作，體驗 Consul 在微服務架構中的應用

相關資源：
- [Spring Cloud Consul 官方文件](https://docs.spring.io/spring-cloud-consul/docs/current/reference/html/)
- [Consul 官方文件](https://www.consul.io/docs)
- 微服務架構實戰課程範例專案：[[consul-customer-service]]、[[consul-waiter-service]]

#### 二、Consul 服務註冊與發現概述

Consul 是 HashiCorp 提供的一個分散式服務網格解決方案，具備服務註冊、服務發現、健康檢查、配置管理及多資料中心支援等功能。它不僅能作為服務註冊中心，還能作為配置中心，並支援安全的服務間通訊。

主要特性：
- **服務發現**：服務啟動時自動註冊，客戶端可動態查詢可用服務節點
- **健康檢查**：支援多種健康檢查方式（HTTP、TCP、Script），確保服務可用性
- **多資料中心支援**：適合跨區域部署，提升系統彈性與可用性
- **DNS 整合**：可透過標準 DNS 查詢服務，方便與現有基礎設施整合
- **Nginx 整合**：可與 Nginx HTTP backend module 聯動，實現動態負載均衡配置更新
- **安全性**：支援 TLS 加密與 ACL 存取控制，保障服務通訊安全

這些功能使 Consul 成為微服務架構中強大且靈活的服務註冊與發現解決方案。

#### 三、Spring Cloud 與 Consul 整合

在 Spring Cloud 生態系統中，使用 Spring Cloud Consul Discovery Starter 可以輕鬆將 Consul 作為服務註冊與發現中心。只需在專案中引入相應依賴，並在配置檔中指定 Consul 伺服器地址，即可替換原本的 Eureka 或 Zookeeper。

配置重點：
- 設定 `spring.application.name` 作為服務名稱，確保唯一性
- 指定 Consul 主機與端口（預設為 localhost:8500）
- 配置健康檢查端點與間隔（如 `/actuator/health`，間隔 10-15 秒）
- 使用 `@LoadBalanced` 的 RestTemplate 實現客戶端負載均衡

這種整合方式讓開發者能夠專注於業務邏輯，無需關心底層服務發現細節。

#### 四、Consul 服務發現的多種方式

Consul 支援多種服務發現方式，靈活適應不同場景需求：

1. **HTTP API**  
   透過 RESTful API 查詢服務列表、服務詳細資訊及健康狀態，方便程式化操作與監控。

2. **DNS 查詢**  
   Consul 提供 DNS 介面，允許使用標準 DNS 工具（如 dig、nslookup）查詢服務 IP，適合無法修改基礎設施的環境。  
   例如：`dig @localhost -p 8600 waiter-service.service.consul`

3. **Nginx 整合**  
   利用 Nginx HTTP Consul backend module，當服務節點變化時，Nginx upstream 配置可自動更新，實現動態負載均衡。

這些方式可依需求混合使用，提升系統彈性與可維護性。

#### 五、實戰演示：Consul Waiter Service 與 Customer Service 範例

本章提供兩個 Spring Cloud 微服務範例專案：

- **Consul Waiter Service**：模擬咖啡廳服務員系統，提供咖啡訂單管理與庫存查詢，展示服務註冊、健康檢查與雙重服務發現（HTTP API + DNS）。
- **Consul Customer Service**：展示如何使用 Consul 作為服務發現中心，實現客戶端動態發現 waiter-service 並進行負載均衡。

實作重點：
- 透過 Docker 啟動本地 Consul 服務（包含 UI 介面）
- 修改 Spring Boot 專案配置，切換服務發現為 Consul
- 使用 RestTemplate 搭配 `@LoadBalanced` 實現服務間通訊
- 利用 dig 命令測試 DNS 服務發現功能
- 觀察 Consul UI 介面中服務註冊狀態與健康檢查結果

此實戰讓學生能夠從理論到實作，完整體驗 Consul 在微服務架構中的應用。

#### 六、課程小結與後續展望

本章節介紹了 Consul 作為服務註冊與發現中心的核心功能與優勢，並透過兩個實戰範例展示如何在 Spring Cloud 微服務中整合 Consul。重點整理如下：

- Consul 支援多資料中心、健康檢查、DNS 服務發現及安全通訊，功能豐富且彈性高
- Spring Cloud 提供簡單的整合方案，讓開發者輕鬆切換服務發現中心
- 多種服務發現方式（HTTP API、DNS、Nginx）滿足不同基礎設施需求
- 實戰範例展示了從服務註冊、健康檢查到客戶端負載均衡的完整流程

後續章節將介紹 **多數據源配置**，幫助學生進一步掌握微服務中資料管理的複雜性與最佳實踐，銜接更完整的微服務架構設計。

#### 七、Tips

- **服務名稱唯一性**：務必確保 `spring.application.name` 唯一，避免服務註冊衝突。
- **健康檢查端點**：實作 `/actuator/health` 並保持快速響應，確保 Consul 能準確判斷服務狀態。
- **DNS 服務發現**：適合無法修改應用程式的基礎設施，利用標準 DNS 工具即可查詢服務。
- **Nginx 整合**：若使用 Nginx 作為負載均衡器，可考慮整合 Consul backend module 實現動態配置更新。
- **本地開發環境**：使用 Docker 快速啟動 Consul，方便測試與開發。
- **監控與告警**：結合 Spring Boot Actuator 與 Micrometer，實現服務健康監控與告警。

這些實務建議能幫助學生在實際專案中更有效率地運用 Consul，提升微服務系統的穩定性與可維護性。

---
### 97 | 使用Nacos作為服務註冊中心 ― [nacos-waiter-service,nacos-customer-service]
根據提供的內容，我幫你整理一份關於Spring微服務架構中使用Nacos作為服務註冊中心的講義：

#### 一、課程目標

- 了解Nacos作為服務註冊中心的基本概念與優勢
- 掌握在Spring Cloud中整合Nacos的配置方法
- 實作基於Nacos的服務註冊與發現功能
- 理解服務間的負載均衡調用機制

#### 二、Nacos簡介

Nacos是阿里巴巴開源的一套服務管理平台，具備以下特點：

- 提供服務發現、配置管理、服務管理等功能
- 支援動態DNS服務
- 完善的中文文檔資源
- 提供Web控制台，方便管理
- 支援多種後端儲存（MySQL、IBMS等）
- 使用Raft協議確保一致性

#### 三、整合Spring Cloud步驟

1. 添加依賴：
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

2. 配置Nacos服務地址：
```properties
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
spring.application.name=your-service-name
```

3. 啟用服務發現：
```java
@EnableDiscoveryClient
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

#### 四、實戰演示

以咖啡訂購系統為例，展示兩個服務：

1. Waiter Service（服務提供者）：
- 提供咖啡菜單查詢
- 處理訂單創建
- 自動註冊到Nacos

2. Customer Service（服務消費者）：
- 調用Waiter Service獲取菜單
- 通過服務發現機制找到服務
- 實現負載均衡調用

#### 五、課程小結與後續展望

優勢：
- 完善的中文支援
- 整合配置中心功能
- 提供完整管理介面
- 支援多種部署模式

注意事項：
- 目前仍在快速迭代中
- 版本相容性需要注意
- 建議等待穩定版本再用於生產環境

#### Tips：

1. 啟動Nacos：
```bash
docker run --name nacos-standalone -e MODE=standalone -p 8848:8848 -d nacos/nacos-server
```

2. 訪問管理介面：
- URL：http://localhost:8848/nacos
- 預設帳密：nacos/nacos

3. 常見問題處理：
- 服務註冊失敗：檢查Nacos服務狀態
- 連線超時：調整超時設定
- 版本相容：確認Spring Cloud Alibaba版本

---
### 98 | 如何定制自己的DiscoveryClient  ― [fixed-discovery-client-demo,Chapter 6-springbucks2]
好的，我會把講義中的「大項標號」改為有順序性的編號（一、二、三…），並依你之前的格式要求每一個大項都以 "#### X、" 開頭且保留一個空行。下面是已調整為順序性標號的完整講義稿（繁體中文）：

#### 一、課程目標：

- 簡要說明本章節的學習重點與實務意義：  
  - 了解如何在 Spring 微服務中實作自定義 DiscoveryClient（FixedDiscoveryClient）與對應負載均衡元件（FixedServerList / ServiceInstanceListSupplier），並將其注入 Spring Boot 專案以替代外部註冊中心進行靜態服務發現。  
  - 能觀察並理解 LoadBalancer 的刷新與更新流程，並依據觀察調整 HttpClient 的連線池與 keep-alive 策略，以提升高併發下的穩定性與效能。  
  - 理解 Joda Money 的序列化需求，並實作 MoneySerializer / MoneyDeserializer 避免 JSON 表現上的金額與幣別混淆。  
- 相關資源：[[Code/Chapter 13 服務熔斷/turbine-demo/README]]、[[98 | 如何定制自己的DiscoveryClient]]

【重點】從實作看懂 discovery -> server list -> load balancer 的資料流；連線管理對高併發效能的重要性。

#### 二、主體 — 概念、設計與實作細節

1) FixedDiscoveryClient：概念與實作要點  
- 目的與動機：適用於無外部註冊中心、單機測試或需靜態清單的場景（快速模擬服務拓撲）。  
- 必要方法與行為：getServices(), getInstances(serviceId), description()；支援 HealthIndicator 所需資訊。  
- 設定來源：application.yml 的 waiter.services（每行 host:port）轉為 DefaultServiceInstance 列表返回。  
- 邊界條件與驗證：解析 host:port 要嚴格驗證；若無目標 service，getInstances 應回傳空列表（非 null）。  

【重點】getInstances 回傳空列表而非 null，並對 host:port 做嚴格驗證。

2) FixedServerList / ServiceInstanceListSupplier：負載均衡端對接  
- 目的：把 discovery client 的 instance 轉為 LoadBalancer/ Ribbon 可用的 Server 或 ServiceInstance 列表（或回傳 Flux/Mono）。  
- 實作重點：在 getUpdatedListOfServers（或對應方法）呼叫 discoveryClient.getInstances(serviceId)，將 host:port 轉為 Server/ServiceInstance。  
- 刷新考量：LoadBalancer 會週期性刷新，實作需能在刷新時回傳最新清單；加強 debug 日誌以觀察更新時序。  

【重點】支援 LoadBalancer 的定時刷新或即時查詢，並記錄更新日誌。

3) 注入與啟動流程  
- 注入方式：於 @Configuration 或 application 類別以 @Bean 註冊 FixedDiscoveryClient 與 FixedServerList，或使用 @Component。  
- 啟動時序：LoadBalancer 初始化或需要時會呼叫 server list / supplier 的更新方法；Ribbon 會調用 getUpdatedListOfServers 並定時刷新。  
- 防錯：getInstances 不得回傳 null；妥善處理不合法配置並記錄錯誤。  

【重點】Bean 註冊順序與 LoadBalancer 初始化時機為 debug 關鍵點。

4) HttpClient 與連線管理（效能優化）  
- 目的：降低建立連線成本、提升吞吐。  
- 建議設定（視情境調整）：總最大連線數 200、每路由最大 20；connect timeout 100 ms、response timeout 500 ms；閒置連線清理 30 s；使用 CustomConnectionKeepAliveStrategy 根據 header 動態決定 keep-alive。  
- 調整原則：根據服務延遲與流量調整，過短會頻繁重連，過長則浪費資源。  
- 測試方法：使用 curl/wrk/JMeter 等工具觀察連線池使用率、平均響應時間與錯誤率，逐步微調。  

【重點】以監控與壓力測試驗證每次調整效果。

5) 貨幣處理（Joda Money）  
- 功能：使用 Joda Money 表示金額與貨幣單位，避免浮點精度與單位混淆。  
- 序列化要點：實作 MoneySerializer / MoneyDeserializer，把 Money 序列化為 { amount, currencyCode }，即使預設為 TWD 也應輸出 currencyCode。  

【重點】明確序列化格式以避免幣別或精度錯誤。

#### 三、實戰演示 — 教學步驟（實作流程）

1) 環境確認  
- Java 21、Maven 3.6+；啟動 waiter-service（範例 localhost:8080）；取得範例專案：[[Code/Chapter 13 服務熔斷/turbine-demo/README]]

2) 啟動 customer-service 並注入自定義元件  
- 編輯 application.yml，確認 waiter.services 含 localhost:8080（每行 host:port）  
- 註冊 FixedDiscoveryClient 與 FixedServerList 的 @Bean  
- mvn spring-boot:run 或 mvn clean package && java -jar  
- 開啟 debug 日誌：觀察 FixedDiscoveryClient 與 LoadBalancer 初始化呼叫

3) Debug / 斷點觀察（建議斷點）  
- 在 FixedDiscoveryClient.getInstances 與 FixedServerList.getServers（或 getUpdatedListOfServers）下斷點，觀察初始化、第一次調用與定時刷新時機。  
- 測試變更：修改 application.yml 的服務清單（新增/移除 host:port），觀察刷新是否反映（若實作檔案變更監聽則會即時反映）。

4) 壓力測試與 HttpClient 調整驗證  
- 施加大量請求（curl/wrk/JMeter），觀察連線池使用率、平均響應時間與錯誤率；調整 pool、keep-alive、超時並比對效果。

5) 常見問題排查步驟  
- 無法發現服務：檢查 waiter-service 是否啟動、application.yml 格式、getInstances 回傳是否為空列表。  
- LoadBalancer 未更新：檢查是否有定時刷新或事件驅動；以 debug 確認 getUpdatedListOfServers 是否被呼叫。  
- 非預期錯誤日誌：檢查 host:port 解析與例外處理，並增加日誌協助追蹤。

【重點】以可觀察（充分日誌、斷點）與可測試（壓力測試）方式驗證設計。

#### 四、課程小結與後續展望

- FixedDiscoveryClient vs 動態註冊中心差異：  
  - FixedDiscoveryClient：優點是簡單、可控、適合開發與測試；缺點是需手動維護、無自動擴縮與健康檢查。  
  - 動態註冊中心（Eureka/Consul）：優點為自動註冊/註銷、健康檢查、動態發現；缺點為需額外基礎設施與更多運維。  
- 建議：開發／測試期間可使用 FixedDiscoveryClient；生產環境建議採用成熟註冊中心以確保可用性與自動化管理。  
- 後續章節預告：下一章將介紹「多資料源（Multiple DataSources）」，包含 Spring Boot 中配置多個資料庫、事務管理與 repository 切換。

【重點】依使用情境選擇適合的 discovery 策略。

#### 五、Tips（教學小撇步與常見防範）

- host:port 解析要嚴格驗證以避免啟動錯誤。  
- 回傳空列表而非 null，讓呼叫端能處理「無服務」情況。  
- 若需模擬變更，可把 waiter.services 放外部檔案並實作檔案變更監聽以自動刷新。  
- 調整 LoadBalancer 刷新頻率時要平衡即時性與系統負荷。  
- 在自定義組件加入充分日誌（INFO/DEBUG），方便追蹤呼叫時間點與回傳內容。  
- 使用 dependencyManagement 統一 Spring Boot / Spring Cloud 版本，避免相容性問題。  
- 每次改動 HttpClient 參數都配合壓力測試與監控驗證效果。

【重點】以「可觀察、可重現、可測試」為設計原則。

參考資源與延伸閱讀：[[Code/Chapter 13 服務熔斷/turbine-demo/README]]、[[98 | 如何定制自己的DiscoveryClient]]、Spring Cloud LoadBalancer 文件、Spring Boot 官方文件、Apache HttpClient 5 文件

如果你需要，我可以進一步將其中任一項輸出為：
1. 投影片大綱（教案導向）  
2. 示範程式碼範本（FixedDiscoveryClient、FixedServerList、ServiceInstanceListSupplier）  
3. HttpClient 設定範例（含 CustomConnectionKeepAliveStrategy）  
4. Money Serializer / Deserializer 範例  
5. 可直接貼入專案的 application.yml 範例

請選擇你要的項目（或告訴我要以哪種格式/細節深度），我會依序產出。

---
### 99 | SpringBucks實戰項目進度小結
#### 一、課程目標

- 學習重點與實務意義：
  - 【重點】理解Spring Cloud中「服務註冊（Service Registry）」與「服務發現（Discovery）」的角色與關係。
  - 【重點】比較與實作常見註冊中心：Eureka、Zookeeper、Consul、Nacos（阿里巴巴提供）。
  - 【重點】掌握服務間呼叫的兩種常見方式：RestTemplate/RestAmbit（手動式）與 OpenFeign（宣告式），並比較優缺點。
  - 【重點】理解負載平衡元件Ribbon的用途、擴充點與實作方式（自訂ServerList/ServerPredicate等）。
  - 【重點】認識Spring Cloud中抽象層（DiscoveryClient、ServiceRegistry、LoadBalancer/BalanceGrant）的責任分工，便於後續擴充與除錯。
- 實作資源（建議練習）：
  - 官方文件：Spring Cloud、Eureka、Zookeeper、Consul、Nacos、Ribbon、OpenFeign（請依組織或課程提供連結）。
  - 範例專案：準備兩個微服務（Waiter Service、Personal Service），分別註冊到不同註冊中心並互相呼叫。
  - 開發環境：Java 11+/Spring Boot、Maven/Gradle、Postman 或 curl 供測試呼叫。
- 推薦練習步驟：
  1. 啟動一個註冊中心（例如Eureka）。
  2. 將 Waiter Service 註冊到該中心。
  3. 啟動 Personal Service，使用 RestTemplate 呼叫 Waiter，觀察服務發現與呼叫流程。
  4. 將呼叫改為 OpenFeign，感受程式碼簡潔度差異。
  5. 啟動另一個註冊中心（Zookeeper/Consul/Nacos），重複上述步驟，比較差異。

#### 二、主體 — 服務註冊與發現核心概念

- 服務註冊（Service Registry）與服務發現（Discovery）
  - 說明：服務註冊負責把服務實例資訊（IP、port、metadata）登記到中央註冊中心；服務發現則讓消費方查詢可用實例清單。
  - 【重點】分工：註冊（Service Registry） vs 發現（DiscoveryClient / Discovery Grant）。
  - 比喻：註冊中心如電話簿，Service Registry是把自己的號碼登記上去，DiscoveryClient是查電話本的人。

- 常見註冊中心介紹（Eureka / Zookeeper / Consul / Nacos）
  - Eureka：Netflix 生態系常用，與Spring Cloud整合度高、用於雲端環境；具備自帶心跳機制與緩存機制。
  - Zookeeper：分散式協調服務，強一致性，常用於需要嚴謹狀態管理的場景。
  - Consul：支援健康檢查、key/value 存儲與服務網格整合，運營友好。
  - Nacos：阿里巴巴提供，支援服務註冊發現與配置管理，對國內使用者友好。
  - 【重點】選擇依據：一致性需求、運維可用性、功能（比如健康檢查、KV、配置管理）與團隊習慣。

- Spring Cloud 抽象層：DiscoveryClient 與 ServiceRegistry
  - 說明：Spring Cloud 將底層註冊中心封裝成抽象介面，應用程式透過統一API（DiscoveryClient）進行發現，降低耦合。
  - 實務意義：日後若要替換註冊中心，只需變更依賴與設定，而非大量改動業務代碼。
  - 【重點】建議練習：閱讀各註冊中心實作的 DiscoveryClient/ServiceRegistry 代碼或官方文件，理解差異與限制。

- 負載平衡：Ribbon（Balance Grant）
  - 說明：Ribbon 提供客戶端負載平衡策略（如RoundRobin、Random、Weighted），能在呼叫端選擇目標實例。
  - 擴充性：可自訂 ServerList（哪裡拿到伺服器列表）、ServerPredicate（過濾邏輯）、LoadBalancerRule（選擇策略）。
  - 範例：透過自訂策略實現「同機房優先」或「根據響應時間選擇」等智慧路由。
  - 【重點】注意：Ribbon 是客戶端負載平衡，與服務端的反向代理（如NGINX）概念不同。

- 服務呼叫方式比較：RestTemplate（或RestAmbit） vs OpenFeign
  - RestTemplate（手動式）：
    - 優點：控制細節多，適合需要自訂HTTP層處理的情境。
    - 缺點：大量樣板碼（URL拼接、序列化、錯誤處理），較繁瑣。
  - OpenFeign（宣告式）：
    - 優點：以介面宣告HTTP呼叫，程式碼簡潔、可與Ribbon整合自動做負載平衡（Feign + Ribbon）。
    - 缺點：抽象較高，除錯時需注意輸出與攔截點；某些客製化情況需額外擴展。
  - 【重點】實務建議：一般情況用Feign能讓代碼更輕薄；需要低階自訂則採RestTemplate或WebClient。

- 小結過渡：
  - 到此我們已建立「註冊中心、發現機制、負載平衡與呼叫方式」的整體觀念，接下來將進入實作演示，以鞏固理解。

#### 三、主體 — 實作細節與常見問題

- 將服務註冊到不同註冊中心（實作重點）
  - 流程：在 Service application.properties/yml 中設定對應的註冊中心端點與啟用註冊開關，包含健康檢查路徑與metadata。
  - 注意點：同一服務切換不同註冊中心時，要確認依賴（starter）與設定檔一致，例如使用 Eureka 需加入 spring-cloud-starter-netflix-eureka-client。
  - 常見錯誤：
    - 未正確設定心跳或TTL，導致服務被註銷。
    - 註冊中心與客戶端版本不相容，導致註冊失敗。
  - 【重點】測試註冊是否成功可透過註冊中心UI或DiscoveryClient列出實例。

- Personal Service 呼叫 Waiter Service（示範流程）
  - 步驟（RestTemplate）：
    1. Personal Service 透過 DiscoveryClient 查詢 Waiter Service 實例清單。
    2. 選取目標實例（若搭配Ribbon則由Ribbon選擇）。
    3. 使用 RestTemplate 向該實例發送請求。
  - 步驟（OpenFeign）：
    1. 定義介面並加上註解（@FeignClient(name = "waiter-service")）。
    2. 由Feign與Ribbon協同完成服務位置解析與負載平衡。
  - 實務比較：
    - 使用Feign時，呼叫端不需手動處理URL或DiscoveryClient呼叫，程式碼更簡潔。
    - 若需要在呼叫前做複雜的重試或自訂請求邏輯，RestTemplate 會較靈活。
  - 【重點】示範應包含：開啟多個Waiter實例觀察Ribbon選擇、測試故障轉移行為。

- Ribbon 的擴充與自訂範例
  - 常見自訂點：
    - 自訂負載平衡規則（LoadBalancerRule）：根據回應時間或權重選擇伺服器。
    - 自訂ServerList：從非傳統來源（例如KV存儲或外部API）取得服務實例。
  - 實作提示：在Spring Boot中以@Bean注入自訂Rule或ServerList，搭配@Configuration生效。
  - 【重點】測試擴充需模擬不同實例的差異（延遲、錯誤率）來驗證策略效果。

- 常見運營/除錯技巧
  - 檢查註冊中心UI與日誌，確認health-check與heartbeat。
  - 使用可觀測性工具（如Sleuth / Zipkin / Prometheus）來追蹤分散式呼叫路徑。
  - 異常排查流程：1) 註冊正常？ 2) Discovery 能列到？ 3) 負載平衡策略是否過濾掉實例？ 4) 真實呼叫是否被網路或防火牆阻擋。
  - 【重點】將日誌與追蹤串聯，能快速定位問題所在。

#### 四、實戰演示（教學腳本指引）

- Demo 目標：
  - Show：將 Waiter Service 分別註冊到 Eureka、Zookeeper、Consul、Nacos，並由 Personal Service 發現並呼叫。
  - 比較：同一呼叫流程下，RestTemplate 與 OpenFeign 的程式碼差異與執行效果。
  - 延伸：在 Ribbon 上實作自訂選擇策略並觀察效果。

- Demo 步驟（建議時間分配）
  1. 5 分鐘：啟動單一註冊中心（Eureka），展示其 UI 與已註冊的 Waiter 實例。
  2. 10 分鐘：使用 RestTemplate 在 Personal Service 呼叫 Waiter，並示範DiscoveryClient查詢流程（顯示程式碼片段）。
  3. 10 分鐘：改用 OpenFeign，示範介面宣告與呼叫，強調程式碼減少的部份，執行並比對日誌。
  4. 10 分鐘：啟動多個 Waiter 實例，示範 Ribbon 的負載平衡（RoundRobin 與自訂策略），觀察請求分配情況。
  5. 5 分鐘：將 Waiter 分別註冊到其他註冊中心（Zookeeper/Consul/Nacos），展示配置差異與需要變動的地方。
  6. 5 分鐘：QA 與課堂討論（收集學生在整合不同註冊中心、版本相容上的疑問）。
- 示範程式碼提示（口述）：
  - RestTemplate 範例：建立DiscoveryClient → 取得instances → 選擇一個URL → restTemplate.exchange(...)
  - Feign 範例：
```
@FeignClient(name="waiter-service") public interface WaiterClient { @GetMapping("/menu") List menu(); }
```
- Demo 要點提示：
  - 務必開啟日誌等級（DEBUG）以觀察Ribbon選擇與Feign調用過程。
  - 在多註冊中心情境，注意每個註冊中心的依賴與設定差異，避免產生混淆。
#### 五、課程小結與後續展望

- 小結（兩種呼叫方式比較）
  - RestTemplate（手動式）
    - 優點：細節掌控較多、靈活性高。
    - 缺點：樣板碼多、開發效率較低。
  - OpenFeign（宣告式）
    - 優點：程式碼簡潔、與Ribbon等整合方便、開發效率高。
    - 缺點：抽象層較高、除錯時需注意攔截器與序列化細節。
  - 【重點】選擇建議：若以快速開發與可維護性為主，OpenFeign 為首選；若需高度自訂或底層控制，採用 RestTemplate/WebClient。
- 註冊中心比較總結（簡要）
  - Eureka：易用、與Spring Cloud整合好。
  - Zookeeper：強一致性，適合需要協調的場景。
  - Consul：更完整的運維支持（健康檢查、KV）。
  - Nacos：註冊+配置管理整合良好，國內生態友好。
- 後續章節預告
  - 下一章將介紹「多資料源配置」，涵蓋多個資料庫連線管理、事務邊界與在微服務架構下的資料一致性思維（如分散式事務、Eventual Consistency）。

#### 六、Tips

- 【Tip】版本管理很重要：註冊中心與Spring Cloud版本不相容會導致難以偵錯的問題。
- 【Tip】先在本地或測試環境把註冊-發現-呼叫流程跑通，再上雲端或容器化部署。
- 【Tip】使用Feign時，若需要攔截或添加Header，可透過Feign攔截器或自訂Configuration注入。
- 【Tip】Ribbon雖方便，但市面上有趨勢以Spring Cloud LoadBalancer或服務網格（Istio/Linkerd）取代，學習Ribbon概念有助理解替代方案。
- 【Tip】實作時務必加入健康檢查與合理的timeout/retry設定，避免單一失敗導致瀑布效應。

如果你要，我可以幫你把示範程式碼範本（RestTemplate 與 OpenFeign 範例、Ribbon 自訂策略）整理成可直接貼到專案的檔案，或把本講義轉成投影片逐頁呈現。你想先看哪一部分？

---
# Chapter 13：服務熔斷 (7講)
### 100 | 使用Hystrix實現服務熔斷（上） ― [circuit-break-demo,Chapter 12-consul-waiter-service]
根據提供的資料，我幫你整理出一份完整的教學講義：

#### 一、課程目標

本章節將介紹服務熔斷（Circuit Breaker）模式，這是微服務架構中關鍵的容錯機制。學習重點包括：
- 理解服務熔斷的概念與重要性
- 掌握使用 Spring AOP 實現自定義熔斷器的方法
- 學會配置與調整熔斷器參數
- 實際演練熔斷保護機制的運作

重點：本課程採用實作導向，將以實際範例展示如何在 Spring Boot 專案中實現熔斷保護。

#### 二、服務熔斷基礎概念

服務熔斷模式源自於 Martin Fowler 的設計模式，主要用於：
- 防止系統級聯故障
- 快速失敗並提供降級服務
- 自動恢復服務

熔斷器有三種狀態：
1. 關閉（Closed）：正常運作狀態
2. 開啟（Open）：觸發熔斷保護狀態
3. 半開（Half-Open）：嘗試恢復服務狀態

提示：可以將熔斷器想像成電路保險絲，當電流過大時自動斷開以保護整個系統。

#### 三、專案架構與技術棧

本專案使用的核心技術：
- Spring Boot 3.2.4
- Spring Cloud 2023.0.1
- Spring AOP
- Consul 服務註冊中心
- OpenFeign 服務調用

專案特色：
- 自定義熔斷器實作
- 完整的監控與日誌機制
- 靈活的熔斷策略調整

#### 四、熔斷器核心實作

重點程式碼解析：

```java
@Around("execution(* tw.fengqing.spring.springbucks.customer.integration..*(..))")
public Object doWithCircuitBreaker(ProceedingJoinPoint pjp) throws Throwable {
    // 取得方法簽名
    String signature = pjp.getSignature().toLongString();
    
    // 檢查失敗次數
    if (counter.get(signature).get() > THRESHOLD &&
        breakCounter.get(signature).get() < THRESHOLD) {
        return null;  // 觸發熔斷保護
    }
    
    try {
        Object retVal = pjp.proceed();
        // 重置計數器
        counter.get(signature).set(0);
        return retVal;
    } catch (Throwable t) {
        // 增加失敗計數
        counter.get(signature).incrementAndGet();
        throw t;
    }
}
```

範例：熔斷器的工作流程就像是一個自動保險絲，當發現異常超過閾值時，自動切斷服務調用。

#### 五、實戰演示

操作步驟：

1. 環境準備：
```bash
# 啟動 Consul
docker run -d --name consul -p 8500:8500 consul:latest

# 啟動應用
mvn spring-boot:run
```

2. 測試場景：
- 正常調用測試
- 服務不可用測試
- 服務恢復測試

提示：觀察日誌輸出，特別注意熔斷器狀態的變化。

#### 六、課程小結與後續展望

本課程重點回顧：
- 熔斷器的基本概念與重要性
- 使用 Spring AOP 實現自定義熔斷保護
- 實際操作與測試熔斷機制

下一章預告：
我們將介紹如何使用 Hystrix 框架實現更完整的熔斷功能。

#### 七、實務建議

1. 熔斷器配置建議：
- 根據業務特性設定適當的失敗閾值
- 配置合理的超時時間
- 實作有意義的降級邏輯

2. 監控與維護：
- 定期檢查熔斷日誌
- 建立熔斷事件監控機制
- 定期調整熔斷策略

提示：在實際應用中，建議從小範圍開始測試，逐步擴大熔斷器的使用範圍。

---
### 101 | 使用Hystrix實現服務熔斷（下）  ― [hystrix-customer-service, Chapter 12-consul-waiter-service]
#### 一、課程目標

本章節目標是讓學生了解並能實作基於 Netflix Hystrix 的服務熔斷與降級機制，掌握與 AOP 基礎實作的差異、常見配置選項與運行時行為，並能在 Spring Cloud 生態中整合 Hystrix 與 Feign 來保護服務穩定性。

- 學習重點：
  - 【重點】理解熔斷器模式（Circuit Breaker）的基本概念與作用
  - 【重點】掌握 Hystrix 在方法級別與 Feign 客戶端上的使用方式（@HystrixCommand、@FeignClient fallback）
  - 【重點】辨識 Hystrix 的執行隔離（Execution Isolation）與超時等核心配置，以及何時使用 thread pool 或 semaphore
  - 【重點】實作有意義的 fallback 邏輯，並將其與系統監控整合（Actuator、Hystrix stream）
- 實務意義：
  - 在依賴服務不可用或延遲時提供可預期的系統行為，避免「雪崩效應」
  - 透過合理的降級策略維持使用者體驗與系統可用性
- 相關資源（建議學生實機操作與練習）：
  - [[101 | 使用Hystrix实现服务熔断（下）]]
  - hystrix-customer-service 專案（已包含範例程式碼與設定）路徑：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/hystrix-customer-service/README.md]]
  - 官方文件：Netflix Hystrix Wiki（README 內亦有連結）
  - Spring Cloud Hystrix 與 OpenFeign 文件（README 參考）

#### 二、熔斷器模式回顧與比較（AOP vs Hystrix）

首先回顧熔斷器的目的與動機：當 downstream 服務不穩定或不可用時，熔斷器可避免耗費過多資源等待失敗呼叫，並提供迅速的降級回應，保護整體系統。

- AOP 實作（先前章節）：
  - 作法：以切面攔截呼叫，統一處理例外與返回預設值。
  - 優點：實作簡單、對單一方法或一類方法快速套用。
  - 缺點：比較「粗暴」，缺乏細粒度的隔離策略與度量監控，較難處理執行隔離或超時控制。
  - 【重點】AOP 適合簡單降級，但不適合需要細緻隔離與監控的生產環境。
- Hystrix（Netflix 提供的成熟方案）：
  - 作法：用 @HystrixCommand 為方法加上熔斷與 fallback，或在 Feign 客戶端指定 fallback 類別。
  - 優點：支援執行隔離（thread / semaphore）、超時控制、命令屬性配置、監控（stream / dashboard）。
  - 缺點：Netflix 已宣告不再維護 Hystrix，後續有其他替代方案（如 Resilience4j）；但 Hystrix 概念與配置仍具教學與實作價值。
  - 【重點】Hystrix 提供更細緻的行為控制與監控，是生產環境常見選擇之一（歷史上廣泛使用）。

過渡：了解二者差異後，我們接著看 Hystrix 在 Spring Cloud 專案中的實際整合與程式範例。

#### 三、Hystrix 在 Spring Cloud 的整合（概念與程式範例解說）

1) 啟用與相依
- 在 pom.xml 加入 spring-cloud-starter-netflix-hystrix（或 Spring Cloud 的 starter），並確保 Spring Boot / Spring Cloud 版本相容（範例使用 Spring Boot 2.1.4、Greenwich.SR1）。
- 在主類或配置類上加入 @EnableCircuitBreaker；若使用 Feign，需在設定中啟用 feign.hystrix.enabled=true。
- 【重點】依賴與版本正確性是成功啟動 Hystrix 的關鍵。

2) 方法級別熔斷（@HystrixCommand）
- 範例：
  - 在某個需要保護的方法上加 @HystrixCommand(fallbackMethod = "fallbackCreateOrder")
  - fallback 方法需與原方法簽名相容（參數與回傳型別相容或可替代）
- 行為說明：
  - 當原方法失敗、拋例外或超時時，Hystrix 會切換到 fallback 方法，快速返回預期結果或預設值。
- 【重點】fallback 方法簽名必須相容；fallback 應回傳有意義的降級回應（例如空清單、預設錯誤物件）。

3) Feign 客戶端熔斷（fallback 類別）
- 範例：
  - @FeignClient(name = "waiter-service", contextId = "coffee", fallback = FallbackCoffeeService.class)
  - FallbackCoffeeService 實作與原介面相同的方法，提供降級邏輯。
- 行為說明：
  - 當 Feign 呼叫失敗或被 Hystrix 熔斷時，會使用 fallback 類別的實作。
- 【重點】Feign + Hystrix 的組合讓遠端呼叫具有一致的降級與隔離策略。

4) 執行隔離與執行策略（Execution Isolation）
- Hystrix 支援兩種主要隔離：thread pool（預設）與 semaphore。
  - thread pool 隔離可避免呼叫阻塞主執行緒，並能針對服務建立獨立併發控制。
  - semaphore 較輕量，適用於非阻塞或少量延遲情境。
- 可透過 CommandProperties 調整超時、thread pool 大小、熔斷閾值等。
- 【重點】選擇隔離策略時需考量延遲行為與資源使用；thread pool 能保護主執行環境但有額外資源成本。

5) Hystrix 的執行位置與行為觀察
- HystrixCommand 預設在不同的執行緒隔離池（thread pool）中執行，因此其日誌或輸出可能出現在不同的執行緒或端口上（錄音中有示例說明）。
- 監控可透過 actuator 的 hystrix.stream 與 Hystrix Dashboard 觀察熔斷命中、執行延遲與 fallback 次數。
- 【重點】遇到「看不到日誌或追蹤不到執行緒」的情況時，記得檢查是否啟用 thread pool 隔離導致日誌分散。

過渡：理解概念之後，我們透過專案範例示範如何實作與測試。

#### 四、實戰演示（以 hystrix-customer-service 為例）

準備步驟（建議學生跟著做）：
1. 取得範例程式碼並進入專案資料夾
   - 參考 README 的快速開始步驟
2. 設定環境：
   - Java 11、Maven，啟動 Consul（預設 localhost:8500）
   - 若遇到 Java 編譯問題，設定 MAVEN_OPTS（README 提供指令）
3. 執行 customer service（port 8090）與 waiter service（服務提供者），或先僅啟動 customer 並模擬 waiter 不可用測試 fallback

演示流程與重點驗證：
- 呼叫 GET /customer/menu（當 waiter 未啟動時，觀察 Hystrix fallback 回傳空清單）
  - 觀察日誌：Hystrix 的 fallback 方法日誌可能顯示在不同執行緒上（customer controller 的 thread 與 Hystrix thread pool）
  - 驗證行為：HTTP 回應為預期降級值
- 呼叫 POST /customer/order（測試方法級別 @HystrixCommand 的 fallback）
  - 觀察 fallbackCreateOrder 是否被呼叫，並確認回傳 null 或預設值
- 啟動 Waiter Service 並再度呼叫，確認系統會回到正常路徑
- 監控：
  - 開啟 actuator/health 查看健康狀態
  - 開啟 actuator/hystrix.stream 並用 Hystrix Dashboard 或其他工具觀察熔斷事件、命令延遲與 fallback 次數

實作提示：
- 若在 controller 或 fallback 類別中加上 @RequestMapping，可能會影響 fallback 行為（錄音中提到避免在結果類上加 RequestMapping），實際操作時務必小心路由配置與註解位置。
- 測試時可調整 Hystrix 的超時與 thread pool 設定，觀察熔斷觸發條件的變化。

#### 五、配置細節與最佳實務

- 超時配置（TML / timeout）
  - 預設通常為 1000 ms（視版本與配置而定），可在 hystrix.command.* 或客製化 command properties 中調整
  - 【重點】合理設定超時，避免過短導致頻繁降級，或過長造成系統資源被占用
- Thread Pool / Semaphore 大小設定
  - 根據服務負載與延遲特性配置，不同服務可使用不同 pool
- 有意義的 fallback 邏輯
  - 避免只回傳 null 或空，應提供可用的替代資料或清楚的錯誤回應，便於上層處理與監控
- 監控與告警
  - 定期檢查 Hystrix stream 與 Dashboard，若熔斷頻繁要檢查下游服務原因或調整閾值
- 版本與替代方案考量
  - 注意 Netflix 已不再維護 Hystrix，生產環境可評估 Resilience4j 等替代方案，但原理與設計仍然參考價值

#### 六、課程小結與後續展望

- 總結兩種配置方式差異與優缺點：
  - AOP：
    - 優點：實作快速、簡單
    - 缺點：缺少隔離、監控與精細控制，不適合複雜或高要求的生產環境
  - Hystrix：
    - 優點：提供隔離策略、超時控制、廣泛的監控支持與豐富配置
    - 缺點：已由 Netflix 停止維護，未來需關注替代方案（但仍為學習熔斷器模式的重要教材）
- 【重點】實務上應依系統需求選擇方案：簡單場景可用 AOP 快速上手；需要生產級容錯、觀測與隔離時，採用 Hystrix（或其替代方案）會更合適。
- 後續章節預告：
  - 下一章節將介紹「多數據源配置」，將探討如何在 Spring 應用中同時管理多個資料庫連線與交易邊界，銜接服務容錯後的資料一致性問題。

#### 七、Tips

- 【Tip】fallback 方法簽名必須與原方法相容，否則 Hystrix 無法正確呼叫 fallback。
- 【Tip】避免在 fallback 類上錯誤地加入 @RequestMapping，可能導致路由或行為異常。
- 【Tip】使用 Hystrix 時同時啟用監控（actuator + hystrix.stream），能協助迅速定位熔斷原因。
- 【Tip】考慮未來維護與社群支持度：Hystrix 雖功能完整，但請評估是否改用 Resilience4j 等現行活躍專案。
- 【Tip】在本地測試熔斷場景時，刻意關閉下游服務（或模擬延遲）是最直接的測試方式。

---
### 102 | 如何觀察服務熔斷  ― [hystrix-dashboard-demo, hystrix-stream-customer-service, Chapter 12-consul-waiter-service, turbine-demo]
#### 一、課程目標

- 說明本章節學習重點：理解 Hystrix 熔斷器如何產生監控資料、如何透過 Hystrix Dashboard 直接觀察單一服務的流（Hystrix Stream），以及如何使用 Turbine 聚合多個實例/服務的 Hystrix Stream 以達到集中監控。  
- 實務意義：當微服務出現延遲或故障時，能即時觀察熔斷器狀態、判斷是否觸發降級，並將監控資料整合到現有監控系統以做告警與追蹤，降低故障擴散風險。  
- 相關資源（供學生實作與閱讀）：
  - Hystrix Dashboard 範例：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/hystrix-dashboard-demo/README.md]]
  - Hystrix Stream 客戶服務範例：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/hystrix-stream-customer-service/README.md]]
  - Turbine 聚合範例：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/turbine-demo/README.md]]

#### 一、主體 — 熔斷觀察的基本概念與流程

[重點] 熔斷觀察的三個層次：本地日誌、Hystrix Stream、Turbine 聚合

在開發或測試階段，最原始的觀察方式是透過程式內的日誌與 AOP 打點來偵測是否走到 fallback。但在分散式環境中，單靠日誌很難快速掌握整體情況，因此需要兩種更直觀的方式：

1. Hystrix Stream（單服務即時流）
   - 概念：每個使用 Hystrix 的應用會輸出一個實時的 metrics stream（例如 /actuator/hystrix.stream），內容包含錯誤率、請求數、latency 分佈、是否開啟熔斷等欄位。
   - 使用場景：單一服務或個別實例的即時排查與視覺化。
   - 優勢：[重點] 圖形化、即時、實作簡單（加入依賴並開啟 endpoint）。
   - 侷限：[重點] 若服務為多實例或多服務，需在 Dashboard 中分別加入多條 stream，不易集中管理。

2. Turbine（多服務/多實例的聚合）
   - 概念：Turbine 會從服務註冊中心（例如 Consul、Eureka）取得多個 Hystrix Stream 的來源，將多個實例/服務的資料聚合成一個統一的 stream，供 Hystrix Dashboard 或其他監控服務讀取。
   - 使用場景：集群環境、需要統一監控入口、降低 Dashboard 設定成本。
   - 優勢：[重點] 自動聚合、便於集中監控與儀表板展示。
   - 侷限：[重點] 需額外部署 Turbine、注意效能與高可用性設計。

過渡：理解這兩者的差異後，接下來說明如何把它們整合到日常監控流程，以及實作步驟。

#### 一、主體 — Hystrix Stream 的結構與關鍵指標

[重點] 必讀指標與含義

- isCircuitBreakerOpen：熔斷器是否開啟（true 表示已打開，會短路請求）
- errorPercentage：錯誤率百分比（用來判斷是否超過閾值）
- requestCount：滑動視窗內總請求數（影響統計可靠性）
- rollingCountSuccess / rollingCountFailure：成功/失敗請求次數
- latencyExecute_mean、latencyTotal_mean：延遲平均值與分位資訊

說明：Hystrix 在內部用一個滑動視窗計算錯誤率與請求量，當錯誤率超過設定（例如 50%）且 requestVolumeThreshold（例如 10）條件滿足時，熔斷器會打開。Hystrix Stream 會把這些資訊以 JSON 事件串流輸出，Dashboard 依據這些資料畫出圓環圖、時間序列與狀態標示。

比喻：把 Hystrix 當作心臟監視器，stream 就是心電圖即時輸出；Turbine 則像 ICU 的中央監控，能同時監視多個病人的心電圖。

#### 一、主體 — 實作架構與配置重點

[重點] 實作流程總覽（以範例專案為例）

1. 啟動服務註冊中心（範例使用 Consul）
   - 範例命令（Docker）：docker run -d --name consul -p 8500:8500 consul:latest
2. 啟動 Hystrix Stream 客戶服務（範例：hystrix-stream-customer-service，預設 port 8090）
   - 確認 /actuator/hystrix.stream 可讀取
3. 啟動 Hystrix Dashboard（範例：hystrix-dashboard-demo，預設 port 9090）
   - 在 Dashboard 輸入單一 stream URL（例如 http://localhost:8090/actuator/hystrix.stream），設定刷新間隔（建議 2 秒）
4. 啟動 Turbine（若需聚合，範例 turbine-demo，預設 port 9000）
   - 在 Turbine 設定中指定 turbine.aggregator.cluster-config 與 turbine.app-config（例如 customer-service, waiter-service）
   - 在 Dashboard 中使用 Turbine 的 stream（例如 http://localhost:9000/turbine.stream?cluster=customer-service）

配置重點（常見設定）：
- Hystrix Command 設定閾值：
  - requestVolumeThreshold、errorThresholdPercentage、sleepWindowInMilliseconds
- Feign/HTTP 客戶端設定超時，避免等待導致長尾延遲
- Actuator 與 hystrix.stream endpoint 開啟與路徑確認

過渡：了解配置後，接下來實際演示可以看到的畫面與如何判斷問題。

#### 一、實戰演示

- 目標：示範從單一服務 stream 到 Turbine 聚合的觀察流程，並模擬錯誤觸發熔斷
- 步驟：
  1. 啟動 Consul、啟動 Customer Service（含 Hystrix）、啟動 Waiter Service（被呼叫的下游）  
  2. 在 Customer Service 中透過做大量失敗請求或直接讓 Waiter Service 回 500，觀察 /actuator/hystrix.stream 的變化（errorPercentage、requestCount、isCircuitBreakerOpen）  
  3. 在 Hystrix Dashboard 加入 Customer 的 stream，觀察圓環圖變化與狀態顏色（綠＝成功、紅＝失敗）  
  4. 啟動 Turbine 並將 Dashboard 指向 Turbine 的聚合 stream，觀察多實例/多服務的聚合效果  
- 示範要點：
  - [重點] 在熔斷器開啟時，Dashboard 會顯示大量的 Failure 與高 errorPercentage，並且 isCircuitBreakerOpen 會轉為 true  
  - [重點] Turbine 能把多個實例的 stream 合併，Dashboard 顯示的就是整體健康情況，避免逐個加入 stream 的繁瑣
- 常見操作檢查：
  - 如果 stream 空白，先檢查目標服務是否有啟用 Hystrix 並暴露 /actuator/hystrix.stream  
  - 若 Turbine 無法聚合，確認服務註冊中心（Consul/Eureka）登記狀態與配置是否匹配

#### 一、課程小結與後續展望

- 小結（兩種配置差異與優劣）：
  - Hystrix Dashboard 直接觀察單一 stream
    - 優點：[重點] 部署簡單、直觀、適合單一服務或開發測試環境  
    - 缺點：[重點] 多實例/多服務需要手動管理多個 stream，不利於運維集中化
  - Turbine 聚合
    - 優點：[重點] 能自動聚合多服務/多實例的 Hystrix Stream，適合生產環境的集中監控  
    - 缺點：[重點] 需額外部署 Turbine，需注意聚合效能與高可用性（在大量服務時需橫向擴展）
- 後續章節預告：下一章將介紹「多數據源配置」的內容，當我們在監控與資料存取層面有多個資料來源（例如多個資料庫）時，如何在 Spring 中安全且可維護地配置多資料源，並處理事務與路由問題。

#### 一、Tips

- 在生產環境避免直接把 hystrix.stream 以未驗證的方式暴露在公開網路上，建議在內網或透過反向代理與認證保護。  
- 設定合理的 Hystrix 閾值需根據實際流量與業務特性調整，不能一味套用範例值；建議先在測試環境做負載模擬再搬到生產。  
- Turbine 建議部署多個實例並放在負載均衡後方，以避免單點性能瓶頸。  
- 若需長期歷史資料與複雜告警，將 Hystrix 指標同步至 Prometheus/Grafana 或其他監控系統，再做告警策略比直接目視 Dashboard 更可用。  
- 常見排查順序：檢查服務健康 → 確認 Hystrix 與 Actuator 設定 → 檢查 stream 是否可取 → 檢查註冊中心與 Turbine 配置。

結語：本章目的在於讓你從程式日誌走向完整的即時監控流程，理解 Hystrix Stream 與 Turbine 的角色與搭配方式。下次課程我們會把重點放在多資料源配置，並示範如何在 Spring 中管理多個資料源與事務。若你在實作過程中遇到具體配置或錯誤訊息，歡迎把 log 或配置貼上來，我可以協助逐步排查。

---
### 103 | 使用Resilience4j實現服務熔斷  ― [resilience4j-circuitbreaker-demo, Chapter 12-consul-waiter-service]
#### 一、課程目標

- 課程目的：理解並能在 Spring Boot 微服務中使用 Resilience4j 實作熔斷（Circuit Breaker），包含程式化（programmatic）與註解式（annotation-based）兩種實作方式，掌握配置參數含義、監控與降級策略，並能在實務中選擇與調整熔斷策略以避免服務雪崩。  
- 實務意義：在分散式系統中，透過熔斷器保護核心服務避免局部故障擴散、降低系統整體風險，並在服務不可用時提供可預期的降級回應與快速恢復機制。  
- 相關資源（供實作與練習）：  
  - 專案示範：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/resilience4j-circuitbreaker-demo/README.md]]（Demo 專案、範例程式碼與操作說明）  
  - 參考文件：Resilience4j 官方文件、Spring Boot Actuator、Spring Cloud OpenFeign（連結請參考 README 中的參考資源）  
- [重點] 熟悉 Resilience4j 的模組化設計、兩種熔斷實作方式、主要配置參數與狀態（CLOSED / OPEN / HALF_OPEN）。

#### 二、主體 — Resilience4j 概念與技術要點

- Resilience4j 簡介與設計理念  
  - Resilience4j 是受 Hystrix 啟發但更輕量、模組化的容錯庫，設計上偏向 Java 函數式風格，可按需引入 circuitbreaker、rate limiter、bulkhead、retry、cache、timeout 等模組。  
  - [重點] 輕量（外部依賴少）、模組化（按需引入）、支援 Spring Boot 整合與監控輸出（Micrometer / Actuator）。  
  - 類比：把熔斷器想像成電路系統的斷路器，當下游故障「短路」時會自動斷開電路，避免整個建築熔斷。

- 熔斷器三種狀態（行為理解）  
  - CLOSED：正常，所有請求通過。  
  - OPEN：觸發熔斷後所有請求被短路或返回降級回應。  
  - HALF_OPEN：部分放行少量請求做健康檢測，若恢復則回到 CLOSED，否則回到 OPEN。  
  - [重點] 了解狀態轉換條件與等待時間（wait-duration-in-open-state）是調校熔斷行為的核心。

- 主要配置參數與含義（實務解釋）  
  - sliding-window-type, sliding-window-size：決定如何計算失敗率（時間窗或次數窗）。  
  - minimum-number-of-calls：在滑動視窗內至少要有多少次呼叫才會開始計算失敗率。  
  - failure-rate-threshold：失敗率超過多少百分比會觸發開路。  
  - wait-duration-in-open-state：開路狀態持續多久後進入半開測試。  
  - permitted-number-of-calls-in-half-open-state：半開時允許多少測試呼叫。  
  - [重點] 這些參數需依業務 SLA 與流量特性調整，非「一刀切」；在測試環境先做壓測與模擬故障驗證。

- 監控與整合（可觀測性）  
  - 使用 Spring Boot Actuator 與 Micrometer 輸出熔斷器狀態與 metrics（例：circuitbreaker 指標、failure rate、state）。  
  - 建議整合現有監控/警告系統（Prometheus/Grafana/Alertmanager）做告警與趨勢觀察。  
  - [重點] 熔斷器觸發應產生告警並納入運維流程，否則單純自動降級可能掩蓋問題。

- 常見問題與故障排除要點（實務導向）  
  - 熔斷器不觸發：檢查 minimum-number-of-calls 是否過高或失敗未被計為例外。  
  - 降級方法未執行：驗證 fallback 方法簽名是否正確與是否有循環依賴。  
  - Actuator 無法訪問：檢查 endpoint 與安全設定。  
  - [重點] 實際測試（模擬後端宕機）是驗證熔斷器是否正確生效的必要步驟。

#### 三、主體 — 兩種實作方式比較（程式化 vs 註解式）

- 程式化（programmatic）實作要點  
  - 範例說明：使用 CircuitBreaker.decorateSupplier() 將呼叫包裝（示範中 readMenu() 以 decorateSupplier 包裝 coffeeService.getAll()）。  
  - 優點：更靈活，可在程式中動態建立與控制 CircuitBreaker（例如根據環境或上下文動態選擇）。  
  - 缺點：程式碼侵入性較高，維護需要考量抽象化。  
  - 代碼重點：需處理 CallNotPermittedException（表示 CircuitBreaker 已開啟），以及其他例外的紀錄與重拋。  
  - [重點] 適合需要細粒度控制或動態建立熔斷器的場景。

- 註解式（annotation-based）實作要點  
  - 範例說明：在 createOrder() 上使用 @CircuitBreaker(name="order", fallbackMethod="fallbackCreateOrder")，並提供 fallbackCreateOrder 當降級邏輯。  
  - 優點：使用簡單、宣告式、與 Spring AOP 整合良好，方便快速上手。  
  - 缺點：較不適合需要動態控制或複雜邏輯的情況，且 fallback 簽名需嚴格符合要求。  
  - [重點] 適合典型業務方法的快速保護與統一配置管理。

- 實務比較（總結）  
  - 程式化：靈活、可動態、較多程式碼；適合高客製化需求。  
  - 註解式：簡潔、方便、維護性好；適合大多數常見情境。  
  - [重點] 在一個系統中可以混合使用：對於通用路徑用註解式，對於特殊或需要動態的用程式化。

#### 四、實戰演示（示範步驟與重點觀察）

- 環境準備（快速檢查）  
  - Java 21、Maven、（選用）Consul（若要測試服務發現）。  
  - 從專案根目錄執行 mvn clean compile 並 mvn spring-boot:run，確認 Actuator 健康檢查：curl http://localhost:8090/actuator/health

- 演示場景一：程式化熔斷器（Menu 端點）  
  - 操作步驟：先讓 waiter-service 在 8080 可用，呼叫 /customer/menu 確認正常；然後停止 waiter-service，連續呼叫幾次觀察行為。  
  - 觀察要點：前幾次會出現連線錯誤，當 failure-rate 與 minimum-number-of-calls 達成條件時，CircuitBreaker 進入 OPEN，此後回傳空陣列 []（示範的降級行為）。  
  - 測試指令範例（README 中提供）：curl http://localhost:8090/customer/menu

- 演示場景二：註解式熔斷器（Order 端點）  
  - 操作步驟：以 POST 呼叫 /customer/order 模擬建立訂單；在後端不可用時，觀察 fallbackCreateOrder 是否被呼叫並返回 null（降級回應）。  
  - 觀察要點：檢查日誌（log.warn）確認 fallback 被觸發，並透過 actuator/circuitbreakers 與 metrics 檢視狀態與指標。  
  - 測試指令範例：curl -X POST http://localhost:8090/customer/order

- 監控驗證：使用 Actuator  
  - 指令：curl http://localhost:8090/actuator/circuitbreakers 以及 /actuator/metrics，觀察各熔斷器的 state、failure rate 等指標。  
  - [重點] 在演示時同時展示日誌、Actuator 回應與實際 HTTP 回傳，幫助學生把概念與實作對應起來。

#### 五、課程小結與後續展望

- 小結（比較兩種配置方式的差異與優缺點）  
  - 註解式（annotation-based）  
    - 優點：宣告式、簡潔、易於大面積保護業務方法。  
    - 缺點：難以做動態或複雜策略。  
  - 程式化（programmatic）  
    - 優點：高度靈活，可動態建立與管理 CircuitBreaker。  
    - 缺點：程式碼較多，維護成本相對高。  
  - [重點] 選擇方式應根據專案需求：以簡單維護為主選註解式，遇到特殊需求再採程式化；兩者亦可混合使用以達到最適化。  

- 後續章節預告：下一章將介紹「多數據源配置」（multi-datasource configuration），會從配置、事務管理與實務選型（例如讀寫分離、不同 DB 的資料一致性策略）接續，幫助你在微服務中處理複雜資料層場景。

#### 六、Tips（實務建議與操作提醒）

- [重點] 在測試環境演練熔斷行為：模擬下游故障、延遲與高錯誤率，驗證配置參數是否達到預期。  
- 設定建議：不要直接使用預設值上線，依流量與 SLA 調整 sliding-window-size、minimum-number-of-calls、failure-rate-threshold 與 wait-duration。  
- 降級回應要有意義：避免返回不具備用戶價值或包含敏感資訊的回應，設計可用的降級內容（快取、預設回應、部分功能）。  
- 監控與告警：將熔斷器事件納入運維告警流程，當 open state 持續或頻繁切換時優先排查下游健康與流量模式。  
- 測試 fallback：確認 fallback 方法簽名與所在類別可被 Spring AOP 正確解析，避免因簽名錯誤導致降級無法生效。  
- 文件化：將各 CircuitBreaker 的業務含義、配置值與調整原因記錄在運維/開發文件中，便於後續追蹤。

參考示範專案與範例程式碼請見示範專案 README（[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/resilience4j-circuitbreaker-demo/README.md]]）與講義音檔（[[103 | 使用Resilience4j实现服务熔断]]），建議學生實作時依 README 指示啟動專案並逐步模擬失敗場景以加深理解。若需要，我可以將本講義轉成投影片或提供逐步實作教學腳本（包含範例指令與 log 檢查重點）。

---
### 104 | 使用Resilience4j實現服務限流（上） ― [bulkhead-customer-service, Chapter 12-consul-waiter-service]
#### 一、課程目標

本章將以「使用 Resilience4j 實現服務限流（上）」為主軸，結合隔板（Bulkhead）模式的實例，帶領同學理解在 Spring 微服務環境中如何用註解與外部化配置建立限流與隔離，確保高併發下服務的穩定性與可預期行為。#重點 #實務

- 學習重點
  - 理解限流（Rate Limiting）與隔板（Bulkhead）的核心概念與適用場景 #考點
  - 掌握 Resilience4j 在 Spring Boot 中的兩種配置方式：註解式與程式式 API #重點
  - 能以 application.yml 定義多個限流/隔板實例，並在方法上套用
  - 會撰寫 fallback 保護流程，並透過 Actuator/Micrometer 觀察執行情況
- 實務意義
  - 在尖峰流量、突發訪問或下游慢查詢時維持服務質量，避免「雪崩效應」 #實務
  - 隔離非關鍵功能與阻斷慢請求，提升整體服務可用性與資源利用率
- 相關資源
  - Resilience4j 官方文件：https://resilience4j.readme.io/
  - Spring Cloud CircuitBreaker (Resilience4j)：https://spring.io/projects/spring-cloud-circuitbreaker
  - Micrometer + Actuator 指南：https://micrometer.io/docs
  - 參考筆記：[[104 | 使用Resilience4j实现服务限流（上）]]、[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/bulkhead-customer-service/README.md]]

#### 二、主體

一、核心概念與模式邏輯

- 限流（Rate Limiter）
  - 定義：限制單位時間內允許的請求數，防止資源被突發或惡意流量耗盡 #重點
  - 適用：查詢類 API、非關鍵功能、需要平滑吞吐的場景
  - Resilience4j 參數常見：
    - limitForPeriod：每個刷新週期可通過的請求數
    - limitRefreshPeriod：刷新週期（如 1s）
    - timeoutDuration：當許可已用罄時，等待可用許可的最長時間
- 隔板（Bulkhead）
  - 定義：把資源池切分，彼此隔離，避免某一路徑的壅塞拖垮整個服務 #重點
  - 兩種類型：
    - SemaphoreBulkhead：以信號量限制併發請求數，輕量、適用非阻塞或短作業 #考點
    - ThreadPoolBulkhead：以執行緒池 + 佇列隔離，適合阻塞式 I/O 或外部呼叫
  - 常見參數：
    - Semaphore：maxConcurrentCalls、maxWaitDuration
    - ThreadPool：coreThreadPoolSize、maxThreadPoolSize、queueCapacity
- 熔斷（Circuit Breaker）與退避
  - 熔斷聚焦「錯誤率/延遲」保護；限流/隔板聚焦「資源容量」治理，常一起使用 #易混淆
  - 退避（Fallback）：當被拒絕或超時時提供退路，確保使用者體驗可控

二、在 Spring 中的整合方式

- 註解式配置（建議入門）
  - @RateLimiter(name="...")、@Bulkhead(name="...", type=...)、@CircuitBreaker(name="...") 可搭配 fallbackMethod
  - 好處：簡潔、可讀性高、與切面（AOP）整合自然 #重點
- 程式式 API（進階/動態）
  - 透過 Registry 取得 RateLimiter/Bulkhead 實例，手動包裝執行邏輯
  - 好處：動態選擇實例、細粒度控制、可組合裝飾（decorateXxx） #實務

三、配置設計的實務考量

- 限流顆粒度
  - 以「業務能力」為單位建立名稱，如 customerFindById、searchOrders #命名規約
- 遞交體驗與回覆
  - 明確回傳 429 Too Many Requests 或友善降級訊息，避免沉默失敗
- 指標與觀測
  - 開啟 Actuator metrics，監看 rate_limiter、bulkhead 指標與事件流 #可觀測性
- 路徑隔離策略
  - 對外部依賴（DB、第三方 API）優先使用 ThreadPoolBulkhead
  - 對 CPU 輕量作業使用 SemaphoreBulkhead

四、常見誤區

- 把限流當熔斷用：兩者保護維度不同，務必搭配使用 #易錯
- timeoutDuration 設過長：會放大延遲並造成併發堆積
- ThreadPoolBulkhead 引數不當：佇列過大導致高延遲，過小則易丟請求

#### 三、實戰演示

本演示以「bulkhead-customer-service」為例，示範限流與隔板的落地方式，並可對照你在筆記中的配置與代碼。

一、專案初始化

- 依賴
  - spring-boot-starter-web
  - resilience4j-spring-boot3（或對應版本）
  - spring-boot-starter-actuator
  - micrometer-registry-prometheus（選用）
- application.yml 範例（節錄）
  - resilience4j.ratelimiter:
    - instances.customerFindById:
      - limitForPeriod: 10
      - limitRefreshPeriod: 1s
      - timeoutDuration: 50ms
  - resilience4j.bulkhead:
    - instances.customerQuerySemaphore:
      - maxConcurrentCalls: 20
      - maxWaitDuration: 50ms
  - resilience4j.thread-pool-bulkhead:
    - instances.outboundPool:
      - coreThreadPoolSize: 10
      - maxThreadPoolSize: 20
      - queueCapacity: 50
- Actuator 開啟
  - management.endpoints.web.exposure.include: health,info,metrics,prometheus

二、服務方法與註解

- Repository/Service 方法
  - 在查詢接口加上 @RateLimiter(name="customerFindById", fallbackMethod="findByIdFallback")
  - 若該查詢偶有慢 SQL，再疊加 @Bulkhead(name="customerQuerySemaphore", type=Bulkhead.Type.SEMAPHORE)
- Fallback 撰寫
  - 方法簽名需包含原參數，最後可附加 Throwable
  - 例如：public Customer findByIdFallback(Long id, Throwable t) { … }
- 對外呼叫（選用）
  - 呼叫外部 API 時使用 ThreadPoolBulkhead（如 WebClient + Scheduler 或透過裝飾器）

三、程式式 API（進階示例）

- 透過 RateLimiterRegistry、BulkheadRegistry 取得實例
- 使用 Decorators.ofSupplier(...) 依序套用 rateLimiter、bulkhead、retry、circuitBreaker
- 適合需動態選擇實例或在非 Spring AOP 範圍中運用的場景 #進階

四、壓測與觀測

- 壓測工具：hey、wrk、JMeter 或 k6
  - 並發提升，觀察 2 條路徑：
    - 正常通過：200/OK
    - 被限流：429 或 fallback 響應（可自訂標記例如 X-Limited: true）
- 指標觀測
  - /actuator/metrics/search rate_limiter.calls、bulkhead.available_concurrent_calls
  - 若有 Prometheus：檢查對應 metrics 並在 Grafana 繪圖
- 事件紀錄
  - 可註冊事件消費者（EventConsumer）監聽成功/拒絕/超時事件，紀錄到 logs

五、錯誤處理與用戶體驗

- 將限流/拒絕包裝為一致錯誤模型（含錯誤碼、建議重試秒數） #最佳實務
- 區分「讀」與「寫」路徑限流策略（寫操作更保守）

#### 四、課程小結與後續展望

- 兩種配置方式對比（註解式 vs 程式式 API） #重點
  - 註解式
    - 優點：簡潔、可讀性高、上手快、易與 Spring AOP/切面事件整合
    - 缺點：動態性較低，跨層共用或條件式組合較受限
    - 適用：大多數常見服務方法、清晰的固定策略
  - 程式式 API
    - 優點：高度彈性、可動態選擇策略與鏈式裝飾、方便跨層/工具類使用
    - 缺點：樣板程式較多、可讀性依賴封裝品質
    - 適用：複雜路徑、需動態切換或與自訂執行流程深度結合
- 補充：兩種隔板類型（Semaphore vs ThreadPool）
  - Semaphore：低成本、高效，適合 CPU 輕量或非阻塞作業
  - ThreadPool：強隔離、成本較高，適合阻塞式 I/O 或外部依賴
- 本章收穫
  - 了解限流/隔板的核心參數、註解用法、fallback 設計與觀測面
  - 可以在 bulkhead-customer-service 這類服務中落地與壓測
- 後續展望
  - 下一章節將介紹多數據源配置，說明在微服務中如何同時管理多資料來源並保持交易一致性與效能表現 #預告

#### 五、Tips：

- 以「業務能力」命名 limiter/bulkhead 實例，避免一把尺 #命名
- timeoutDuration 不宜過長，寧可快速失敗 + 明確 fallback #重點
- ThreadPoolBulkhead 的 queueCapacity 要小心設定，避免堆積造成高延遲 #實務
- 觀測先行：上線前確認 metrics 與告警門檻，確保可回溯與預警 #可觀測性
- 與 API Gateway 限流互補：Gateway 控入口流量，服務內控資源與依賴 #架構建議

補充說明：
- 若你提供 [[104 | 使用Resilience4j实现服务限流（上）]] 與 [[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/bulkhead-customer-service/README.md]] 的具體內容（或以 @vault 搜索貼出重點），我可以把上述講義草案精準對齊你的代碼、參數與實際情境，並同步整理為便於授課的逐字講稿版本。
---
### 105 | 使用Resilience4j實現服務限流（下） ― [ratelimiter-waiter-service, bulkhead-customer-service]
#### 一、課程目標

本章聚焦以 Resilience4j 在 Spring 微服務中實作「服務限流（Rate Limiting）」，並延伸到「等待取得許可」與「快速拒絕」兩種策略的差異與取捨。完成後你將能：
- 設計並套用限流策略，保護核心服務避免雪崩與資源枯竭
- 在 Spring Boot 中以註解式與程式碼式兩種方式配置 Resilience4j RateLimiter
- 搭配 Fallback、監控與壓測，驗證限流策略成效
- 理解限流與熔斷的關係與搭配方式，構建更完整的韌性機制

參考資源：
- 本章相關筆記與程式：
  - [[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 13 服務熔斷/ratelimiter-waiter-service/README.md]]
  - [[105 | 使用Resilience4j实现服务限流（下）]]
- 官方文件：
  - Resilience4j RateLimiter docs：https://resilience4j.readme.io/docs/ratelimiter
  - Spring Boot 監控 Micrometer：https://micrometer.io/
  - Spring Cloud CircuitBreaker（如需與熔斷整合）：https://spring.io/projects/spring-cloud-circuitbreaker

【重點】限流的目的不是降低效能，而是以可控方式「保護」服務，維持整體系統的穩定可用

#### 二、主體

一、為何要限流（Rate Limiting）  
- 問題背景：在高併發或下游服務抖動時，若不限制入口流量，容易造成執行緒用盡、連線池耗盡、CPU 飆高，導致整體系統「雪崩」。  
- 與熔斷差異：
  - 限流：主動限制「進入速率」，目標是讓系統在可承受的節奏內工作
  - 熔斷：在失敗率高時，暫停向下游發送請求以自我保護  
- 與排隊的關係：限流可被視為「預設最多只讓多少請求進入」，超過就等待或拒絕，避免無序排隊導致尾延遲升高

【重點】限流是「入口閥門」，熔斷是「故障保護開關」，兩者相輔相成

二、Resilience4j RateLimiter 原理與名詞  
- limitForPeriod：在一個 refresh 期間可核發的「許可數」  
- limitRefreshPeriod：許可數的刷新週期（如每 1 秒補充 N 張許可）  
- timeoutDuration：若當下無許可，取得許可時最多等待多久；0 表示「快速拒絕」  
- 行為特性：採固定時間窗的許可刷新；超出可用許可時，呼叫端要嘛「等待」、要嘛「立刻失敗」  
- 典型選型：
  - 快速拒絕：timeoutDuration: 0（適合邊界閘道，避免佔用工作執行緒）
  - 等待取得：timeoutDuration: 100–500ms（適度平滑尖峰，但要注意執行緒占用）

【易錯】將 timeoutDuration 設太大，容易把 Tomcat/Netty 工作執行緒「卡住」，反而形成資源枯竭

三、在 Spring 中的整合模式  
- 註解式（AOP）：在方法上加 @RateLimiter(name="...") 與可選 fallbackMethod  
- 程式碼式（Decorator）：以 RateLimiterRegistry 取得 RateLimiter，包裹 Supplier/Callable/Mono/Flux  
- 與其他韌性元件組合：
  - RateLimiter + CircuitBreaker：先限流再熔斷，避免在故障時過量請求衝擊下游
  - RateLimiter + TimeLimiter：非同步或反應式場景控制等待上限  
- 命名建議：以「下游資源維度」命名（例如 "baristaService"），使配置與監控對應清晰

【重點】在邏輯上建議順序：RateLimiter → Bulkhead（可選）→ CircuitBreaker → Retry（謹慎）→ Fallback

四、關鍵配置與常見參數建議  
- limitForPeriod：與下游最大安全 QPS 對齊，初始可抓「穩定 80% 負載」再逐步調整  
- limitRefreshPeriod：常用 1s；也可依服務性質（如 I/O 密集）微調  
- timeoutDuration：MVC/Servlet 模式保守設置（0–200ms），Reactive 模式可稍長  
- 動態配置：可分 profile 或透過外部化配置（如 Spring Cloud Config）按環境調整  
- 監控與告警：追蹤拒絕率、等待比例、尾延遲(P99) 變化，遇到尖峰檢視是否需要調高或加快擴容

【實務】當使用者體感比吞吐更重要時，優先「快速拒絕 + 友善降級頁」比長時間等待更好

五、監控與觀測  
- Actuator：/actuator/metrics/resilience4j.ratelimiter.calls、available_permissions、waiting_threads  
- Micrometer：將指標匯出到 Prometheus/Grafana 追蹤趨勢  
- 日誌：對 Fallback 路徑與拒絕事件加上結構化日誌，方便壓測與問題追蹤

【重點】沒有監控的限流，只是「猜測」；監控數據才是你調參與驗證依據

六、常見陷阱  
- Fallback 方法簽名不匹配（需包含原方法參數與 Throwable）  
- 名稱對不上配置（@RateLimiter 的 name 須對應到 yml 中的實例名）  
- Reactive 場景誤用阻塞 API（請使用 reactive 模式的裝飾）  
- 把限流放在過深層級，導致大量請求已進入應用才被丟棄，增加不必要的資源消耗

#### 三、實戰演示

場景：waiter-service 呼叫 barista-service，示範兩種策略
- /order 快速拒絕（timeoutDuration: 0）
- /order/wait 等待取得許可（timeoutDuration: 300ms）

步驟一：加入依賴
- io.github.resilience4j: resilience4j-spring-boot2
- org.springframework.boot: spring-boot-starter-web
- org.springframework.boot: spring-boot-starter-actuator
- 可選：micrometer-registry-prometheus

步驟二：application.yml 重要配置（示意）
- resilience4j.ratelimiter:
  - instances:
    - barista-fast:
      - limitForPeriod: 10
      - limitRefreshPeriod: 1s
      - timeoutDuration: 0
    - barista-wait:
      - limitForPeriod: 10
      - limitRefreshPeriod: 1s
      - timeoutDuration: 300ms
- management.endpoints.web.exposure.include: health,info,metrics,prometheus

【重點】同一服務可針對不同端點或下游使用不同 RateLimiter 實例

步驟三：Controller 與註解式用法（示意）
- /order：@RateLimiter(name = "barista-fast", fallbackMethod = "fallbackFast")
- /order/wait：@RateLimiter(name = "barista-wait", fallbackMethod = "fallbackWait")
- fallback 簽名需包含 Throwable；回應 429 或 503 並附上重試指引

步驟四：程式碼式包裝（Decorator）（示意）
- 透過 RateLimiterRegistry 取得 "barista-wait" 實例
- 使用 Decorators.ofSupplier(() -> webClient.get()...retrieve()...) 再 .withRateLimiter(...)
- 便於更細緻地組合多個韌性元件（如先 RateLimiter 再 CircuitBreaker）

步驟五：壓測與觀測
- 使用 hey/ab/jmeter 以 QPS 20 打 /order；觀察拒絕率趨近 (QPS - limit) / QPS
- 打 /order/wait；觀察等待比例上升但總成功數提升，同時檢查 P95/P99 是否被拉長
- 查看 /actuator/metrics/resilience4j.ratelimiter.calls 與 available_permissions

【驗收標準】
- 快速拒絕路徑：低延遲、拒絕率清晰可控、fallback 回應一致
- 等待取得路徑：成功率提升但尾延遲上升可接受；等待時間受控且不造成執行緒飢餓

#### 四、課程小結與後續展望

一、兩種配置方式比較（註解式 vs 程式碼式）
- 註解式（@RateLimiter）
  - 優點：簡潔、開發效率高、與 yml 配置直覺對應
  - 缺點：在複合情境（多個韌性元件順序、條件式應用）彈性較低
- 程式碼式（Decorator/Registry）
  - 優點：可細緻組合順序（RateLimiter→CircuitBreaker→TimeLimiter）、動態策略切換
  - 缺點：樣板碼較多、需要嚴謹測試以避免包裝順序錯誤

二、兩種限流策略比較（快速拒絕 vs 等待取得）
- 快速拒絕
  - 優點：保護執行緒與資源、延遲穩定、使用者體感一致
  - 缺點：成功率較低，需要良好降級頁或重試策略
- 等待取得
  - 優點：在短尖峰下提高成功率、平滑流量
  - 缺點：延遲上升、可能卡住執行緒，需配合 TimeLimiter 或 Reactive

【結論】以「入口快速拒絕」確保系統穩態，以「內部適度等待」平滑短尖峰，再配合熔斷、觀測與自動擴容，形成完整韌性方案

三、後續展望
- 下一章將介紹「多數據源配置」的實務做法，說明在分庫分表或讀寫分離場景下的連線池設計、事務邊界與觀測要點，銜接更複雜的微服務資料層實務

#### 五、Tips：

- 給邊界閘道或高峰入口：優先使用「快速拒絕 + 一致降級回應 + 可觀測性」  
- 給內部服務的短尖峰：可用「小幅 timeoutDuration + TimeLimiter」平衡成功率與延遲  
- 與 CircuitBreaker 一起用：順序建議 RateLimiter 在前，避免在故障期向下游傾倒過量請求  
- 監控先行：建立拒絕率、等待比例、P95/P99 的儀表板，再迭代調參  
- 測試策略：用壓測工具重現尖峰，對比兩策略的成功率與延遲分佈，避免只看平均值  
- Fallback 設計：給出 retry-after、排隊位置或離線處理選項，讓使用者有明確行為指引  
- Reactive 場景：盡量使用 WebClient + reactive 裝飾，降低阻塞風險  
- 資源安全線：先量測下游的「穩定可承載 QPS」，以此回推 limitForPeriod 初始值，再用監控微調

【最後提醒】限流不是一次設好就好，而是「隨著流量型態與容量一起演進」的長期工程。搭配觀測、壓測與自動化部署，才能讓限流真正為系統穩定性加分。

---
### 106 | SpringBucks實戰項目進度小結
#### 一、課程目標

本章聚焦於「服務保護」在 Spring 微服務架構中的實務運用，帶你理解並落地三大保護模式：斷路器、隔艙、速率限制（含時間限制），以及從 Hystrix 過渡到 Resilience4j 的最佳實踐。你將能在不同壓力與故障情境下，讓服務表現穩健、可觀測、可告警。

【重點】掌握服務保護模式與工具選型，能根據場景合理配置與監控  
【重點】理解 Hystrix 停維背景與為何選 Resilience4j，並能完成遷移

參考資源（建議課後練習）：
- Resilience4j 官方文件：https://resilience4j.readme.io
- Spring Boot Actuator（觀測端點）：https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html
- Spring Cloud Circuit Breaker 抽象：https://spring.io/projects/spring-cloud-circuitbreaker
- Netflix Hystrix（停維說明）：https://github.com/Netflix/Hystrix
- 阿里巴巴 Sentinel（替代方案）：https://github.com/alibaba/Sentinel
- Guava RateLimiter 與 Cache：https://github.com/google/guava
- 壓測工具：ab（ApacheBench）、wrk、JMeter、Gatling

#### 二、主體

一、為何需要服務保護

在分散式系統中，單點過載、下游雪崩、網路抖動都可能引發連鎖故障。服務保護的目標是「隔離風險、平滑流量、快速失敗、優雅降級」。

- 【重點】核心原則：失敗要可控、故障要可見、退路要明確  
- 舉例：像船艙分隔（隔艙）可避免進水擴散；同理，限制併發或隔離執行池可防止單一路徑拖垮整個系統

二、三大保護模式與時間限制

1) 斷路器 Circuit Breaker  
- 監控呼叫成功/失敗比率，當錯誤率達門檻時「打開」，快速失敗，避免持續壓垮下游；一段時間後進入半開做探測。  
- 【重點】三種狀態：Closed（正常）、Open（快速失敗）、Half-Open（試探）  
- 常見指標：失敗率/慢調用率門檻、滑動視窗大小、半開允許測試次數、冷卻時間

2) 隔艙 Bulkhead  
- 將資源（執行緒池/併發度）隔離分艙，一個功能過載不會拖累整體。  
- 【重點】可用「執行緒池隔離」或「信號量併發數」兩種方式，權衡上下文傳遞與切換成本

3) 速率限制 Rate Limiter  
- 以固定速率放行請求，避免瞬間尖峰；常見演算法：令牌桶/漏桶。  
- Guava RateLimiter 基於令牌桶模型，適合應用層限流。  
- 【重點】速率限制與隔艙搭配：先限流再隔艙，能更平滑地保護後端

4) 時間限制 Time Limiter  
- 為每次呼叫設定超時，超過即快速失敗；避免長時間阻塞資源。  
- 【重點】超時要與重試策略協調，避免「雪上加霜」的放大量重試

三、工具選型與演進：Hystrix -> Resilience4j -> Sentinel（備選）

- Hystrix：過去的事實標準，但官方已停止維護，不建議新專案採用。  
- Resilience4j：輕量、模組化（circuitbreaker、ratelimiter、bulkhead、timelimiter…）、原生支援函數式與注解式整合，與 Spring Boot Actuator 深度整合。  
- Sentinel（Spring Cloud Alibaba）：提供流控、熔斷、降級、系統自適應保護，適合阿里系生態或需要流量規則可視化管理的場景。  
- 【重點】本章主線：以 Resilience4j 作為 Hystrix 的替代方案

關於程式風格：
- 函數式（裝飾器）風格：可組合多個保護器，易於單元測試與重用  
- 注解/AOP 風格：開發效率高、改動少，適合快速落地  
- 【重點】兩種方式可並存，視團隊風格與場景選擇

與 Feign 整合：
- 可透過 Spring Cloud Circuit Breaker 或 Resilience4j 的整合套件，為 Feign 客戶端提供斷路、限流與超時控制  
- 【重點】為客戶端呼叫點加裝「保護裝飾器」比在服務內部更能前移風險

四、觀測與監控

- Resilience4j 暴露 Actuator 端點（事件/指標），可查詢每個保護器的狀態與事件流，如 circuitbreaker events、ratelimiter metrics、bulkhead metrics、timelimiter metrics  
- 可接入 Prometheus + Grafana 建立儀表板與告警；老專案可用 Hystrix Dashboard 作觀察  
- 【重點】統一監控平台＋預警規則：第一時間發現打開斷路、限流嚴重、超時暴增等異常

五、壓力測試與工具

- Linux/Mac：ab（ApacheBench）、wrk  
- Windows：可透過 WSL 或 Cygwin 使用 ab；亦可用 JMeter、Gatling  
- 【重點】壓測要有目標：設定吞吐、P95/P99 延遲、錯誤率門檻，並觀察保護器的觸發行為與恢復曲線  
- 建議測三階段：平穩負載、突發尖峰、故障注入（延遲/錯誤）以驗證降級路徑

六、本章專案變更回顧

- virtual-service：新增基於 Resilience4j 的 RateLimiter  
- customer-service：先以 Hystrix 演示斷路與保護，後改用 Resilience4j 實作斷路器與隔艙（並搭配時間限制），展示遷移路徑與配置差異  
- 【重點】最終目標：在不同壓力條件下，服務均能快速失敗、平滑退讓、可觀測且可恢復

#### 三、實戰演示

一、為 virtual-service 加上速率限制
- 目標：將每秒請求數限制在可承載範圍，驗證尖峰下的平滑表現  
- 步驟：  
  - 新增 Resilience4j RateLimiter 設定（每秒許可數、超時等待時間）  
  - 套用於入口控制器或服務方法（注解或函數式裝飾器）  
  - 以 wrk/ab 打尖峰流量，觀察成功/拒絕比、平均/尾延遲

二、為 customer-service 套用斷路器、隔艙與時間限制
- 目標：下游變慢或失敗時，快速失敗並提供降級回應，避免阻塞  
- 步驟：  
  - 設定 CircuitBreaker（失敗率、慢調用比例、滑動視窗、半開策略）  
  - 設定 Bulkhead（最大併發或執行緒池大小/佇列長度）  
  - 設定 TimeLimiter（超時門檻）  
  - 實作 Fallback（預設值、快取回應或引導到稍後重試）  
  - 以故障注入（延遲/錯誤碼）觀察狀態演進 Closed→Open→Half-Open

三、觀測與告警
- 查詢 Actuator 端點：circuitbreaker events、ratelimiter 指標、bulkhead 併發使用  
- 接入監控：Prometheus 拉取指標，Grafana 繪製看板（斷路狀態、拒絕率、P95 延遲）  
- 設定告警：如 1 分鐘內斷路打開超過 N 次、被限流比率超過 X%、P99 延遲高於 S 秒

四、壓測驗證
- 腳本一：平穩流量（基線）  
- 腳本二：突發尖峰（驗證 RateLimiter 生效）  
- 腳本三：下游延遲/錯誤（驗證 TimeLimiter 與 CircuitBreaker 行為）  
- 【重點】驗證「開啟—恢復—半開」全流程與降級回應的可用性與可觀測性

#### 四、課程小結與後續展望

一、兩種配置方式差異與優缺點（以 Hystrix vs Resilience4j 為例）
- Hystrix（傳統）
  - 優點：生態成熟（歷史）、有 Dashboard、設計完整  
  - 缺點：【重點】官方停維、升級受限、與新版本 Spring 生態整合弱
- Resilience4j（推薦）
  - 優點：【重點】模組化輕量、與 Actuator/微指標深度整合、支援函數式與注解式、社群活躍  
  - 缺點：從 Hystrix 遷移需調整語義與監控面板；需要重新校準參數與儀表板

補充：在 Resilience4j 內部也可比較「注解式 vs 函數式」兩種用法  
- 注解式：改動小、上手快；但細粒度組合與單測彈性略弱  
- 函數式裝飾器：可組合多策略、易測試；但初學曲線稍高

二、整體收穫
- 你懂得在高並發與故障場景下，以「限流→隔艙→斷路→超時→降級」的順序架起多層保護  
- 能夠將事件與指標輸出至統一監控平台，並依指標設置告警

三、後續展望：多資料源配置
- 下一章將介紹多資料源配置與隔離策略，討論在交易/查詢型服務中，如何兼顧一致性、效能與可用性，並與本章的保護機制協同運作

#### 五、Tips

- 參數先保守再逐步放寬：先降低併發與速率門檻，觀察後上調  
- 斷路器與重試要協調：Open 狀態下避免盲目重試放大壓力  
- Fallback 設計要可用：提供降級快取、預設值或替代路徑；確保回應可被用戶接受  
- 隔艙要配合執行緒池監控：關注佇列長度與拒絕率，避免饑餓與爆倉  
- 超時與端到端 SLO 對齊：上游超時應略短於下游，以快速釋放資源  
- 指標與事件都要收集：同時看「結果指標」（延遲、錯誤率）與「保護器事件」（Open、限流次數）  
- 演練半開策略：控制探測請求數，避免恢復期被瞬間流量壓垮  
- 工具生態搭配：需要規則視覺化或動態生效可評估 Sentinel；應用層限流也可用 Guava RateLimiter；短期維運老系統可保留 Hystrix 但規劃遷移  
- 文件化與腳本化：把壓測、故障注入與觀測步驟寫成腳本，便於回歸與培訓

【重點】服務保護的本質是「在不確定中保持系統可用」。請將本章方法論落實到每個跨服務呼叫點，並建立可觀測、可告警、可演練的日常工程流程。

---
# Chapter 14：服務配置（7講）
### 107 | 基於Git的配置中心（上） ― [config-server]
#### 一、課程目標：

- 本章學習重點：理解並實作 Spring Cloud Config Server 的設計概念與運作流程，掌握如何以 Git 為後端集中管理微服務配置、使用 Profile 與命名規則處理多環境配置、透過 Actuator 檢查健康狀態與存取配置，以及整合服務註冊（Consul）以便在微服務環境中運行。  
- 實務意義：讓學生能在真實專案中把配置從程式碼中抽離，達成配置版本管理、環境隔離、動態更新與集中監控，減少部署時的錯誤並提升運維效率。  
- 可操作資源（實作練習用）：  
  - Git 配置倉庫範例路徑：建立本地 Git repo 並加入 waiter-service.yml / waiter-service-dev.yml（見範例）【操作指令在實作演示中】  
  - 專案原始碼：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 14 服務配置/config-server/README.md]]（含快速啟動與設定範例）  
  - 參考文件：Spring Cloud Config 官方文件（https://docs.spring.io/spring-cloud-config/docs/current/reference/html/）、Spring Boot Actuator（https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html）、Consul 文件（https://www.consul.io/docs/discovery）  
- 【重點】請在練習時準備：Java 21、Maven、Git，以及（選用）Consul 作為服務註冊中心。

過渡：先建立概念與技術棧，再逐步進入實作步驟與常見問題排查。

#### 二、主體 — 理論與核心概念（分段說明）

一、Config Server 的定位與作用  
- 角色說明：Config Server 是一個「集中式配置管理服務」，負責將配置從各個微服務中抽離，透過 HTTP REST API 對外提供配置資料。想像成一個專門的設定檔倉庫，應用啟動或運行時向它拉取配置。  
- 【重點】好處：集中化管理、版本控制（Git）、環境隔離（Profile）、動態更新（避免頻繁重啟）與與 Spring Boot 無縫整合。

二、核心功能與技術棧  
- 支援多種後端：Git、SVN、檔案系統等；本專案示範以 Git 為後端，充分利用版本管理。  
- 多環境支援：透過 Spring Profile 機制（例如 waiter-service-dev.yml）提供不同環境配置。  
- 健康監控：整合 Spring Boot Actuator，提供 /actuator/health 等端點以便監控。  
- 服務發現整合：支援與 Consul 整合，Config Server 本身可以註冊至 Consul，以利在動態環境中被發現與管理。  
- 技術棧重點：Spring Boot 3.4.5、Spring Cloud Config Server、Spring Cloud Consul Discovery、Maven、Git、Actuator。

過渡：了解功能後，我們看具體的命名與 API 使用方式，這是日常操作常見的基礎。

三、配置命名規則與 API 端點（實務要點）  
- 命名規則（簡潔說明）：  
  - {application}.yml：對應某一服務的預設配置（例如 waiter-service.yml）。  
  - {application}-{profile}.yml：特定環境配置（例如 waiter-service-dev.yml）。  
  - application.yml：全域共用配置。  
- 常用 API：  
  - GET /{application}/{profile} → 取得 JSON 格式配置  
  - GET /{application}.yml → 取得 YAML 格式配置（單一檔案）  
  - GET /{application}-{profile}.yml → 取得特定環境 YAML  
  - /actuator/health → 健康檢查  
- 【重點】命名要一致：微服務呼叫 Config Server 時，application 名稱與 Git 中檔名需對應，否則會抓不到預期的配置。

四、動態刷新與安全性考量  
- 動態刷新：Config Server 支援配置的動態更新（可搭配 /actuator/refresh 或使用事件總線如 Spring Cloud Bus 觸發），讓服務在不重啟或最小重啟下更新設定。  
- 配置加密：敏感資料（DB 密碼、API Key）應使用 Spring Cloud Config 的加密功能保護。  
- 安全性與網路：生產環境務必限制 Config Server 的存取（網路位置、認證與權限），避免敏感配置被暴露。  
- 【重點】在生產環境，將 Git 存取權限、Config Server 的網路防護與加密一起做成流程，是必要的。

五、運維與常見問題排查（實務經驗）  
- 常見錯誤：Git URI 設定錯誤、檔案命名不一致、Profile 不匹配、權限不足、Consul 連線失敗。  
- 排查步驟：從 /actuator/health 確認服務健康 → 檢查 application.properties 的 spring.cloud.config.server.git.uri → 用 curl 測試特定檔案端點 → 檢查 Config Server 日誌（Git clone/讀取錯誤）。  
- 性能注意：大型 Git 倉庫會造成同步與 clone 成本，建議定期清理或使用淺複製策略；也可將配置切分為多個 repo 減少單一倉庫負擔。

過渡：理論與常見問題掌握後，下一段示範完整的實作步驟，讓你能在本機環境快速上手。

#### 三、實戰演示（帶學生一步步操作）

步驟總覽（以 README 範例為基礎）  
1. 準備：安裝 Java 21、Maven、Git（Consul 選用）【環境檢查】  
2. 取得專案：git clone https://github.com/SpringMicroservicesCourse/spring-cloud-config-server.git  
3. 建立本地 Git 配置倉庫（範例）  
   - 建立倉庫並新增範例配置文件：  
     - waiter-service.yml（包含 order.discount、waiterPrefix）  
     - waiter-service-dev.yml（覆寫開發環境的 discount）  
   - git init / git add / git commit（確保本地 path 使用 file:// URI）  
   - 【範例指令】 mkdir -p ~/fengqing-spring-cloud-config-git-repo; cd ...; git init; echo ... > waiter-service.yml; git add .; git commit -m "init"  
4. 配置 Config Server 的 git uri：在 application.properties 中設定 spring.cloud.config.server.git.uri=file:///path/to/your/config-repo  
5. 編譯並啟動：mvn clean compile; mvn spring-boot:run  
6. 驗證：  
   - 檢查健康：curl http://localhost:8888/actuator/health → 應回傳健康狀態  
   - 取得 YAML：curl http://localhost:8888/waiter-service.yml → 檢視配置內容  
   - 取得 JSON：curl http://localhost:8888/waiter-service/default → 取得 JSON 格式的配置  
- 【示範要點】若使用 file:// 路徑，注意路徑權限與 OS 特性；若使用遠端 Git（http/ssh），需處理認證與私密金鑰。

演示補充說明：  
- 若要啟用 Consul 整合，需在 application.properties 設定 spring.cloud.consul.host / port，並確認 Consul agent 正常運作，Config Server 會註冊到 Consul，方便在服務網格中被發現。  
- 若需動態下發配置更新，示範如何修改 Git 檔案後觸發應用刷新（可用 /actuator/refresh 或整合事件總線），並觀察應用端配置變化。

過渡：完成實作後，歸納比較不同配置策略的利弊，利於架構決策。

#### 四、課程小結與後續展望

總結（聚焦兩種配置方式差異）  
- 方法 A：集中式配置（Config Server + Git 後端）  
  - 優點：集中管理、版本控制、支援多環境、可動態更新、便於團隊協作與審查（Pull Request）。  
  - 缺點：引入單點（需做好 HA）、網路依賴（啟動時需可存取配置倉庫）、需要額外安全與權限管理。  
- 方法 B：內嵌配置（每個服務的 application.yml / application.properties）  
  - 優點：部署簡單、啟動時不依賴外部服務、較低延遲與部署複雜度。  
  - 缺點：難以統一管理與版本化不同環境的配置、無法輕易做到動態更新、變更需重新部署或手動調整。  
- 【重點】選擇建議：開發/小型專案可以使用內嵌配置快速上手；中大型或多團隊專案建議採集中式（配合 Git 與嚴謹的存取控制），以利法遵與稽核。

後續展望：  
- 下一章節預告：多數據源配置（會介紹如何在一個應用中同時連接與管理多個資料來源、如何以 Spring 的配置與 Bean 管理來區分多個 DataSource、以及測試與遷移策略），可視為配置信息管理後的下一步，聚焦資料層的彈性設計與運維。

過渡句：掌握集中式配置之後，接下來會把注意力移到資料來源管理，讓系統在多資料源、多租戶或分層儲存場景下也能保持可維護性。

#### 五、Tips：

- 【配置設計】使用 application.yml 放共用設定，每個服務使用 {service}.yml，環境差異放 {service}-{profile}.yml，保持結構一致性。  
- 【安全】敏感資訊務必使用 Config Server 的加密功能或加密存放在 Vault 等專門工具；避免 plaintext 存放在公開 Git。  
- 【版本與流程】建立配置變更流程（Pull Request → 測試 → Staging 驗證 → Deploy），任何配置改動都應可追溯。  
- 【效能】大型 Git 倉庫會造成 clone/拉取瓶頸，可考慮分割倉庫或使用淺 clone。  
- 【高可用】在生產環境考量 Config Server 的 HA（多節點、負載平衡、以及 Git 存取的可用性）。  
- 【測試】在變更配置前，先在測試/預備環境驗證；採用自動化測試來檢查配置參數有效性（結構、必填欄位）。  
- 【排錯策略】先看 /actuator/health → 檢查日誌錯誤（Git clone、權限、network），確認 spring.cloud.config.server.git.uri 是否正確。  
- 【操作小技巧】本機測試常用 file:/// 結合本地 Git repo；遠端部署則使用 HTTP/SSH 並妥善管理認證金鑰。

結語：本章重點在於掌握「配置從程式碼中抽離」的實務模式與風險控管，透過集中式 Config Server 結合 Git 與 Actuator，可以大幅提升配置管理的一致性與可追溯性。完成本章實作後，你將能在微服務專案中安全、可控地管理跨環境配置，為後續的多數據源與更複雜架構打下穩固基礎。

---
### 108 | 基於Git的配置中心（下） ― [git-config-waiter-service, config-service]
#### 一、課程目標

- 說明本節學習重點與實務意義：
  - 了解 Spring Cloud Config 的 Client 使用方式與運作流程，包含透過 Config Server 取得集中式配置與動態刷新配置的實作。
  - 掌握兩種 Config Server 發現方式（直接 URI 與服務發現）之差異與應用情境，並能判斷在開發/測試/生產環境中如何選擇。
  - 實作範例：使用 git 作為配置後端，透過 Waiter Service（咖啡店訂單系統）示範折扣參數動態變更與訂單計算流程。
  - 理解 @RefreshScope 與 Actuator /actuator/refresh 的協作，以及如何在不重啟應用的情況下更新配置。

- 相關資源（建議學生下載閱讀與練習）：
  - 專案範例（建議 clone 並本機執行）：[[200-AREA/arch/coding/java/spring/Spring微服務架構實戰/Code/Chapter 14 服務配置/git-config-waiter-service/README.md]] （倉庫內含 README、bootstrap.properties、示範程式碼）
  - 講義錄音與筆記：[[108 | 基于Git的配置中心（下）]]
  - 官方文件：Spring Cloud Config、Spring Boot Actuator、Resilience4j（連結請參考 README 中 Reference）
- 目標標籤：#重點 #實務操作 #動態配置

#### 二、主體

- 段落一：集中式配置概念與為何需要 Config Server
  - 說明：在微服務架構中，配置分散會導致維運困難。集中式配置（Config Server）把應用參數（例如折扣、服務員前綴、資料庫設定等）放到中央來源（例如 git），各服務在啟動時或運行時向 Config Server 拉取對應配置。
  - 重點：【#重點】配置外部化能讓部署更一致、維運更容易，且便於多環境管理（dev/test/prod）。
  - 類比：把每個服務的設定從「每台機器上的便條紙」集中到一個「版本化的配置檔庫」，方便追蹤與回滾。

- 段落二：Config Client 基本設定與啟動順序（bootstrap.properties）
  - 說明：Config Client 需在啟動初期與 Config Server 溝通，因此常把 Config Server 連線設定（如 service-id 或 URI）放在 bootstrap.properties（啟動階段生效），以便在 ApplicationContext 建立前取得外部配置。
  - 重要配置範例：
    - 直接指定 URI：spring.cloud.config.uri=http://host:8888 （簡單但不利於動態服務發現）
    - 使用服務發現：spring.cloud.config.discovery.enabled=true 並指定 spring.cloud.config.discovery.service-id=configserver（需 Consul/Eureka 等）
  - 重點：【#重點】bootstrap.properties 在啟動階段先於 application.properties 被讀取，適合放 Config Server 連線與應用名稱 spring.application.name。

- 段落三：發現方式比較 — 直接 URI vs 服務發現
  - 直接 URI：
    - 優點：設定簡單、定位明確。
    - 缺點：單點設定，不利於 Config Server 水平擴充與動態變更。
  - 服務發現（Consul/Eureka）：
    - 優點：Config Server 可透過註冊中心自動被發現，利於 HA 與動態擴縮。
    - 缺點：需額外部署註冊中心，系統複雜度增加。
  - 重點：【#重點】在單機或測試環境可先使用 URI，生產環境建議透過服務發現來提高可用性。

- 段落四：容錯與啟動行為（failFast、retry）
  - 說明：若 Config Server 無法連線，應控制 Client 的行為。可以透過 failFast 使應用在無法取得配置時快速失敗或設置重試機制（指數退避）。
  - 建議：
    - 開發時可容忍暫時離線，設定合理預設值於 application.properties。
    - 生產時搭配重試與熔斷策略（Resilience4j、retry），避免配置系統問題造成服務集體不可用。
  - 重點：【#重點】為 Config Server 建立容錯策略與預設值，避免啟動時因配置不可用而影響系統穩定性。

- 段落五：動態刷新配置的實作（@RefreshScope 與 /actuator/refresh）
  - 說明：配置類別（如 OrderProperties）加上 @RefreshScope 能在呼叫 /actuator/refresh 時重新注入最新配置，使 bean 的屬性動態更新而不必重啟應用。
  - 範例說明：OrderProperties 定義 discount 與 waiterPrefix，預設值會在 application.properties；如果 Config Server 中有對應的 profile（例如 waiter-service-dev.yml），Client 啟動後透過 /actuator/refresh 可即時更新折扣值並影響訂單計算。
  - 操作步驟示範（後述實戰演示中會執行）：
    1. 修改 git 中的配置檔（例如把 discount 從 60 改為 30）
    2. 透過 POST http://localhost:8080/actuator/refresh 觸發刷新
    3. 驗證 /config/order 或業務端點，確認數值已被更新
  - 重點：【#重點】@RefreshScope + Actuator 提供無侵入的配置更新機制，適用於調整業務參數（非敏感密鑰）。

- 段落六：實務中的配置結構與命名慣例
  - 建議配置分層：
    - 全域（application.yml）放共用設定
    - 服務專屬（waiter-service.yml）放服務層級參數
    - profile 專屬（waiter-service-dev.yml / -prod.yml）放環境差異設定
  - 重點：【#重點】保持各環境檔案結構一致，僅變動數值，能減少部署風險與合併衝突。

- 段落七：業務範例解析 — Waiter Service 中的訂單計算流程
  - 說明流程：
    - 建立訂單時，系統從 OrderProperties 讀取 discount（百分比）與 waiterPrefix，計算方式為：總金額 = (所有 Coffee.price 的總和 × discount) / 100。
    - Waiter ID 生成：使用 UUID 組合 waiterPrefix，確保不同服務實例的前綴與識別。
  - 實作要點：
    - 金額使用 Joda Money 或專門貨幣類型，避免浮點誤差。
    - 把可變的業務參數（如 discount）放入 Config Server，便於營運時調整促銷策略。
  - 重點：【#重點】業務參數外部化能即時影響計算結果，需測試邊界值（0、100、>100）與型別轉換。

#### 三、實戰演示

- 環境準備（依 README 指令）
  1. Clone 範例倉庫並進入專案：
     - git clone https://github.com/SpringMicroservicesCourse/spring-cloud-config-waiter-service.git
     - cd git-config-waiter-service
  2. 啟動前置服務（如使用服務發現）：
     - consul agent -dev
     - 在 config-server 專案目錄啟動 Config Server：mvn spring-boot:run
  3. 編譯並啟動 Waiter Service（開發環境）：
     - mvn clean compile
     - mvn spring-boot:run -Dspring-boot.run.arguments="--spring.profiles.active=dev"
     - 或 java -jar target/xxx.jar --spring.profiles.active=dev

- 驗證步驟（常用 curl/Postman 範例）
  1. 檢查健康狀態：
     - GET http://localhost:8080/actuator/health
  2. 查看目前配置（測試端點）：
     - GET http://localhost:8080/config/order 或 GET http://localhost:8080/actuator/configprops
  3. 建立訂單測試（POST 範例）：
     - POST http://localhost:8080/order/  body: {"customer":"張三","items":["latte","mocha"]}
     - 驗證回傳的總金額是否依目前 discount 計算。
  4. 動態修改配置流程示範：
     - 在 Config Server 的 git 倉庫中修改 waiter-service-dev.yml（例如把 order.discount: 60 -> 30），commit & push。
     - 呼叫 POST http://localhost:8080/actuator/refresh
     - 再次呼叫 /order/ 建立新訂單或 GET /config/order 驗證 discount 已更新。
  - 預期結果說明：
    - 若折扣由 60 改為 30，原先總價計算會反映新的折扣。示範中 50 元的總價在 30% 折扣下為 15（50 × 30 / 100 = 15）。
  - 常見異常與排解（示範中會即時處理）：
    - 若無法取得配置：確認 Config Server 運行、bootstrap.properties 設定正確、Consul/Eureka 是否可達。
    - 若刷新無效：確認 OrderProperties 有 @RefreshScope 並呼叫 /actuator/refresh，查看日誌以確認 Spring 有載入新屬性。

#### 四、課程小結與後續展望

- 小結（兩種配置方式的差異與優缺點）
  - 直接 URI：
    - 優點：設定簡單、明確。
    - 缺點：不利於擴展與高可用，需要手動變更 URI。
  - 服務發現（Consul/Eureka）：
    - 優點：支援多個 Config Server 實例、動態發現與高可用。
    - 缺點：需額外部署註冊中心，系統複雜度增加。
  - 選擇建議：
    - 開發/單機測試：可先用 URI 快速上手。
    - 生產/高可用場景：建議使用服務發現 + 容錯設計（retry、預設值）。
  - 重點：【#重點】決策依可用性需求與運維能力而定，務必為 Config Server 建立監控與回退機制。

- 後續章節預告
  - 下一章節將介紹「多數據源配置」（multi-datasource）：如何在同一應用中管理多個資料來源的配置、動態切換與事務處理要點，並銜接本章節的集中化配置概念，以便在多資料庫環境中仍能以配置中心統一管理連線參數與切換策略。

#### 五、Tips

- 部署與安全
  - 使用 Config Server 的加密功能或將敏感資訊（密碼、金鑰）放在受保護的環境變數或 Vault 中。
  - 為配置變更建立 Pull Request 與審核流程，避免直接在 production 修改配置。

- 建議設定
  - bootstrap.properties 放 Config Server 連線設定與 spring.application.name。
  - application.properties 放本地預設值（作為 fallback），例如 order.discount=95。
  - 在生產環境啟用監控（Actuator + Prometheus）以追蹤配置刷新與影響。

- 故障排查快速清單
  - 應用啟動連不到 Config Server：檢查 Config Server 是否在執行、bootstrap.properties 是否正確、網路連線與端口。
  - 配置變更不生效：確認 target bean 有 @RefreshScope、是否呼叫 /actuator/refresh、檢查日誌與 configprops。
  - 訂單金額計算異常：確認 discount 的來源（application.properties 或 Config Server profile），並檢查金額型別處理（請使用貨幣類型而非 float/double）。

- 最佳實務（Checklist）
  - #重點 確保配置檔在版本控制中並有變更審核流程。
  - #重點 為 Config Server 與註冊中心設計監控與告警。
  - #重點 在 Client 端提供合理的預設值與容錯策略，避免因配置中心暫時不可用導致應用啟動失敗。

附註：課堂上可依序展示「啟動 Config Server → 啟動 Waiter Service → 在 git 修改配置 → 呼叫 /actuator/refresh → 驗證訂單金額變化」的完整流程，並讓學生動手操作以加深理解。若需要，我可以把實作步驟整理成一份可直接複製貼上的操作清單給學生。

---
### 109 | 基於Zookeeper的配置中心 ― [zk-config-waiter-service]
#### 一、課程目標

- 學習重點：了解如何使用 ZooKeeper 作為 Spring 微服務的配置中心，掌握其與 Spring Cloud Config Server（以 Git 為後端）的差異、整合方式與實務操作流程；學會在運行時動態更新配置並觀察應用自動刷新行為。  
- 實務意義：在分散式系統中，配置一致性、即時性與高可用性很重要；ZooKeeper 提供強一致性與監聽（watch）機制，能支援無重新啟動的配置變更推播，適合需要即時配置更新或協調功能的微服務架構。  
- 參考資源（建議實作時打開）：
  - 課程筆記：[[109 | 基于Zookeeper的配置中心]]
  - 範例程式碼（實作練習）：[[Code/Chapter 13 服務熔斷/turbine-demo/README]]（位於 zk-config-waiter-service）
  - 官方文件：ZooKeeper（https://zookeeper.apache.org/）、Spring Cloud（https://spring.io/projects/spring-cloud）、Spring Boot（https://spring.io/projects/spring-boot）
  - 專案 README 的快速開始與指令（包含 Docker 啟動、zkCli 操作等）請以範例 repo 為準

【重點】本章核心：掌握「如何在 Spring Boot 應用中引入 Spring Cloud ZooKeeper Config，並利用 ZooKeeper 的監聽機制實現動態配置更新」。

#### 二、主體

一、為什麼選用 ZooKeeper 作為配置中心？（概念與優勢）  
- 什麼是 ZooKeeper：分散式協調服務，提供節點（znode）結構、原子性與監聽（watch）機制。  
- 優點：  
  - 【重點】即時配置更新：透過 watch 可將配置變更推送給 client，減少手動 refresh。  
  - 高可用與強一致性：適合需要一致性保證的配置場景。  
  - 可與服務發現整合：若已使用 ZK 作為註冊中心，整合成本較低。  
- 比喻：把 ZooKeeper 想成一個分層的檔案系統，服務的設定放在對應的資料夾（節點）下，當檔案內容改變時，系統會通知訂閱者。

二、與 Spring Cloud Config Server（Git）比較（差異與適用情境）  
- Spring Cloud Config Server（Git）：
  - 優點：版本管理、易於多人協作與歷史追溯（因為背後是 Git）。  
  - 缺點：若要應用端即時拿到變更，通常需要透過 /actuator/refresh 或 Bus 才能推送（需額外機制）。  
- ZooKeeper Config：
  - 優點：【重點】原生的節點監聽可即時推送變更，應用端可自動收到變更並刷新，無需手動呼叫 refresh（視實作而定）。  
  - 缺點：不像 Git 有內建的版本與 diff 歷史管理，節點管理需要小心規劃。  
- 選擇建議：若需求重視「即時性、協調與一致性」，ZK 優於 Git；若重視「配置版本管理與多人編輯流程」，Git Config 更合適。

三、Spring Cloud ZooKeeper Config 的整合要點（實務設定）  
- 依賴：加入 Spring Cloud Zookeeper Config starter（例如 spring-cloud-starter-zookeeper-config；版本需與 Spring Cloud 版本對應，例如 Spring Cloud 2024.0.x 對應 ZK client 版本）。【重點】注意 Spring Cloud 與 ZK client 的版本相容性（例如 transcript 提到 3.5 vs 3.4 的差異）。  
- 啟動流程：在 bootstrap.properties/ bootstrap.yml 中配置 ZK 連線與 config 設定，因為配置在啟動階段就要載入。範例要點：  
  - spring.application.name=waiter-service  
  - spring.cloud.zookeeper.connect-string=localhost:2181  
  - spring.cloud.zookeeper.config.enabled=true  
  - spring.cloud.zookeeper.config.root=/config  
  - spring.cloud.zookeeper.config.default-context=application  
  - spring.cloud.zookeeper.config.profile-separator=,  
- ZK 節點結構（重要）：
  - 建議使用 /config/{application}/{profile}/{key} 結構。  
  - 也可配置 default context（例如 /config/application）作為全域配置。  
- 如何放置配置：在 ZK 中每個 key 對應一個節點內容保存 value（不像單一檔案，ZK 是以節點值方式儲存）。  
- 配置載入機制：Spring Cloud Zookeeper 會在 bootstrap 階段讀取指定 root 與 context 下的節點並合併到 Environment 中。

四、動態刷新與監聽（watch）機制（技術細節與實作行為）  
- 機制說明：ZooKeeper 支援對 znode 註冊 watch，一旦節點內容變化，client 會收到通知。Spring Cloud 對此可整合以觸發 Property 源的更新。  
- 與 @RefreshScope 的關係：  
  - 可搭配 @RefreshScope 讓 Bean 在配置變更時自動刷新；但在 ZK 的情況下，若整合得當可無需人工呼叫 /actuator/refresh，因為 watch 可主動推送變更並觸發 Refresh。  
- 範例行為（從錄音與範例專案觀察到的流程）：  
  - 在 zk 上修改 /config/waiter-service/order.discount 為 30 → 應用端 log 出現 RefreshKeyChange（代表已監聽到變更）→ API 的計算結果隨即變更（例如折扣由 6 折變為 3 折，示範中金額立即改變）。  
- 注意：watch 的精確行為與 Spring Cloud 版本實作有關，測試時請檢查日誌以確認變更通知流程正常。

五、範例專案重點說明（zk-config-waiter-service）  
- 專案目的：實作一個咖啡廳訂單系統，示範如何把配置放在 ZooKeeper 並在運行時動態修改。  
- 關鍵組件與檔案：  
  - bootstrap.properties 與 application.properties（載入 ZK 連線與 Consul 配置）  
  - OrderProperties（讀取折扣、prefix 等配置）  
  - Controller（CoffeeController、CoffeeOrderController）與 Service（CoffeeOrderService）展示配置如何影響業務邏輯（例如折扣計算）  
  - README 提供快速啟動指令與 zkCli 範例（建議實作時逐步照做）  
- 服務依賴：ZooKeeper（2181）與 Consul（8500）可透過 Docker 快速啟動；確保在啟動應用前，這些中介服務先運行。

#### 三、實戰演示

步驟（可直接在課堂上操作 / 讓學生跟著做）：

1. 啟動所需服務（Docker）：
   - docker run -d --name zookeeper -p 2181:2181 zookeeper:3.8
   - docker run -d --name consul -p 8500:8500 consul:1.15
   （如使用本地安裝亦可，參考 README）

2. 在 ZooKeeper 建立配置節點（使用 zkCli 或 zkCli.sh）：
   - zkCli.sh -server localhost:2181
   - create /config/waiter-service/order.discount 60
   - create /config/waiter-service/order.waiter-prefix springbucks-

   【重點】create 指令建立節點並填入初始值，之後 set 指令可更新節點值。

3. 啟動專案：
   - mvn clean compile
   - mvn spring-boot:run
   - 確認應用在啟動時能從 ZK 讀到配置（查看啟動日誌）

4. 呼叫 API 驗證行為（使用 Postman 或 curl）：
   - POST /order/ （建立訂單），觀察折扣計算前後金額。

5. 現場修改配置並驗證無需重啟即可生效：
   - 在 zkCli 中執行： set /config/waiter-service/order.discount 30
   - 觀察應用 log 出現 RefreshKeyChange（或相應訊息），再次呼叫 API 可看到金額隨即改變。

6. 故障排除快速檢查：
   - 若 ZK 連線失敗： echo stat | nc localhost 2181
   - 檢查節點是否存在： ls /config/waiter-service
   - 檢查配置內容： get /config/waiter-service/order.discount

過程中建議學生分組操作：一組修改 ZK 節點、一組呼叫 API，觀察變更傳播延遲與日誌，並討論可能的 race condition 或一致性問題。

#### 四、課程小結與後續展望

- 小結（兩種配置方式比較）：
  - ZooKeeper 配置中心：
    - 優點：即時推播、強一致性、可與 ZK 服務發現整合。適用於需低延遲配置更新或協調需求高的場景。  
    - 缺點：缺乏像 Git 的版本管理，需要自行建立配置變更管理流程。  
  - Spring Cloud Config Server（Git）：
    - 優點：配置有版本歷史、多人協作友好。  
    - 缺點：即時推播需要額外機制（Bus、手動 refresh 等），不一定能原生做到無縫即時更新。
- 哪時選哪個：
  - 若系統重視「配置歷史與審核流程」選 Git：Config Server。  
  - 若系統重視「高頻率、即時且一致的配置變更」選 ZK。  
- 後續預告：下一章將介紹「多資料源配置」——如何在 Spring Boot / Spring Data JPA 中配置與管理多個資料來源，並處理事務、連線池與路由策略，這將與本章在服務配置與環境設定上的技巧產生連結。

#### 五、Tips

- 【重點】在 bootstrap 階段載入 ZK 配置（bootstrap.properties），確保啟動時就能取得必要配置。  
- 使用 /config/{application}/{profile} 的節點命名規範，方便管理與環境隔離。  
- 測試環境可用 Docker 快速啟動 ZK 與 Consul；生產環境請使用正式部署並注意安全性與監控。  
- 若需要版本控制，考慮把配置變更流程整合到 CI/CD 或把重要配置也同步到 Git（混合策略）。  
- 建議在重要 Bean 上使用 @RefreshScope，搭配 ZK watch 可實現無痛熱更新。  
- 監控與韌性：整合 Prometheus、Resilience4j 等，設定適當的限流與熔斷以保護服務。  
- 相容性注意：確認 Spring Cloud 與 ZK client 版本相容（錄音中提到 3.5 vs 3.4 的差異），更新前先在 staging 測試。  
- 日誌與排錯：日誌是最直接的驗證手段，變更通知的 log（如 RefreshKeyChange）能幫助確認 watch 是否生效。

結語：透過本章的講解與實作，學生應能掌握如何把 ZooKeeper 當作配置中心整合進 Spring 微服務架構，理解其優缺點並能在實際專案中選擇適合的配置策略。若你想，我可以把本講義轉成投影片大綱或示範課堂練習題目與答案，方便實際授課使用。

---
### 110 | 深入理解Spring Cloud的配置抽象
#### 一、課程目標

- 學習重點：理解 Spring Cloud Config 在分散式系統中的抽象（Property Source / Property Source Locator）、配置的載入與合併策略；掌握兩種常見配置中心的實務差異（以 Spring Cloud Config Server + Git 與 ZooKeeper 為例），並會實作「以 ZooKeeper 作為配置中心」的完整流程，包含動態生效（watch → 自動刷新）與故障排查。  
- 實務意義：在微服務環境中，配置一致性與即時性會直接影響系統可用性與運維成本；理解配置來源與刷新機制能幫助你設計更可靠的配置管理策略（例如：何時選擇 Git 為後端，何時選擇 ZooKeeper）。  
- 建議教材與實作資源：  
  - 課程筆記：[[109 | 基于Zookeeper的配置中心]]  
  - 範例程式碼（實作練習）：[[Code/Chapter 13 服務熔斷/turbine-demo/README]]（zk-config-waiter-service）  
  - 官方文件：ZooKeeper（https://zookeeper.apache.org/）、Spring Cloud（https://spring.io/projects/spring-cloud）、Spring Boot（https://spring.io/projects/spring-boot）

【重點】本章核心：Spring Cloud 將外部配置抽象為 Property Source，並透過不同的 Property Source Locator（例如 Config Server、ZooKeeper）把遠端配置合併到 Spring Environment；理解這套抽象是掌握動態配置的關鍵。

#### 二、主體

一、Spring Cloud Config 的抽象：Property Source 與合併邏輯  
- 概念說明：Spring Cloud 在 Spring Environment 中加入額外的 Property Source（類似一個額外的設定檔層），這些 Property Source 優先於應用內的 application.properties/yml，因此遠端配置會覆蓋本地設定。  
- 組成方式：系統會建立一個 Composite Property Source（例如命名為 Config Service / Zookeeper Composite），將不同 context（application+profile、application、default）依優先順序加入。  
- 比喻：把配置想成多層透明片（layer），最上層能遮蔽下層的設定。當系統搜尋某個屬性時，會從上而下檢查每一層，找到就停止。

二、Property Source Locator 的工作流程（以 Config Server 為例）  
- 機制：Property Source Locator 有一個 locate(environment) 的方法，會根據當前 Environment（包含 application name、profile、label 等）向後端（例如 Config Server）請求遠端 Environment。  
- 遠端請求：Config Server 通常透過 HTTP（在程式中常用 RestTemplate 或其他 HTTP client）向後端（例如 Git 存放的檔案）請求取得 Environment 回來，然後把其中的 Property Sources 加入 Composite。  
- 注意：錄音提到的 "Resentrate" 可能為類似 RestTemplate 的 HTTP client；若需精確細節可以回頭檢視 Config Server 的實作或問我，我可以帶你看程式碼片段。

三、Config Server 的後端擴充與加密機制  
- 支援多種 backend：Git、SVN、檔案系統、Vault（或其他加密/安全後端）等。  
- 加密與安全：如果需要把敏感配置（如密碼）放入配置中心，常見做法是使用專門的加密存取（例如 HashiCorp Vault）或 Config Server 提供的 encryption/decryption 支援。錄音中提到的某些商業/第三方加密方案也可整合於 Config Server。  
- 建議：若系統為金融或其他高度敏感領域，應評估加密方案或使用 HSM/Vault 類服務，不要僅靠 plain text 存放在後端。

四、ZooKeeper 作為配置中心的整合要點與機制  
- 啟用方式：加入 Spring Cloud ZooKeeper Config starter，並在 bootstrap.properties/ bootstrap.yml 中設定 spring.cloud.zookeeper.connect-string、config.enabled、config.root、default-context、profile-separator 等。  
- ZK 的 Property Source Locator：ZK client 會讀取 /config/{application}/{profile} 或 /config/{default-context} 下的節點，為每個 context 建立一個 ZookeeperPropertySource，最後合併成 Composite。  
- 動態刷新（watch）機制：ZK 的 Tree Cache（或 znode watch）會監聽節點新增、刪除、變更，config watcher 在收到事件後會 publish 一個 Refresh Event，Spring 的事件機制會觸發 Environment/Bean 的刷新（搭配 @RefreshScope 可讓特定 Bean 自動重載屬性）。  
- 範例行為：修改 /config/waiter-service/order.discount 的值 → ZK 的 watch 觸發 → 應用端 log 出現 RefreshKeyChange（表示已收到變更）→ 再次呼叫 API，可見計算結果已更新。  
- 【重點】相比於 Config Server（需 /actuator/refresh 或 bus）或需額外推播，ZK 的 watch 能原生支援即時推送與自動 refresh（視實作而定）。

五、配置合併與優先順序（容易混淆的地方）  
- 優先級範例（由高到低，具體依實作可微調）：application+profile（例如 waiter-service, dev） → application（應用共用） → default-context + profile → default-context（application）  
- 說明：這裡談的是「配置來源的合併順序」，不是單純「檔案載入順序」。換句話說，當同一屬性在多個 Property Source 出現時，會以上面的優先順序來決定最終值。  
- 建議：規劃 ZK/Config Server 節點結構時，先設計命名與層級（例如 /config/{application}/{profile}/{key}），以避免衝突或不易排查的覆寫問題。

六、常見誤解與注意事項  
- 誤解：以為改變後端檔案會自動「立即」生效在所有情境都成立；實務上取決於後端是否有推播機制（ZK watch vs Git-based Config Server）。  
- 注意：Spring Cloud 與後端 client 的版本相容性很重要（錄音中提到例如不同版本的 ZK client 與 Spring Cloud 需要對應處理），上線前務必在 staging 測試。  
- 日誌：變更通知的日誌（例如 RefreshKeyChange）是排查 watch/refresh 是否正常的第一線索。

#### 三、實戰演示

演示目的：從零開始把 ZooKeeper 當作配置中心，驗證修改配置後應用端如何自動生效。

1. 啟動基礎服務（建議用 Docker）  
   - docker run -d --name zookeeper -p 2181:2181 zookeeper:3.8  
   - docker run -d --name consul -p 8500:8500 consul:1.15

2. 在 ZooKeeper 建立初始配置（使用 zkCli.sh 或 zkCli）  
   - zkCli.sh -server localhost:2181  
   - create /config/waiter-service/order.discount 60  
   - create /config/waiter-service/order.waiter-prefix springbucks-

   【重點】create 建立節點並設定初始 value，之後用 set 更新值。

3. 啟動專案（範例 repo）  
   - mvn clean compile  
   - mvn spring-boot:run  
   - 檢查啟動日誌，確認有從 ZK 讀取到 Composite Property Source 與對應 key。

4. 呼叫 API 驗證（例如使用 Postman 或 curl）  
   - POST /order/ 建立訂單並觀察折扣金額是否符合 /config/waiter-service/order.discount 的設定值。

5. 即時修改配置並驗證無需重啟  
   - 在 zkCli 中執行： set /config/waiter-service/order.discount 30  
   - 觀察應用日誌是否出現類似 RefreshKeyChange 的事件，然後再次呼叫 POST /order/，確認結果改為新的折扣。

6. 故障排查小提示  
   - 若 ZK 連不上： echo stat | nc localhost 2181  
   - 檢查節點存在： ls /config/waiter-service  
   - 讀取節點值： get /config/waiter-service/order.discount  
   - 若應用未收到變更：檢查應用端是否正確啟用 ZK Config starter、bootstrap 配置是否正確，以及日誌中是否有 Watch/TreeCache 相關錯誤。

#### 四、課程小結與後續展望

- 小結（兩種配置方式差異）  
  - ZooKeeper 作為配置中心：  
    - 優點：即時推播（watch）、高一致性、與 ZK 協調/註冊機制整合容易。  
    - 缺點：缺少像 Git 那樣的版本管理/history，節點管理需額外流程。  
  - Spring Cloud Config Server（Git 為後端）：  
    - 優點：天生有版本控制與多人協作的好處，便於審計與回滾。  
    - 缺點：即時推播需額外機制（/actuator/refresh、Spring Cloud Bus 等），操作複雜度較高。  
- 建議的採用場景：  
  - 若需即時配置、強一致性與協調功能（例如動態限流參數、feature toggle 等）→ 優先考慮 ZooKeeper。  
  - 若需配置審計、變更歷史與多人協作 → 優先考慮 Git-backed Config Server，必要時搭配 Bus/Push 機制實現廣播刷新。  
- 後續預告：下一章將介紹「多資料源配置」（multi-datasource）：如何在 Spring Boot/Spring Data 中管理多個資料來源、事務邊界、連線池與路由策略，這與本章的配置管理會有密切關聯（配置如何驅動資料源切換、環境分流等）。

#### 五、Tips

- 【重點】把 ZK 的配置載入放在 bootstrap.properties/ bootstrap.yml（啟動階段就讀取），以確保 application 啟動時能拿到必要設定。  
- 把配置節點規範化：/config/{application}/{profile}/{key}，可減少衝突並方便排查。  
- 若需要同時兼顧版本管理與即時性，可採混合策略：主要配置放 Git（有版本與審計），關鍵即時參數同步至 ZK（或採用 Vault+推播）。  
- 在需要自動刷新 Bean 的地方加上 @RefreshScope，並觀察日誌中的 RefreshEvent 以驗證生效。  
- 上線前務必驗證 Spring Cloud 與後端 client 的版本相容性，並在 staging 環境做壓力與一致性測試。  
- 對於敏感資料，務必使用加密後端或 Vault/HSM，不要把密碼以明文存放在 ZK/Git。  
- 使用 Prometheus / 日誌聚合監控 ZK 與 Config Server 的可用性，當配置推播失敗時能儘快告警。

如果你需要，我可以把本講義整理成投影片大綱、示範課堂練習題（含答案）或直接產出上課用的逐步示範腳本（含 terminal 指令與預期日誌片段），你要哪一種格式？另外，錄音中提到的 "Resentrate" 我推測是指 HTTP client（例如 RestTemplate）；若你希望我把該段落對應到程式碼層面（示範 locate → RestTemplate.getForObject → 解析 Environment 的實作），我可以補上範例程式碼。

---
### 111 | 基於Consul的配置中心 ― [consul-config-waiter-service]
#### 一、課程目標

- 說明：讓學生理解如何在 Spring 微服務架構中，使用 Consul 作為配置中心來管理與動態更新服務設定，並能在實務上觀察配置變更如何不重啟即時生效。  
- 學習重點：
  - 【重點】如何在專案中啟用 Consul 作為配置來源並在啟動階段讀取遠端配置。  
  - 【重點】Consul 的配置存放結構與支援格式，以及如何在服務中取得這些配置。  
  - 【重點】Consul 的自動刷新機制是如何運作（配置檢測 → 事件發佈 → 需要刷新的 bean 被更新）。  
  - 【重點】實務操作流程：啟動 Consul、在 UI 編輯配置、觀察應用端自動更新。  
- 實務意義：降低部署成本與停機風險，提升配置管理的彈性與運維效率。  
- 相關資源（便於練習）：
  - Vault 筆記範例：[[111 | 基于Consul的配置中心]]  
  - 專案示例說明：[[Code/Chapter 13 服務熔斷/turbine-demo/README]]（consul-config-waiter-service）  
  - Consul 官方文件：https://www.consul.io/docs  
  - Spring Cloud Consul 文件：https://spring.io/projects/spring-cloud-consul

#### 二、主體

1) 為何選擇 Consul 作為配置中心？  
過渡語：先從選擇理由說起，幫助學生建立選型判斷基準。  
- 說明：Consul 同時提供配置管理與服務註冊/發現功能，對於微服務環境能一併處理設定分發與服務目錄。它支援多種配置格式，並提供直覺的管理介面。  
- 【重點】主要優勢：動態配置更新、格式彈性、與服務發現整合、叢集高可用。  
- 比喻：把 Consul 想成「集中配置的資料庫」，服務像客戶端到資料庫查設定，資料庫更新時會通知需要的人。

2) 在 Spring 應用中如何與 Consul 整合（概念說明）  
過渡語：了解整合的基本流程，才能在實作時把握要點。  
- 說明：整合的重點在於兩件事：一是啟動階段要能從 Consul 取得配置並注入到 Spring 的環境；二是在運行時能偵測到配置變更並更新需要的元件。  
- 【重點】啟動階段需確保應用能連上 Consul 並讀取遠端配置；運行時常用的做法是標註需要動態刷新的 bean，當配置變更事件發生時，該 bean 會被重新注入最新設定。

3) Consul 中配置的組織與格式（概念化）  
過渡語：配置如何在 Consul 中組織，決定了查詢與管理的便利性。  
- 說明：通常會把全域配置與服務專屬配置分開管理，依服務名稱與環境（profile）來劃分路徑，並可採用 YAML、Key-Value、JSON 或檔案等多種格式。  
- 【重點】良好的路徑與命名規則能降低衝突並提升可維護性；若預設節點名稱不合需求，可透過配置參數調整映射方式。

4) 動態刷新機制：從變更到生效的流程  
過渡語：把黑盒打開，解釋變更是如何流到應用的。  
- 說明：系統會在後台透過檢測機制週期性取得 Consul 上的配置內容並與先前版本比較；若發現變動，會發出事件通知應用。應用接收到事件後，會針對標記為可刷新的元件執行重新注入，達成配置即時生效。  
- 【重點】關鍵組件包括：遠端配置的定位器（把 Consul 內容轉為 Spring 可讀的設定來源）與檢測/監測機制（負責發現變動並發事件）。檢測頻率是可以調整的，需在即時性與資源消耗間取得平衡。

5) 與其他配置中心（例如 Zookeeper）之比較（決策指南）  
過渡語：理解差異，有助於在不同需求下選擇最合適的技術。  
- 說明：Consul 擅長快速上手、介面友善、與服務發現整合；Zookeeper 更偏向提供嚴格的一致性與事件通知機制。  
- 【重點】選擇依據應包含：一致性需求（強一致 vs 最終一致）、即時性需求、運維複雜度與安全性需求。

#### 三、實戰演示

過渡語：實作以專案範例為主線（consul-config-waiter-service），重點示範整體流程與觀察點。

- 準備環境：請確保有可用的 Consul 服務（可本地或遠端），並將範例專案拉到開發機進行測試。  
- 啟動應用並確認狀態：在應用啟動後，檢查應用的健康狀態與監控端點，確認應用已成功從 Consul 讀取配置。  
- 在 Consul UI 建立或修改服務專屬的配置：於指定路徑放入所需設定（例如訂單折扣或前綴字串等），儲存後系統會開始檢測變更。  
- 觀察自動刷新流程：修改配置後，觀察應用端日誌是否顯示檢測到變更並發出刷新事件；使用相關 API 呼叫以驗證新的設定已被應用在業務流程上。  
- 常見檢查點：
  - 應用是否在啟動時成功連上 Consul。  
  - 應用是否有標示需動態刷新的元件。  
  - 修改配置後是否在合理時間內被檢測到並生效（若未生效，檢查網路、權限與檢測設定）。

#### 四、課程小結與後續展望

- 小結（差異與優劣一覽）：
  - Consul：易用、格式彈性、與服務註冊/發現整合佳；缺點在於預設以輪詢方式檢測變更，需注意檢測頻率對資源的影響。  
  - 其他方案（如 Zookeeper）：在事件通知與一致性控制上有不同權衡；選用時請依系統需求（一致性 vs 可用性、即時性 vs 成本）做判斷。  
  - 【重點】實作時必須同時考量安全性（ACL、TLS）、敏感資訊儲存策略，以及監控/日誌的配置以利排障。  
- 後續預告：下一章節將介紹「多數據源配置」，重點會涵蓋同一應用中多個資料來源的管理、連線池與事務處理策略，以及在微服務架構下多數據源的常見設計模式，與本章節的配置管理概念自然銜接。

#### 五、Tips

- 【Tip】敏感資訊不要直接放在公開的配置中心；在生產環境應使用專門的密鑰管理服務或啟用 Consul 的 ACL 與通訊加密。  
- 【Tip】調整配置檢測頻率時，評估即時性需求與系統負載，避免過短間隔導致不必要的資源消耗。  
- 【Tip】僅對真正需要動態刷新的 bean 使用刷新註解，避免過度重新載入導致不穩定或效能問題。  
- 【Tip】在測試階段建議使用獨立的 Consul 環境（例如容器化的測試實例），生產環境則以叢集與備援方式部署並啟用安全機制。  
- 【Tip】搭配監控（如 Micrometer 與 actuator）追蹤配置更新事件與系統健康，能更快速定位問題來源。

---
### 112 | 基於Nacos的配置中心 ― [nacos-config-waiter-service]
#### 一、課程目標

【重點】理解並能實作在 Spring Cloud 微服務架構中，使用 Nacos 作為配置中心，並與 Consul 做服務發現的混合配置方案。掌握動態配置刷新機制、常見故障排除與生產環境最佳實務。

學習重點與實務意義：
- 了解混合架構的動機：Consul 負責服務註冊/發現，Nacos 負責集中配置管理，避免單一平台風險並整合團隊技術能力。
- 能配置 bootstrap.properties 與 Nacos 連線參數，並使用 @RefreshScope 與 ConfigurationProperties 做動態屬性注入。
- 驗證動態配置刷新流程（從 Nacos 發布 — 應用監聽變更 — RefreshEvent）與使用 Actuator 相關端點進行檢視與手動刷新。
- 能排查常見問題（版本不相容、配置未載入、服務未註冊、端口衝突等）。

實作與參考資源（課後練習）：
- 專案範例（教學用）：[[Code/Chapter 13 服務熔斷/turbine-demo/README]]
- 錄音與補充筆記：[[112 | 基于Nacos的配置中心]]
- 官方文件：
  - Nacos 官方文件：https://nacos.io/zh-cn/docs/what-is-nacos.html
  - Consul 服務發現：https://www.consul.io/docs/discovery/services
  - Spring Cloud Alibaba：https://github.com/alibaba/spring-cloud-alibaba
  - Spring Cloud Consul：https://docs.spring.io/spring-cloud-consul/docs/current/reference/html/

#### 二、主體

1) 架構概覽 — 混合配置的設計意圖與角色分工  
【重點】Consul = 服務發現（像黃頁）；Nacos = 配置中心（像控制塔）  
說明：在此範例中，我們採用 Consul 做服務註冊與健康檢查，Nacos 做集中化配置管理與動態刷新。這種分工讓每個工具專注於自己擅長的領域，提升可靠度與可維護性。比喻：Consul 提供「服務地址黃頁」，Nacos 提供「運行參數控制台」。

2) 開發與執行需求（快速上手）  
【重點】必備環境：Java 21、Maven、Consul、Nacos（可用 Docker）  
步驟概述：
- 啟動 Consul：consul agent -dev（本地 dev 模式）
- 啟動 Nacos（standalone）：nacos/bin/sh startup.sh -m standalone 或使用 docker-compose 
- 編譯並啟動應用：mvn clean compile && mvn spring-boot:run

3) 核心配置說明（bootstrap.properties 與 OrderProperties）  
【重點】把 Nacos 設為遠端配置來源；使用 bootstrap.properties 指定服務名稱與 Nacos/Consul 位址  
解釋：
- bootstrap.properties 裡設定 spring.application.name、Consul 位址與 Nacos server-addr 以及 spring.cloud.nacos.config.refresh-enabled=true，確保在應用啟動階段就能連到 Nacos 並載入配置。
- 使用 @ConfigurationProperties(prefix="order") 並搭配 @RefreshScope 的 bean（例如 OrderProperties）來支援動態刷新。若 Nacos 更改該 key，Spring 容器在收到 refresh 事件後會重新注入新值。

4) 動態刷新機制原理（Nacos → 應用）  
【重點】Nacos 監聽器會在變更時 push 通知，框架端有 refresher/listener 將變更轉為 Spring RefreshEvent  
解析：
- Nacos 客戶端會對 Data ID（通常以應用名為 prefix、profile 為 suffix）進行監聽，當配置變更時會觸發回調；
- Spring Cloud Alibaba 的自動化元件會把這些回調轉為刷新事件，觸發 @RefreshScope 的 bean 更新與相關事件處理流程（可檢視程式碼中 guide-worker、add-listener、refresher 的實作以理解細節）；
- 注意：某些實作以 thread-pool 處理監聽與通知，這影響延遲與穩定性。

5) 監控與健康檢查（Actuator 與監控端點）  
【重點】啟用管理端點（/actuator/health, /actuator/env, /actuator/refresh）來驗證註冊與配置來源  
說明：
- /actuator/health：確認應用與依賴（例如 Consul）狀態。
- /actuator/env：可查到配置來源是否來自 nacos（grep "nacos"）。
- /actuator/refresh：手動觸發刷新（若開啟），用於測試或故障排除。

6) 依賴與版本相容性（關鍵風險控制）  
【重點】Spring Cloud Alibaba 必須用 2023.0.1.0（README 強調為關鍵版本），Spring Cloud 與 Spring Boot 的組合也要匹配。  
說明：若版本不對（例如 spring-cloud-alibaba 版本錯誤），Nacos 配置可能無法載入。開發時務必在 pom 的 dependencyManagement/import 正確指定 Spring Cloud 與 Alibaba 的 BOM。

#### 三、實戰演示（課堂操作步驟）

演示前準備：確保 Java、Maven、Docker（或本機 Consul/Nacos）可用。

步驟 A：啟動基礎服務
- consul agent -dev
- cd nacos/bin && sh startup.sh -m standalone
或使用 docker-compose up -d consul nacos

步驟 B：在 Nacos 控制台新增配置
- 打開 http://localhost:8848/nacos，帳號 nacos/nacos
- 建立 Data ID：waiter-service（或 waiter-service.yml，視 file-extension）
- Group：DEFAULT_GROUP
- 內容（properties 或 yaml）例如：
  order.discount=55
  order.waiter-prefix=fengqing-%

步驟 C：啟動應用程式
- mvn clean compile
- mvn spring-boot:run
- 驗證：curl http://localhost:8080/actuator/health
- 檢查 Consul UI：http://localhost:8500（是否出現 waiter-service）

步驟 D：測試動態刷新
- 在 Nacos 編輯 waiter-service 配置（修改 order.discount）
- 在應用端查看：curl http://localhost:8080/actuator/env/order.discount
- 或手動觸發：curl -X POST http://localhost:8080/actuator/refresh
- 建立新訂單以驗證折扣是否已生效（POST /order/）

步驟 E：調試與查看日誌（若配置未生效）
- 在 bootstrap.properties 增加 debug 日誌：
  logging.level.com.alibaba.cloud.nacos=DEBUG
  logging.level.org.springframework.cloud.consul=DEBUG
- 檢查 actuator env 是否顯示 nacos 為來源：
  curl -s "http://localhost:8080/actuator/env" | grep -i "nacos"

#### 四、課程小結與後續展望

總結：本章學到將 Nacos 作為配置中心、Consul 作為服務發現的混合架構實作重點：
- 【重點】Nacos 負責集中化與動態配置刷新；Consul 負責服務註冊與健康檢查。
- 【重點】必須注意版本相容性（spring-cloud-alibaba=2023.0.1.0 與 Spring Cloud / Boot 的匹配）。
- 【重點】使用 @RefreshScope + actuator 可在不重新啟動應用下更新配置；但要理解底層的 listener 與事件通知流程以避免競態或延遲問題。

兩種配置方式差異（本地 application.properties vs Nacos 遠端配置）：
- 本地配置（application.properties / bootstrap.properties）
  - 優點：簡單、啟動快、方便本地開發。
  - 缺點：無法跨多實例統一管理，變更需重新部署或手動管理，容易版本不一致。
- Nacos 遠端配置
  - 優點：集中管理、支援動態刷新、可分 namespace/group/environment，方便多環境隔離與運維。
  - 缺點：依賴外部服務（可用性/安全性需設計）、需處理版本與相容性、部署與測試門檻較高。

後續展望：
- 下一章節將介紹「多數據源配置」，包含如何在 Spring 中配置與管理多資料來源，以及與微服務情境下的資料治理與讀寫分離策略。

#### 五、Tips

- 【重點】版本鎖定：spring-cloud-alibaba 必須使用 2023.0.1.0（否則 Nacos 配置可能不生效）。
- 啟用 Actuator 常用端點（health, env, configprops, refresh, prometheus）方便排查與監控。
- 避免重複配置：移除 application.properties 中會覆蓋遠端配置的重複條目，確保優先順序一致。
- 本地快速啟動：使用 docker-compose up -d consul nacos 可加速開發測試環境建立。
- 日誌與追蹤：在排查時把 com.alibaba.* 與 org.springframework.cloud.consul 設為 DEBUG，能看出 Nacos 客戶端是否正確註冊監聽器與接收到通知。
- 常見故障快速排查：
  - Nacos 未生效：檢查依賴版本、Data ID 與 group 名稱是否正確、Nacos 是否可連線。
  - Consul 未顯示服務：檢查 consul agent 是否啟動、網路端口、actuator health 是否可用。
  - Port 被占用：pkill -f "nacos-config-waiter-service" 或調整 server.port。

參考練習（建議課後作業）：
- 實作：在 Nacos 中新增多個環境 namespace（dev/prod），並在應用中依環境讀取不同配置。
- 測試：模擬 Nacos 配置變更並驗證應用的刷新流程，觀察日誌與 RefreshEvent 流程。
- 延伸：嘗試在集群環境下（非 standalone）部署 Nacos，體驗在多節點下的可用性差異。
---
### 113 | SpringBucks實戰項目進度小結
#### 一、課程目標

- 本章學習重點：理解 Spring 生態中常見的配置中心（Spring Cloud Config、Zookeeper、Consul、Nacos、Apollo）如何管理與下發配置，掌握配置刷新機制的差異與實作方式，並能在微服務中設計可動態變更的設定（如折扣、服務前綴等）。
- 實務意義：在微服務環境中，配置頻繁變更是常態；選擇合適的配置中心與刷新策略能降低重啟成本、提升部署彈性與運維管理能力。
- 相關資源連結（練習用）：
  - Spring Cloud Config 官方文件：https://spring.io/projects/spring-cloud-config
  - Spring Cloud Bus 與 Actuator：https://spring.io/projects/spring-cloud-bus
  - Apache Zookeeper：https://zookeeper.apache.org/
  - Consul 官方文件：https://www.consul.io/
  - Nacos 官方文件：https://nacos.io/
  - Ctrip Apollo（配置治理）：https://github.com/ctripcorp/apollo

【重點】課程目標：掌握配置中心的種類、刷新機制與在 Spring 應用中的整合實務。

#### 二、主體

段落一：配置中心的角色與基本原理  
配置中心的核心職責是集中管理應用配置，將環境或參數從程式碼中抽離。對 Spring 應用而言，配置中心通常以一組 property source 的形式注入到 Spring Environment 裡。Spring Cloud Config 的做法是透過 PropertySourceLocator 去定位遠端的 property source，然後把它加入到應用的 property sources 順序中，讓查找屬性時能優先讀取遠端配置。

過渡：了解了「配置被如何注入」後，接下來看不同配置中心如何處理配置變更與刷新。

段落二：配置刷新機制比較（核心差異）  
- Spring Cloud Config：本身不具備自動全局廣播刷新功能。若要讓所有實例一致性刷新，可以：
  - 在需要動態刷新的 bean 上加上 RefreshScope（或使用 @RefreshScope），
  - 並結合 Spring Cloud Bus 做事件廣播，讓所有服務收到配置變更事件後觸發刷新。
  【重點】需要 combination：RefreshScope + Cloud Bus 才能做到「全局自動刷新」。  
- Zookeeper：靠節點監聽（watcher）機制，當節點資料變更時，自身能觸發客戶端的回調，實現即時刷新。  
- Consul、Nacos：通常採用「定時輪詢」的方式去檢測變更（periodic polling），一旦偵測到變更會發出 refresh event，效果類似手動呼叫 actuator 的 /refresh（POST）。  
- Apollo：提供即時修改生效的能力，且額外提供完善的權限管理、發布審核與審計功能，適合對配置變更有嚴格治理需求的組織。

過渡：有了刷新機制的差異概念，下一步看看如何在程式碼與專案層面整合並示範一個實際案例。

段落三：Spring Cloud 在上層的抽象與開發者體驗  
Spring Cloud 為不同的配置中心提供了抽象層，使得上層應用在程式碼上不需關心底層配置中心的實作差異。實作差別往往體現在 pom（或 build）中替換不同的依賴，以及在 bootstrap.yml（或 bootstrap.properties）中配置對應的端點與認證資訊。換言之，開發者可以用相近的程式碼與註解（例如 @Value、@ConfigurationProperties、@RefreshScope）來取得與刷新配置。

【重點】上層程式碼一致性：依賴與 bootstrap 設定改變即可切換配置中心，而應用邏輯不需大幅變動。

段落四：實例說明 — waiter service 的配置應用（概念化）  
場景：為 waiter service 新增可由配置中心管理的設定：order 的折扣（discount）、服務名稱或前綴（waiter.prefix）、商品原價累加邏輯等。  
實作重點：
- 在配置中心（Config Server / Zookeeper / Nacos / Consul / Apollo）配置 discount 和 waiter.prefix。  
- 應用啟動時透過 PropertySource 載入，計算訂單金額：先把每個 coffee 的原價累加成 subtotal，再乘以 discount，最後加上其他必要項目，得到最終金額。  
- 若改變 discount 的值並希望立即生效：在 Spring Cloud Config 情境下，需發出 refresh event（例如透過 Spring Cloud Bus 廣播或對單一實例呼叫 /actuator/refresh）。在 Zookeeper/Nacos/Consul 則依其監控或輪詢機制會觸發相同效果。

比喻幫助理解：可以把配置中心想成「全公司的壁櫥」，應用啟動時把所需的「調味料」從壁櫥取出放到自己的工作台（PropertySource）；若壁櫥裡的調味料改變，有些壁櫥會直接通知每個工作台（Zookeeper watcher），有些會定時有人巡視並通知（Consul/Nacos 的輪詢），而有些需要你在每個工作台安裝一個「接受廣播的收音機」來接收變更（Cloud Bus）。

#### 三、實戰演示

步驟概覽（示範用 waiter service）：
1. 建立一個簡單的 Spring Boot 應用（waiter service），加入 Spring Cloud Config Client 或其他對應 client 依賴（pom 中切換依賴以測試不同配置中心）。  
2. 在 bootstrap.yml 加入對配置中心的連線設定（URI、命名空間、認證等）。  
3. 在配置中心新增配置項：
   - waiter.discount = 0.9
   - waiter.prefix = "WTR-"
4. 在服務中使用 @ConfigurationProperties 或 @Value 注入設定，並把計算訂單金額的邏輯放在一個服務方法中（subtotal * discount）。  
5. 啟動多個 waiter service 實例，修改配置中心中的 discount 值：
   - 若使用 Spring Cloud Config + Cloud Bus：發起一個變更並透過 Bus 廣播，觀察所有實例的配置同步變更。  
   - 若使用 Zookeeper：修改節點值，觀察實例是否透過 Node Watcher 即時刷新。  
   - 若使用 Consul/Nacos：修改配置，等待輪詢週期完成或手動觸發 refresh event，並觀察效果。  
6. 演示額外管理流程：在 Apollo 中提交配置、發起審核並發布，示範其權限與審計流程對企業環境的重要性。

提示性的實作細節：
- 在需要動態刷新的 bean 上加入 @RefreshScope（或使用 Spring Boot 的刷新相關註解/機制）。  
- 若用 Cloud Bus，啟用消息中介（如 RabbitMQ 或 Kafka）作為事件傳播管線。  
- 測試時可透過 curl 或 Postman 對 /actuator/refresh（或 /actuator/busrefresh）發出 POST 以模擬手動刷新。

【重點】實作流程：替換依賴 → bootstrap 設定 → 在配置中心設定值 → 啟動實例 → 觸發變更並觀察刷新效果。

#### 四、課程小結與後續展望

- 小結兩種主要配置刷新方式的差異與優缺點：
  - 即時通知（如 Zookeeper watcher）
    - 優點：變更幾乎即時生效、延遲低。
    - 缺點：需維持長連線/watcher 管理，對大規模節點可能有壓力。
  - 輪詢（如 Consul、Nacos 的定時刷新）
    - 優點：實作簡單、對服務端壓力可控（透過設定輪詢頻率）。
    - 缺點：存在刷新延遲，非即時。
  - 廣播式（Spring Cloud Bus + RefreshScope）
    - 優點：可達到集中式一鍵刷新多實例，適合分佈式系統。
    - 缺點：需額外的消息中介，並增加系統複雜度與維運成本。
  - 管理型配置中心（Apollo）
    - 優點：提供權限控管、發布審核、審計記錄，適合企業治理需求。
    - 缺點：學習與部署成本較高。
- 幫助學生建立完整概念：選擇適合的配置中心應考量「一致性需求（即時 vs 延遲）」「治理需求（是否需要審核/權限）」「運維成本（消息中介、watcher 管理）」等因素。

預告下一章節：將介紹「多數據源（multiple data sources）配置」，包括在 Spring Boot 中管理多個資料庫連線、事務範圍與配置注入，銜接後續應用層的資料存取設計。

【重點】選擇策略：按實際業務對即時性、治理與運維成本做取捨。

#### 五、Tips

- 測試環境建議：先在本地或測試網路搭建一套輕量配置中心（例如 Nacos 或 Consul 的單機模式）習慣配置與刷新流程，再演練 Cloud Bus 與消息中介的整合。  
- 使用 @RefreshScope 時注意：被該註解管理的 bean 在刷新後會以 proxy 的方式重新載入，若持有外部資源或有複雜初始化流程，需妥善處理資源釋放與重建。  
- 若系統對配置變更需嚴格審核，優先考慮 Apollo 類型產品或在 CI/CD 流程中加入配置審核步驟。  
- 日誌與指標：在實作配置刷新時，加入清晰的日誌與監控指標，方便追蹤何時誰修改了哪些配置、哪些實例完成了刷新。  
- 分享與討論：鼓勵大家回去檢視公司現有的配置管理策略，並在課後留言區分享你們的做法與遇到的問題，互相學習最佳實務。

【重點】實務建議：從小型測試開始、注意資源管理、並建立審計與監控機制。

---
# Chapter 15：Spring Cloud Stream (4講)
### 114 | 認識Spring Cloud Stream
#### 一、課程目標：

本章目標是讓學生掌握在 Spring Cloud 應用中如何導入消息驅動（message-driven）設計，並能實作基本的生產者/消費者範例。學習重點包括：
- 了解 Spring Cloud Stream 的定位與核心概念（Binder、聲明式綁定、Consumer Group、Partition）。
- 能以註解或訊道（MessageChannel）方式實作訊息的發送與接收。
- 知道常見中介軟體（如 RabbitMQ、Kafka）的抽象化與客製化配置方式。
- 理解消費者群組與分區對消息傳遞語意（至少一次、一次且僅一次、順序性）的影響。

【重點】
- Spring Cloud Stream 是一層「Binder（或稱 Bundle）」抽象，將底層不同消息中間件（Kafka、RabbitMQ 等）統一為一致的應用接口。
- 主要學習範式：聲明式（註解/介面綁定）與程式式（MessageChannel/功能性函數）兩種實作方式。

延伸資源（建議練習與參考）
- Spring Cloud Stream 官方文件（請參考課堂資源連結）
- 本地安裝並練習 Kafka / RabbitMQ（Docker 快速啟動範例）
- 範例程式碼：建立 maven/gradle 專案，加入相應 binder 依賴並執行（課堂提供範例 repo）

#### 二、Spring Cloud Stream 概念與架構說明

首先介紹 Spring Cloud Stream 的核心概念與為何使用它：
- Spring Cloud Stream 是一個輕量框架，用來構建消息驅動的應用。它提供「聲明式的程式設計模型」，也就是以註解或配置來聲明應收/發的訊息通道與相關屬性。
- Binder（或文檔中稱的 Bundle）是最重要的抽象。Binder 將不同消息中間件的差異包裝起來，對應到應用端提供相同的接口。對開發者而言，只需跟 Binder 互動，不必過度關注底層細節。

比喻說明：
- 可把 Binder 想像成「電源轉接器」，應用端只要插上統一介面，底下轉接器會根據環境（Kafka、RabbitMQ）提供不同的電壓/接腳實作，應用不需每次重新設計插座。

【重點】
- Binder 讓應用程式具有跨中介軟體的移植性。
- 若需要使用中介軟體特有功能，Spring Cloud Stream 也允許在配置檔中做客製化設定。

#### 三、聲明式綁定（Annotation-based）——設計與實作要點

聲明式綁定是本章重點之一，常見做法如下：
- 定義一個介面，介面方法以 @Input 或 @Output 標註，代表某個 channel 的接收或發送端。
- 在應用 main 類或配置類上加入 @EnableBinding(YourBindingInterface.class)，啟用綁定。
- Spring Cloud Stream 會把對應的 MessageChannel bean 注入到容器，你可以直接使用或透過 @StreamListener 等註解接收消息。

範例流程（概念性步驟）
1. 建立介面：
   - 方法標註 @Input("inputChannel") 或 @Output("outputChannel")。
2. 啟用綁定：
   - @EnableBinding(MyBindings.class)
3. 發送消息：
   - 注入 MessageChannel（對應 output）並呼叫 send(message)。
   - 或將方法 return 的值透過 @SendTo 發送到指定 channel。
4. 消費消息：
   - 使用 @StreamListener("inputChannel") 或在函數上配置要處理的 channel。

【重點】
- 聲明式更符合 Spring 的習慣，程式可讀性高、開發快速。
- 常用註解：@EnableBinding、@Input、@Output、@StreamListener、@SendTo

過渡語句：接下來說明與實作相關的語意控制（consumer group、partition 等），這些會直接影響消費行為與系統擴展性。

#### 四、Consumer Group 與 Partition（分區）概念與實務影響

Consumer Group（消費者群組）
- 基本語意：同一個 consumer group 裡的多個實例，會共同分擔來自該 topic/queue 的消息（通常一條消息只會被 group 中一個消費者處理）。
- 使用場景：當多個系統或服務都必須各自收到相同消息時，應使用不同的 consumer group，使每個系統各自收到並處理一次消息。
- 注意：即便使用 consumer groups，仍需考慮消息重複投遞、重試與去重策略。

Partition（分區）
- 將同一主題拆為多個分區，達到水平擴展與一定程度的訊息局部有序性。
- 同一 partition 的消息會被送到「相同的消費者實例」，因此可在 partition 內近似保證順序性。
- 實務策略：生產者在發送時可帶上 partition key，消費者可配置 partition 數量以匹配吞吐與消費實例數量。

【重點】
- Consumer Group 解決「同一訊息被多個系統各自消費」的需求。
- Partition 提供「可預期的序列性」與「負載分攤」，但增加系統設計複雜度（例如 rebalancing、offset 管理）。

#### 五、發送與接收消息的實作細節

兩種常見做法：
1. 透過注入的 MessageChannel 呼叫 send(message)
   - 程式式的發送方式，適合需在程式邏輯中明確控制訊息建構與發送時機。
2. 使用註解方式（@SendTo 或 @StreamListener）
   - 方法式的處理：方法回傳值會被送到指定 channel，或使用 @StreamListener 標註方法直接處理進來的消息。

實務提醒：
- message 的 payload、headers 與 content-type 需要配合（特別是在跨系統/跨語言整合時）。
- 在生產環境請考慮以下防護：重試策略、死信隊列（DLQ）、訊息去重與事務一致性（若需）。

【重點】
- 發送：MessageChannel.send(...) 或 @SendTo。
- 消費：@StreamListener 或功能性函數（function bean）。
- 一定要在配置檔（application.yml/properties）明確指定 binder、group、partition 等屬性。

過渡語句：理論說明後，下面給出一個可操作的實戰演示流程，便於快速上手。

#### 六、實戰演示（步驟式教學）

演示目標：建立一個簡單的生產者與消費者，使用 Spring Cloud Stream + Kafka Binder（亦可改為 RabbitMQ）。

準備
- 使用 Spring Initializr 建立專案，加入 spring-cloud-stream 與 spring-cloud-starter-stream-kafka（或 rabbit）依賴。
- 本地啟動 Kafka（或 RabbitMQ），可用 Docker 快速啟動。

步驟概覽
1. 定義綁定介面
   - interface MyBindings { @Input("in") SubscribableChannel in(); @Output("out") MessageChannel out(); }
2. 啟用綁定
   - @SpringBootApplication
     @EnableBinding(MyBindings.class)
     public class App { ... }
3. 生產者實作（兩種方式示例）
   - 程式式：注入 MessageChannel out，呼叫 out.send(MessageBuilder.withPayload(...).build());
   - 註解式：在一個方法上使用 @SendTo("out")，return 資料。
4. 消費者實作
   - @StreamListener("in")
     public void handle(String payload) { // 處理 }
5. 在 application.yml 設定 binder 與 consumer group、partition
   - spring:
       cloud:
         stream:
           bindings:
             in:
               group: myGroup
               destination: topicName
             out:
               destination: topicName
           kafka:
             binder:
               brokers: localhost:9092
6. 執行測試
   - 啟動多個消費者實例，觀察 consumer group 如何分攤消息。
   - 測試帶 partition key 的發送，觀察 partition 與順序行為。

實務提示
- 從日誌觀察 offset 與 consumer rebalance，熟悉中間件行為。
- 若要測試 DLQ 或重試，調整 binder 的相關屬性並模擬拋異常場景。

【重點】
- 實作時分離「應用邏輯」與「消息綁定/config」，方便後續維護與測試。
- 開發環境建議使用容器化中間件（Docker），快速重置與重播測試資料。

#### 七、課程小結與後續展望

總結兩種常見配置/實作方式之差異與優缺點：
- 聲明式（@EnableBinding + @StreamListener / @Input/@Output）
  - 優點：語意清楚、與 Spring 生態整合良好、開發快速。
  - 缺點：在某些新版本中被功能性模型（functional programming model）漸漸取代，對於高度程式式控制的場景可能不夠靈活。
- 程式式 / 功能性（MessageChannel send / functional beans）
  - 優點：程式控制更細、便於在程式流程中直接操作、與函數式風格整合好（例如用 Supplier/Function/Consumer bean）。
  - 缺點：程式碼較詳盡，開發初期需要更多樣板程式；跨中介軟體的可移植性需透過 binder 配置維持。

【重點】
- 選擇哪種方式取決於團隊熟悉度、專案需求（是否需要細緻的發送控制）、以及 Spring Cloud Stream 的版本與社群建議。

後續展望
- 下一章節預告：會介紹多數據源（multi-data-source）配置，從資料庫層面延伸到如何在微服務中處理多個資料來源的整合與事務管理，與本章的消息傳遞在實務上常常會結合使用（例如以消息觸發跨資料源的流程）。

#### 八、Tips：

- 【Tip】差異化測試：在開發時同時啟動多個消費者實例測試 consumer group 與 partition 行為，觀察重平衡（rebalance）與吞吐量變化。
- 【Tip】若需確保「一次且僅一次」語意，除了中間件配置外，還要在消費端做去重或採用分散式事務/補償策略。
- 【Tip】在多環境部屬時，把 binder 的 brokers/hosts 透過環境變數或配置中心管理，避免硬編碼。
- 【Tip】閱讀官方文件時注意版本差異；Spring Cloud Stream 近年有 functional model 與 annotation model 的差異，依專案版本選擇適合的實作方式。
- 【Tip】實務上建議在消費者實作中加入良好的錯誤處理（重試策略、DLQ）、以及監控（消費延遲、offset）能力。

如果你希望，我可以：
- 幫你產出一份包含範例程式碼（完整 Java/Gradle 專案結構）的示範範例，或
- 針對 Kafka 或 RabbitMQ 分別列出具體的 application.yml 範例與注意事項。

你想先要哪一個實作範例？

---
### 115 | 通過Spring Cloud Stream訪問RabbitMQ  ― [rabbitmq-waiter-service, rabbitmq-barista-service]

#### 一、 課程目標

本章節目標是讓學生理解並能實作使用 Spring Cloud Stream 結合 RabbitMQ 的事件驅動微服務設計，包含系統架構、訊息流、實作要點、部署與除錯技巧。學完本章，學生能：

- 理解 Spring Cloud Stream（函數式模型）與 RabbitMQ 的整合方式與配置概念。  
  【重點】掌握 function-based 綁定與 StreamBridge 的使用情境。
- 能在本地啟動 RabbitMQ 與 MariaDB，編譯並運行 Waiter 與 Barista 兩個服務，驗證訊息流程。  
  【重點】能使用 RabbitMQ 管理介面檢查 Exchange/Queue/Binding。
- 能閱讀並理解核心程式：發送訊息（Waiter 的 updateState）與接收處理（Barista 的 Consumer\<Long>）。  
  【重點】理解訊息可靠性（持久化、consumer group）與錯誤處理策略。

參考資源（已放在 Obsidian Vault）：
- [[README]]（專案說明、快速上手、程式碼結構）
- [[115 | 通过Spring Cloud Stream访问RabbitMQ]]（錄音逐字稿，教學說明與操作流程）
外部官方文件：Spring Cloud Stream、RabbitMQ、Spring Boot Actuator（請參考 README 中列出的連結）

#### 二、 系統概觀與設計動機

本專案以「咖啡店訂單系統」示範事件驅動微服務：Customer → Waiter Service → RabbitMQ → Barista Service。設計理由與優勢包括：
- 非同步、解耦：服務間以訊息交換，降低同步呼叫的耦合度。 【重點】
- 可擴展性：多個 Barista 節點可作為同一 consumer group 的成員擴展消費能力。 【重點】
- 高可用與可靠性：透過訊息持久化與重試/死信機制提升可靠性。

用比喻說明：把訊息當成包裹，RabbitMQ 是郵局，Exchange 決定要把包裹分送到哪些信箱（Queue），consumer group 是同一個店面內幾個工作人員分攤處理相同類型包裹。

過渡：了解整體動機後，我們接著看 Spring Cloud Stream 與 RabbitMQ 在程式與配置上的具體呈現。

#### 三、 Spring Cloud Stream 與 RabbitMQ 的技術要點

- 核心概念  
  - 函數式模型（Spring Cloud Stream 4.x）：以 Function/Consumer/Supplier Bean 表示訊息處理邏輯，透過 spring.cloud.function.definition 指定函數對應。 【重點】  
  - Bindings：使用 spring.cloud.stream.bindings.[functionName]-in-0/out-0.destination 指定 exchange/queue 名稱。  
  - StreamBridge：在函數式模型下，用來動態發送訊息到指定的 binding（取代舊式 MessageChannel 注入/使用）。【重點】

- 依賴與 Starter  
  - 引入 spring-cloud-starter-stream-rabbit 即可獲得 RabbitMQ 的支援（底層還會加入 spring-cloud-starter-amqp）。【重點】

- RabbitMQ 基本名詞（快速回顧）  
  - Exchange：訊息進入點，負責路由到 Queue。  
  - Queue：實際儲存訊息，consumer 從 Queue 消費。  
  - Binding & Routing Key：決定 Exchange 與 Queue 的對應。  
  - delivery-mode=persistent：確保訊息持久化，避免訊息遺失。 【重點】

過渡：理解這些概念後，接下來把焦點放在實際程式與配置上。

#### 四、 重點程式流程與配置說明（理論對應實作）

- Waiter Service：更新狀態並發送訊息
  - 流程：API 收到 PUT 更新狀態 → 檢查狀態機（只允許 INIT → PAID） → 存資料庫 → 若為 PAID，使用 StreamBridge.send 發送 orderId 到 Barista 的 newOrders queue。  
  - 程式要點：使用 MessageBuilder.withPayload(order.getId()).build() 建構訊息；log 記錄發送結果。  
  - 【重點】狀態機檢查可避免非法狀態轉換；發送僅傳遞必要識別（如 orderId），減少序列化複雜度。

- Barista Service：接收並處理新訂單
  - 使用 Consumer\<Long> newOrders() Bean 接收 orderId，讀取資料庫、設為 BREWING、填入 barista 名稱、儲存、最後發送 finishedOrders 訊息回 Waiter。  
  - 可用 StreamBridge.send 或定義 finishedOrders-out-0 綁定來發送。  
  - 【重點】接收到的 payload 通常為 lightweight 的識別值，服務端再去查 DB 可維持 message size 小與服務責任分離。

- 配置範例（要點）
  - Waiter: 
    - spring.cloud.function.definition=finishedOrders
    - spring.cloud.stream.bindings.finishedOrders-in-0.destination=finishedOrders
    - spring.cloud.stream.bindings.newOrders-out-0.destination=newOrders
  - Barista: 
    - spring.cloud.function.definition=newOrders
    - spring.cloud.stream.bindings.newOrders-in-0.destination=newOrders
    - spring.cloud.stream.bindings.finishedOrders-out-0.destination=finishedOrders
  - consumer group：設定 group（例如 waiter-service / barista-service）避免重複消費或實作群體分工。 【重點】

過渡：完成程式與配置說明後，馬上示範如何在本機環境跑起來並測試。

#### 五、 實戰演示（實作步驟與測試）

- 環境啟動（Docker）
  1. 啟動 MariaDB：
     docker run --name mariadb -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=springbucks -e MYSQL_USER=springbucks -e MYSQL_PASSWORD=springbucks -p 3306:3306 -d mariadb:latest
  2. 啟動 RabbitMQ（含管理介面）：
     docker run --name rabbitmq -e RABBITMQ_DEFAULT_USER=spring -e RABBITMQ_DEFAULT_PASS=spring -p 5672:5672 -p 15672:15672 -d rabbitmq:3.7-management
  【重點】15672 可用來檢視 exchange/queue/binding。

- 編譯與啟動服務
  1. git clone \<repo> 並進入 Chapter 15 Spring Cloud Stream
  2. mvn clean compile 分別在 rabbitmq-waiter-service 與 rabbitmq-barista-service 執行
  3. 啟動 Waiter 與 Barista（各開一個終端機）：
     mvn spring-boot:run
  【重點】確保兩個服務的資料庫與 RabbitMQ 配置指向正確的 Host/Port/帳密。

- 功能測試（curl 或 Postman）
  1. 建立訂單：
     curl -X POST http://localhost:8080/order/ -H "Content-Type: application/json" -d '{"customer":"張三","items":["espresso","latte"]}'
  2. 支付訂單（觸發發送訊息）：
     curl -X PUT http://localhost:8080/order/1 -H "Content-Type: application/json" -d '{"state":"PAID"}'
  3. 查詢訂單狀態：
     curl http://localhost:8080/order/1
  - 在 RabbitMQ 管理介面（http://localhost:15672，spring/spring）觀察 exchange/queue 是否有 message 傳遞與綁定情形。  
  【重點】若訊息未被消費，檢查 exchange → queue 綁定與 consumer group 是否正確。

- 觀察日誌與除錯
  - Waiter 發送時應有 log 記錄 "Sent order X to barista for brewing."  
  - Barista 接收並處理時應有 "Receive a new Order X..." 與 "Order X is READY."  
  - 若未見訊息：檢查 binding destination 名稱、group、RabbitMQ 連線參數（host/port/user/pass）。

過渡：實作與測試完成後，整理兩種常見配置方式的差異，幫助選擇設計策略。

#### 六、 課程小結與後續展望

- 差異總結：函數式模型（StreamBridge） vs 傳統 MessageChannel/注入方式
  - 函數式模型（Spring Cloud Stream 4.x）
    - 優點：與 Spring Function 結合更自然、易於測試、可用 StreamBridge 動態發送；較現代化、與 Spring Cloud Stream 新版本相容。 【重點】
    - 缺點：對習慣舊 API 的團隊可能需學習曲線；某些進階配置語法與舊版本不同。
  - 傳統 MessageChannel / @StreamListener 或直接注入 Channel
    - 優點：概念直觀、較多現有專案採用、可以直接注入 Channel 操作（例如 messageChannel.send）。  
    - 缺點：較不符合函數化趨勢，與 Spring Function 整合度較低，未來方向可能以函數式為主。
  - 選擇建議：新專案建議採用函數式模型與 StreamBridge；維護舊專案可視情況逐步遷移。 【重點】

- 下一章預告  
  - 下一章將介紹「多資料源配置」，教你怎麼在微服務中管理多個資料來源（例如讀寫分離、不同資料庫類型共存），並說明與事件驅動流程整合時的注意事項。

#### 七、 Tips（教學與實務小撇步）

- 配置與命名一致性：Exchange/Queue/Binding 的命名務必在所有服務中一致，避免因拼字或前綴錯誤導致訊息無法路由。 【重點】
- 訊息設計：傳送輕量識別（如 orderId），讓消費端到 DB 查完整資料，降低跨服務序列化複雜度。  
- 訊息持久化：設定 delivery-mode=persistent，並在 RabbitMQ 設定合適的 queue durability。  
- consumer group：每個服務應有唯一 group，避免重複消費或衝突。  
- 錯誤處理：實作重試與死信佇列（DLQ），并在消費端記錄失敗資訊以便補償處理。  
- 監控：整合 Actuator、Prometheus，並定期觀察 RabbitMQ 的 queue 長度與 consumer lag。  
- 測試技巧：使用 TryRabbitMQ（或 RabbitMQ 管理 UI）模擬訊息流向，快速定位交換器與隊列的綁定情況。

【快速問題排除】
- 訊息發送後沒有被消費？檢查 Exchange → Queue 綁定、consumer group 是否相符、服務是否在同一 Virtual Host。
- 服務啟動失敗？檢查端口被占用、RabbitMQ/MariaDB 是否已啟動，以及配置檔的 host/port/user/password。

結語：本章把理論、實作與操作工具串起來，重點在於理解「以輕量訊息交換實現服務解耦」的設計哲學與實務細節。建議同學實際跟著專案跑一次，並在 RabbitMQ 管理介面觀察訊息流向，以加深理解。若需要，我可以把本講義轉成投影片大綱或示範課程的逐步講稿（含投影片要點與講解提示）。

---
### 116 | 通過Spring Cloud Stream訪問Kafka  ― []
---
### 117 | SpringBucks實戰項目進度小結  ― []
---
# Chapter 16：服務鏈路追蹤 (6講)
### 118 | 通過Dapper理解鏈路治理  ― []
---
### 119 | 使用Spring Cloud Sleuth實現鏈路追蹤  ― []
---
### 120 | 如何追蹤消息鏈路  ― []
---
### 121 | 除了鏈路還要治理什麼  ― []
---
### 122 | SpringBucks實戰項目進度小結  ― []
---
### 123 | 結課測試&結束語  ― []
---
